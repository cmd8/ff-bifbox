// Define KSP parameters
string KSPparams = "";
string EPSparams = " -eps_pos_gen_non_hermitian ";
// RESIDUAL VECTOR
  varf vR(defu(um), defu(v))
      = int2d(Th)(
        ugradu(v, ub, 0, ub) - divu(0, v)*ubp + visc(0, v, 0, ub)/params["Re"]
        + vp*divu(0, ub)
      )
      - int1d(Th, BCopen) (
        ndotvisc(v, 0, ub)/params["Re"]
      )
      + BoundaryConditions(0, um, ub);

// JACOBIAN MATRIX
varf vJ(defu(um), defu(v))
      = int2d(Th)(
        iomega*vdotu(v, um)
        + ugradu(v, um, 0, ub) + ugradu(v, ub, ik, um) - divu(-ik, v)*ump + visc(-ik, v , ik, um )/params["Re"]
        + vp*divu(ik, um)
      )
      - int1d(Th, BCopen) (
        ndotvisc(v, ik, um)/params["Re"]
      )
      + HomBoundaryConditions(m, um);

// MASS MATRIX
varf vM(defu(um), defu(v))
      = int2d(Th)(
          vdotu(um, v)
      )
      + HomBoundaryConditions(m, um);

// HESSIAN MATRIX
IFMACRO(Hessian)
varf vJq(defu(dum), defu(v))
      = int2d(Th)(
        iomega*vdotu(v, um)
        + ugradu(v, um, 0, ub) + ugradu(v, ub, ik, um) - divu(-ik, v)*ump + visc(-ik, v , ik, um )/params["Re"]
        + vp*divu(ik, um)
      )
      - int1d(Th, BCopen) (
        ndotvisc(v, ik, um)/params["Re"]
      )
      + HomBoundaryConditions(m, dum);

varf vH(defu(dub), defu(v))
      = int2d(Th)(
        ugradu(v, um, 0, dub) + ugradu(v, dub, ik, um)
      + HomBoundaryConditions(0, dub);

varf vMq(defu(dum), defu(v))
      = int2d(Th)(
          1i*vdotu(v, um)
      )
      + HomBoundaryConditions(m, dum);
ENDIFMACRO
