//
// modecompute.edp
// Chris Douglas
// chris.douglas@ladhyx.polytechnique.fr
//
// EXAMPLE USAGE:
//  Compute eigenvalues, store specrum without storing eigenvectors:
// mpirun -n 4 FreeFem++-mpi -v 0 modecompute.edp -eps_target 0.1+1.0i -eps_nev 10 -fi <FILEIN> -so <VALFILE>
//
//  Compute eigenvalues, store spectrum with eigenvectors:
// mpirun -n 4 FreeFem++-mpi -v 0 modecompute.edp -eps_target 0.1+1.0i -eps_nev 4 -fi <FILEIN> -fo <VALFILE>
//
// NOTE: This file should not be changed unless you know what you're doing.
//
load "iovtk"
load "PETSc-complex"
include "settings.idp"
include "macros_bifbox.idp"
// arguments
string meshin = getARGV("-mi", ""); // input meshfile
string filein = getARGV("-fi", "");
string fileout = getARGV("-fo", "");
string evalout = getARGV("-so", fileout);
bool adj = getARGV("-adj",0);
int m = getARGV("-m", 0);
string epstarget = getARGV("-eps_target", "0+0i");
int epsnev = getARGV("-eps_nev", 1);
bool strictnev = getARGV("-strict", 0);
string sttype = getARGV("-st_type", "sinvert");
string stpctype = getARGV("-st_pc_type", "lu");

string fileroot;
string fileext = parsefilename(filein, fileroot); //extract file name and extension
parsefilename(evalout, evalout); // trim extension from output file, if given
parsefilename(fileout, fileout); // trim extension from output file, if given
if(fileext == "mode" || fileext == "rslv"){
  filein = readbasename(workdir + filein);
  fileext = parsefilename(filein, fileroot);
}
if(filein != "" && meshin == "") meshin = readmeshname(workdir + filein); // get mesh file

// Load mesh, make FE basis
Th = readmeshN(workdir + meshin);
Thg = Th;
buildDmesh(Th);
restu = restrict(XMh, XMhg, n2o);
XMh defu(ub);
if(fileext == "base") {
  ub[] = loadbase(fileroot, meshin);
} else if(fileext == "fold") {
  real[int] qm, qma;
  ub[] = loadfold(fileroot, meshin, qm, qma);
} else if(fileext == "hopf") {
  complex[int] qm, qma;
  int m;
  real omega;
  ub[] = loadhopf(fileroot, meshin, qm, qma, m, omega);
}
complex[int] val(epsnev);
XMh<complex>[int] defu(vec)(epsnev);
XMh<complex> defu(um);

Mat<complex> J;
createMatu(Th, J, Pk);
Mat<complex> M(J);
complex ik, iomega = 0.0; // Let PETSc/SLEPc do the shift
include "eqns.idp"

{
  ik = 1i*real(m);
  {
    matrix<complex> Jtemp = vJ(XMh, XMh, tgv = -1);
    matrix<complex> Mtemp = vM(XMh, XMh, tgv = -10);
    if (adj) {
      Jtemp = -Jtemp';
      Mtemp = Mtemp';
    } else Jtemp = -Jtemp;
    J = Jtemp;
    M = Mtemp;
  }
  int k = EPSSolve(J, M, vectors = vec, values = val,
                 sparams = " -st_type " + sttype
                         + " -st_pc_type " + stpctype
                         + " -eps_target " + epstarget
                         + " -eps_monitor_conv " + EPSparams);
  if (strictnev) {// activate to limit number of eigenpairs
    val.resize(min(k, epsnev));
    vec.resize(min(k, epsnev));
  }
  if(fileout != ""){
    for (int ii = 0; ii < val.n; ++ii){
      um[] = vec[ii][];
      complex[int] temp(XMh.ndof);
      ChangeNumbering(J, um[], temp);
      ChangeNumbering(J, um[], temp, inverse = true);
      vec[ii][] = um[];
    }
  }
  savemode(fileout, evalout, filein, meshin, vec, val, m, (fileout != ""));
}
