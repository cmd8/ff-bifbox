//
// modecompute.edp
// Chris Douglas
// chris.douglas@ladhyx.polytechnique.fr
//
// EXAMPLE USAGE:
//  Compute eigenvalues, store specrum without storing eigenvectors:
// mpirun -n 4 FreeFem++-mpi -v 0 modecompute.edp -eps_target 0.1+1.0i -eps_nev 10 -bfi <FILEIN> -vfo <VALFILE>
//
//  Compute eigenvalues, store eigenvectors without storing spectrum:
// mpirun -n 4 FreeFem++-mpi -v 0 modecompute.edp -eps_target 0.1+1.0i -eps_nev 4 -bfi <FILEIN> -mfo <VALFILE>
//
// NOTE: This file should not be changed unless you know what you're doing.
//
load "iovtk"
load "PETSc-complex"
include "solversettings.idp"
include "solvermacros.idp"
// arguments
string basefilein = getARGV("-bfi", "");
string modefilein = getARGV("-mfi", "");
string foldfilein = getARGV("-ffi", "");
string hopffilein = getARGV("-hfi", "");
string evalfileout = getARGV("-vfo", "");
string modefileout = getARGV("-mfo", "");
bool paraviewflag = getARGV("-pvo", 0); // toggle whether solution is also saved in Paraview format
int meshsplit = getARGV("-split", 1); // toggle whether mesh is split for P1 representation in Paraview
bool adj = getARGV("-adj",0);
int m = getARGV("-m", 0);
string epstarget = getARGV("-eps_target", "0+0i");
int epsnev = getARGV("-eps_nev", 1);
bool strictnev = getARGV("-strict", 0);
string sttype = getARGV("-st_type", "sinvert");
string stpctype = getARGV("-st_pc_type", "lu");

if (hopffilein == "" && foldfilein == "" && basefilein == ""  && modefilein != "") basefilein = readbasename(workdir + modefilein + ".mode");
string meshfile;
if(foldfilein != "") meshfile = readmeshname(workdir + foldfilein + ".fold");
else if(hopffilein != "") meshfile = readmeshname(workdir + hopffilein + ".hopf");
else meshfile = readmeshname(workdir + basefilein + ".base");

// Load mesh, make FE basis
Th = readmeshN(workdir + meshfile + meshext);
Thg = Th;
buildDmesh(Th);
restu = restrict(XMh, XMhg, n2o);
XMh defu(ub);
if(foldfilein != "") {
  real[int] qm, qma;
  ub[] = loadfold(workdir, foldfilein, meshfile, qm, qma);
} else if(hopffilein != "") {
  complex[int] qm, qma;
  int m;
  real omega;
  ub[] = loadhopf(workdir, hopffilein, meshfile, qm, qma, m, omega);
} else {
  ub[] = loadbase(workdir, basefilein, meshfile);
}
complex[int] val(epsnev);
XMh<complex>[int] defu(vec)(epsnev);
XMh<complex> defu(um);

if (epstarget == "0+0i" && modefilein != "") {
  complex target = readmodeeval(workdir + modefilein + ".mode", m);
  if (adj) target = conj(target);
  epstarget = string(target);
}

Mat<complex> J;
createMatu(Th, J, Pk);
Mat<complex> M(J);
complex ik = 1i*real(m);
complex iomega = 0.0; // Let PETSc/SLEPc do the shift
IFMACRO(formulation,incomp)
include "eqns_incomp.idp"
ENDIFMACRO
IFMACRO(formulation,lowmach)
include "eqns_lowmach.idp"
ENDIFMACRO
IFMACRO(formulation,comp)
include "eqns_comp.idp"
ENDIFMACRO
IFMACRO(formulation,lowmachreact)
include "eqns_lowmachreact.idp"
ENDIFMACRO
IFMACRO(formulation,compreact)
include "eqns_compreact.idp"
ENDIFMACRO
IFMACRO(formulation,custom)
include "eqns_custom.idp"
ENDIFMACRO

{
  matrix<complex> Jtemp = vJ(XMh, XMh, tgv = -1);
  matrix<complex> Mtemp = vM(XMh, XMh, tgv = -10);
  if (adj) {
    Jtemp = -Jtemp';
    Mtemp = Mtemp';
  } else Jtemp = -Jtemp;
  J = Jtemp;
  M = Mtemp;
}
int k = EPSSolve(J, M, vectors = vec, values = val,
                 sparams = " -st_type " + sttype
                         + " -st_pc_type " + stpctype
                         + " -eps_target " + epstarget
                         + " -eps_monitor_conv " + EPSparams);
if (strictnev) k = min(k, epsnev); // activate to limit number of eigenpairs
if (evalfileout != "" && mpirank == 0){
  cout << "  Writing " + k + " eigenvalues to '" + evalfileout + ".txt' in '" + workdir + "'." << endl;
  { ofstream file(workdir + evalfileout + ".txt", append);
    file.precision(17);
    file.scientific;
    for(int i = 0; i < k; ++i) file << m + "\t" + val(i) << endl;
  }
}
if (modefileout != ""){
  for (int i = 0; i < k; ++i){
    complex eigenvalue = val(i);
    um[] = vec[i][];
    complex[int] dummy;
    ChangeNumbering(J, um[], dummy);
    ChangeNumbering(J, um[], dummy, inverse = true);
    if (basefilein == ""){
      complex[int] qb(ub[].n);
      qb.re = ub[];
      ChangeNumbering(J, qb, dummy);
      ChangeNumbering(J, qb, dummy, inverse = true);
      ub[] = qb.re;
      savebase(workdir, modefileout, "", meshfile, true, true, paraviewflag);
      basefilein = modefileout;
    }
    savemode(workdir, modefileout + "_" + i, basefilein, meshfile, m, eigenvalue, paraviewflag);
  }
}
