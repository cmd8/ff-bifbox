// Define KSP parameters
string KSPparams = "";
string EPSparams = " -eps_pos_gen_non_hermitian ";
// RESIDUAL OPERATOR
varf vR(defu(um), defu(v))
      = int2d(Th)(
        vT*ugradf(ub, 0, ubT)/ubT + ubT^(params["a"])*diff(0, vT, 0, ubT)/params["Pe"]
        + ugradu(v, ub, 0, ub)/ubT - divu(0, v)*ubp + ubT^(params["a"])*visc(0, v , 0, ub )/params["Re"]
        - vp*divu(0, ub) - ubT^(params["a"])*diff(0, vp, 0, ubT)/params["Pe"]
      )
      - int1d(Th, BCopen) (
        0.5*vdotu(v, ub)*min(0., real(ndotu(ub)))/ubT
        + ubT^(params["a"])*ndotvisc(v, 0, ub)/params["Re"]
      )
      + int1d(Th, BCaxis, BCopen, BCwall, BCpipe, BCinflow, BCslip) (
          vp*ubT^(params["a"])*ndotgrads(ubT)/params["Pe"]
      )
      + BoundaryConditions(0, um, ub);

// JACOBIAN OPEARTOR
varf vJ(defu(dum), defu(v))
      = int2d(Th)(
        iomega*(gdotf(vT, dumT) + vdotu(v, dum))/ubT
        + vT*(ugradf(dum, 0, ubT) + ugradf(ub, ik, dumT) - ugradf(ub, 0, ubT)*dumT/ubT)/ubT + (ubT^(params["a"])*diff(-ik, vT, ik, dumT) + params["a"]*ubT^(params["a"]-1.)*dumT*diff(-ik, vT, 0, ubT))/params["Pe"]
        + (ugradu(v, dum, 0, ub) + ugradu(v, ub, ik, dum) - ugradu(v, ub, 0, ub)*dumT/ubT)/ubT - divu(-ik, v)*dump + (ubT^(params["a"])*visc(-ik, v , ik, dum ) + params["a"]*ubT^(params["a"]-1.)*dumT*visc(-ik, v , 0, ub ))/params["Re"]
        - vp*divu(ik, dum) - (ubT^(params["a"])*diff(-ik, vp, ik, dumT) + params["a"]*ubT^(params["a"]-1.)*dumT*diff(-ik, vp, 0, ubT))/params["Pe"]
      )
      - int1d(Th, BCopen) (
        0.5*(real(ndotu(ub)) < 0)*(vdotu(v, dum)*ndotu(ub) + vdotu(v, ub)*ndotu(dum) - vdotu(v, ub)*ndotu(ub)*dumT/ubT)/ubT
        + (ubT^(params["a"])*ndotvisc(v, ik, dum) + params["a"]*ubT^(params["a"] - 1.0)*dumT*ndotvisc(v, 0, ub))/params["Re"]
      )
      + int1d(Th, BCaxis, BCopen, BCwall, BCpipe, BCinflow, BCslip) (
        vp*(ubT^(params["a"])*ndotgrads(dumT) + params["a"]*ubT^(params["a"]-1.)*dumT*ndotgrads(ubT))/params["Pe"]
      )
      + int2d(Th)(
        iomega*(gdotf(vT, umT) + vdotu(v, um))/ubT
        + vT*(ugradf(um, 0, ubT) + ugradf(ub, ik, umT) - ugradf(ub, 0, ubT)*umT/ubT)/ubT + (ubT^(params["a"])*diff(-ik, vT, ik, umT) + params["a"]*ubT^(params["a"]-1.)*umT*diff(-ik, vT, 0, ubT))/params["Pe"]
        + (ugradu(v, um, 0, ub) + ugradu(v, ub, ik, um) - ugradu(v, ub, 0, ub)*umT/ubT)/ubT - divu(-ik, v)*ump + (ubT^(params["a"])*visc(-ik, v , ik, um ) + params["a"]*ubT^(params["a"]-1.)*umT*visc(-ik, v , 0, ub ))/params["Re"]
        - vp*divu(ik, um) - (ubT^(params["a"])*diff(-ik, vp, ik, umT) + params["a"]*ubT^(params["a"]-1.)*umT*diff(-ik, vp, 0, ubT))/params["Pe"]
      )
      - int1d(Th, BCopen) (
        0.5*(real(ndotu(ub)) < 0)*(vdotu(v, um)*ndotu(ub) + vdotu(v, ub)*ndotu(um) - vdotu(v, ub)*ndotu(ub)*umT/ubT)/ubT
        + (ubT^(params["a"])*ndotvisc(v, ik, um) + params["a"]*ubT^(params["a"] - 1.0)*umT*ndotvisc(v, 0, ub))/params["Re"]
      )
      + int1d(Th, BCaxis, BCopen, BCwall, BCpipe, BCinflow, BCslip) (
        vp*(ubT^(params["a"])*ndotgrads(umT) + params["a"]*ubT^(params["a"]-1.)*umT*ndotgrads(ubT))/params["Pe"]
      )
      + HomBoundaryConditions(sym, dum);

// MASS OPERATOR
varf vM(defu(dum), defu(v))
      = int2d(Th)(
          (gdotf(vT, dumT) + vdotu(v, dum))/ubT
      )
      + int2d(Th)(
          (gdotf(vT, umT) + vdotu(v, um))/ubT
      )
      + HomBoundaryConditions(sym, dum);

// FORCING/RESPONSE WEIGHTING MATRICES (FOR RESOLVENT ANALYSIS)
varf vMq(defu(dum), defu(v))
      = int2d(Th)( (gdotf(vT, dumT) + vdotu(v, dum))/ubT );

varf vMf(deff(dum), deff(v))
      = int2d(Th)( vdotu(v, dum)/ubT );

varf vP(deff(fm), defu(v))
      = int2d(Th)( vdotu(v, fm) );

// HESSIAN OPERATOR
varf vH(defu(dum), defu(v))
      = int2d(Th)(
        -iomega*(gdotf(vT, umT) + vdotu(v, um))*um2T/ubT^2. - iomega2*(gdotf(vT, um2T) + vdotu(v, um2))*umT/ubT^2.
        + vT*(ugradf(um, ik2, um2T)   + ugradf(um2, ik, umT)   - ((ugradf(um, 0, ubT)   + ugradf(ub, ik, umT))*um2T   + (ugradf(um2, 0, ubT)   + ugradf(ub, ik2, um2T))*umT)/ubT   + 2.0*um2T*ugradf(ub, 0, ubT)*umT/ubT^2.)/ubT
            + params["a"]*ubT^(params["a"]-1.)*(um2T*diff(-ik-ik2, vT, ik, umT) + umT*diff(-ik-ik2, vT, ik2, um2T) + (params["a"]-1.)*um2T/ubT*umT*diff(-ik-ik2, vT, 0, ubT))/params["Pe"]
        + (ugradu(v, um, ik2, um2) + ugradu(v, um2, ik, um) - ((ugradu(v, um, 0, ub) + ugradu(v, ub, ik, um))*um2T + (ugradu(v, um2, 0, ub) + ugradu(v, ub, ik2, um2))*umT)/ubT + 2.0*um2T*ugradu(v, ub, 0, ub)*umT/ubT^2.)/ubT
            + params["a"]*ubT^(params["a"]-1.)*(um2T*visc(-ik-ik2, v , ik, um ) + umT*visc(-ik-ik2, v , ik2, um2 ) + (params["a"]-1.)*um2T/ubT*umT*visc(-ik-ik2, v , 0, ub ))/params["Re"]
        - params["a"]*ubT^(params["a"]-1.)*(um2T*diff(-ik-ik2, vp, ik, umT) + umT*diff(-ik-ik2, vp, ik2, um2T) + (params["a"]-1.)*um2T/ubT*umT*diff(-ik-ik2, vp, 0, ubT))/params["Pe"]
      )
      - int1d(Th, BCopen) (
        0.5*(real(ndotu(ub)) < 0)*((vdotu(v, um)*ndotu(um2) + vdotu(v, um2)*ndotu(um))/ubT - (vdotu(v, um)*ndotu(ub) + vdotu(v, ub)*ndotu(um))*um2T/ubT^2. - (vdotu(v, um2)*ndotu(ub) + vdotu(v, ub)*ndotu(um2) - 2.0*vdotu(v, ub)*ndotu(ub)*um2T/ubT)*umT/ubT^2)
        + params["a"]*ubT^(params["a"]-1.)*(um2T*ndotvisc(v, ik, um) + umT*ndotvisc(v, ik2, um2) + (params["a"]-1.)*um2T/ubT*umT*ndotvisc(v, 0, ub))/params["Re"]
      )
      + int1d(Th, BCaxis, BCopen, BCwall, BCpipe, BCinflow, BCslip) (
        vp*params["a"]*ubT^(params["a"]-1.)*(um2T*ndotgrads(umT) + umT*ndotgrads(um2T) + (params["a"]-1.)*um2T/ubT*umT*ndotgrads(ubT))/params["Pe"]
      )
      + int2d(Th)(
        -iomega*(gdotf(vT, umT) + vdotu(v, um))*dumT/ubT^2. - iomega2*(gdotf(vT, dumT) + vdotu(v, dum))*umT/ubT^2.
        + vT*(ugradf(um, ik2, dumT)   + ugradf(dum, ik, umT)   - ((ugradf(um, 0, ubT)   + ugradf(ub, ik, umT))*dumT   + (ugradf(dum, 0, ubT)   + ugradf(ub, ik2, dumT))*umT)/ubT   + 2.0*dumT*ugradf(ub, 0, ubT)*umT/ubT^2.)/ubT
            + params["a"]*ubT^(params["a"]-1.)*(dumT*diff(-ik-ik2, vT, ik, umT) + umT*diff(-ik-ik2, vT, ik2, dumT) + (params["a"]-1.)*dumT/ubT*umT*diff(-ik-ik2, vT, 0, ubT))/params["Pe"]
        + (ugradu(v, um, ik2, dum) + ugradu(v, dum, ik, um) - ((ugradu(v, um, 0, ub) + ugradu(v, ub, ik, um))*dumT + (ugradu(v, dum, 0, ub) + ugradu(v, ub, ik2, dum))*umT)/ubT + 2.0*dumT*ugradu(v, ub, 0, ub)*umT/ubT^2.)/ubT
            + params["a"]*ubT^(params["a"]-1.)*(dumT*visc(-ik-ik2, v , ik, um ) + umT*visc(-ik-ik2, v , ik2, dum ) + (params["a"]-1.)*dumT/ubT*umT*visc(-ik-ik2, v , 0, ub ))/params["Re"]
        - params["a"]*ubT^(params["a"]-1.)*(dumT*diff(-ik-ik2, vp, ik, umT) + umT*diff(-ik-ik2, vp, ik2, dumT) + (params["a"]-1.)*dumT/ubT*umT*diff(-ik-ik2, vp, 0, ubT))/params["Pe"]
      )
      - int1d(Th, BCopen) (
        0.5*(real(ndotu(ub)) < 0)*((vdotu(v, um)*ndotu(dum) + vdotu(v, dum)*ndotu(um))/ubT - (vdotu(v, um)*ndotu(ub) + vdotu(v, ub)*ndotu(um))*dumT/ubT^2. - (vdotu(v, dum)*ndotu(ub) + vdotu(v, ub)*ndotu(dum) - 2.0*vdotu(v, ub)*ndotu(ub)*dumT/ubT)*umT/ubT^2.)
        + params["a"]*ubT^(params["a"]-1.)*(dumT*ndotvisc(v, ik, um) + umT*ndotvisc(v, ik2, dum) + (params["a"]-1.)*dumT/ubT*umT*ndotvisc(v, 0, ub))/params["Re"]
      )
      + int1d(Th, BCaxis, BCopen, BCwall, BCpipe, BCinflow, BCslip) (
        vp*params["a"]*ubT^(params["a"]-1.)*(dumT*ndotgrads(umT) + umT*ndotgrads(dumT) + (params["a"]-1.)*dumT/ubT*umT*ndotgrads(ubT))/params["Pe"]
      )
      + HomBoundaryConditions(sym, dum);

// TRESSIAN OPERATOR (FOR WEAKLY NONLINEAR ANALYSIS)
varf vT(defu(dum), defu(v))
      = int2d(Th)(
        2.0*iomega*(gdotf(vT, umT) + vdotu(v, um))*um2T*dumT/ubT^3.
        + vT*(-dumT*(ugradf(um, ik2, um2T) + ugradf(um2, ik, umT)) - ugradf(um2, ik3, dumT)*umT - ugradf(um, ik3, dumT)*um2T + 2.0*dumT*um2T/ubT*(ugradf(um, 0, ubT)*um2T/ubT + ugradf(ub, ik, umT)) + 2.0*dumT*umT/ubT*(ugradf(um2, 0, ubT) + ugradf(ub, ik2, um2T)) + 2.0*um2T*umT/ubT*(ugradf(dum, 0, ubT) + ugradf(ub, ik3, dumT)) - 6.0*dumT*um2T*ugradf(ub, 0, ubT)*umT/ubT^2.)/ubT^2.
            + params["a"]*(params["a"]-1.)*ubT^(params["a"]-2.)*(dumT*(um2T*diff(-ik-ik2-ik3, vT, ik, umT) + umT*diff(-ik-ik2-ik3, vT, ik2, um2T)) + um2T*umT*diff(-ik-ik2-ik3, vT, ik3, dumT) + (params["a"]-2.)*dumT/ubT*um2T*umT*diff(-ik-ik2-ik3, vT, 0, ubT))/params["Pe"]
        + (-dumT*(ugradu(v, um, ik2, um2) + ugradu(v, um2, ik, um)) - ugradu(v, um2, ik3, dum)*umT - ugradu(v, um, ik3, dum)*um2T + 2.0*dumT*um2T/ubT*(ugradu(v, um, 0, ub)*um2T/ubT + ugradu(v, ub, ik, um)) + 2.0*dumT*umT/ubT*(ugradu(v, um2, 0, ub) + ugradu(v, ub, ik2, um2)) + 2.0*um2T*umT/ubT*(ugradu(v, dum, 0, ub) + ugradu(v, ub, ik3, dum)) - 6.0*dumT*um2T*ugradu(v, ub, 0, ub)*umT/ubT^2.)/ubT^2.
            + params["a"]*(params["a"]-1.)*ubT^(params["a"]-2.)*(dumT*(um2T*visc(-ik-ik2-ik3, v, ik, um ) + umT*visc(-ik-ik2-ik3, v, ik2, um2 )) + um2T*umT*visc(-ik-ik2-ik3, v, ik3, dum) + (params["a"]-2.)*dumT/ubT*um2T*umT*visc(-ik-ik2-ik3, v, 0, ub ))/params["Re"]
        - params["a"]*(params["a"]-1.)*ubT^(params["a"]-2.)*(dumT*(um2T*diff(-ik-ik2-ik3, vp, ik, umT) + umT*diff(-ik-ik2-ik3, vp, ik2, um2T)) + um2T*umT*diff(-ik-ik2-ik3, vp, ik3, dumT) + (params["a"]-2.)*dumT/ubT*um2T*umT*diff(-ik-ik2-ik3, vp, 0, ubT))/params["Pe"]
      )
      - int1d(Th, BCopen) (
        0.5*(real(ndotu(ub)) < 0)*(-dumT*(vdotu(v, um)*ndotu(um2) + vdotu(v, um2)*ndotu(um)) - umT*(vdotu(v, um2)*ndotu(ub) + vdotu(v, ub)*ndotu(um2)) - um2T*(vdotu(v, um)*ndotu(dum) + vdotu(v, dum)*ndotu(um)) + 2.0/ubT*(dumT*umT*(vdotu(v, um2)*ndotu(ub) + vdotu(v, ub)*ndotu(um2)) + dumT*um2T*(vdotu(v, um)*ndotu(ub) + vdotu(v, ub)*ndotu(um)) + um2T*umT*(vdotu(v, dum)*ndotu(ub) + vdotu(v, ub)*ndotu(dum))) - 6.0*dumT*vdotu(v, ub)*ndotu(ub)*um2T*umT/ubT^2.)/ubT^2.
        + params["a"]*(params["a"]-1.)*ubT^(params["a"]-2.)*(dumT*um2T*ndotvisc(v, ik, um) + dumT*umT*ndotvisc(v, ik2, um2) + um2T*umT*ndotvisc(v, ik3, dum) + (params["a"]-2.)*dumT/ubT*um2T*umT*ndotvisc(v, 0, ub))/params["Re"]
      )
      + int1d(Th, BCaxis, BCopen, BCwall, BCpipe, BCinflow, BCslip) (
        vp*params["a"]*(params["a"]-1.)*ubT^(params["a"]-2.)*(dumT*(um2T*ndotgrads(umT) + umT*ndotgrads(um2T)) + um2T*umT*ndotgrads(dumT) + (params["a"]-2.)*dumT/ubT*um2T*umT*ndotgrads(ubT))/params["Pe"]
      )
      + HomBoundaryConditions(sym, dum);
