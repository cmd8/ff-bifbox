//
// porbcompute.edp
// Chris Douglas
// cdoug@mit.edu
//
// EXAMPLE USAGE:
//  Initialize with guess from file, solve on same mesh
// mpirun -n 4 FreeFem++-mpi -v 0 porbcompute.edp -Re 1 -fi <FILEIN> -fo <FILEOUT> -Nh <N>
//
//  Initialize with guess from file, solve on different mesh
// mpirun -n 4 FreeFem++-mpi -v 0 porbcompute.edp -mi <MESHIN> -fi <FILEIN> -fo <FILEOUT>
//
//  Initialize with guess from file, adapt mesh/solution
// mpirun -n 4 FreeFem++-mpi -v 0 porbcompute.edp -fi <FILEIN> -fo <FILEOUT> -mo <MESHOUT>
//
// NOTE: This file should not be changed unless you know what you're doing.
//
load "iovtk"
load "PETSc"
include "settings.idp"
include "macros_bifbox.idp"
// arguments
string meshin = getARGV("-mi", ""); // input meshfile with extension
string meshout = getARGV("-mo", ""); // output mesh without extension
string filein = getARGV("-fi", ""); // input file with extension
string basefilein = getARGV("-bfi", "");
string fileout = getARGV("-fo", ""); // output file without extension
int hohoselect = getARGV("-hoho", 1);
bool zerofreq = getARGV("-zero", 0);
string adaptto = getARGV("-adaptto", "0");
string sneslinesearchtype = getARGV("-snes_linesearch_type","basic");
int Nh = getARGV("-Nh", 0); //if 0 will try to get from file, otherwise fail
int gmres = getARGV("-gmres", 0); //if 0 will try to get from file, otherwise fail
int sym, sym1;
real omega;

string fileroot, meshroot, basefileroot;
string fileext = parsefilename(filein, fileroot); //extract file name and extension
parsefilename(fileout, fileout); // trim extension from output file, if given
if((fileext == "mode" || fileext == "rslv") && basefilein == "") basefilein = readbasename(workdir + filein);
string basefileext = parsefilename(basefilein, basefileroot);
if(meshin == "") meshin = readmeshname(workdir + filein); // get mesh file
string meshext = parsefilename(meshin, meshroot);
parsefilename(meshout, meshout); // trim extension from output mesh, if given
if (fileext != "porb") Nh = max(1, Nh);
// Load mesh, make FE basis
Th = readmeshN(workdir + meshin);
Thg = Th;
buildDmesh(Th);
restu = restrict(XMh, XMhg, n2o);
XMh defu(ub);
XMh<complex> defu(um), defu(uma), defu(um2), defu(um3);
complex[int, int] uh(um[].n, Nh);
if (fileext == "porb") {
  ub[] = loadporb(fileroot, meshin, uh, sym1, omega, Nh);
}
else if (fileext == "hopf") {
  complex[string] alpha;
  complex beta;
  complex[int] qma;
  ub[] = loadhopf(fileroot, meshin, um[], qma, sym1, omega, alpha, beta);
  uh(:, 0) = um[];
}
else if (fileext == "foho") {
  real[string] alpha2;
  real beta22, beta23, gamma22, gamma23;
  complex[string] alpha;
  complex beta;
  complex gamma12, gamma13;
  real[int] q2m, q2ma;
  complex[int] qma;
  ub[] = loadfoho(fileroot, meshin, um[], qma, q2m, q2ma, sym1, omega, alpha, alpha2, beta, beta22, beta23, gamma12, gamma13, gamma22, gamma23);
  uh(:, 0) = um[];
}
else if(fileext == "hoho") {
  int symN;
  real omegaN;
  complex[string] alpha, alphaN;
  complex beta, betaN, gamma1, gamma2, gamma12, gamma13, gamma22, gamma23;
  complex[int] qma, qNm, qNma;
  if(hohoselect == 1){
    ub[] = loadhoho(fileroot, meshin, um[], qma, qNm, qNma, sym1, symN, omega, omegaN, alpha, alphaN, beta, betaN, gamma1, gamma2, gamma12, gamma13, gamma22, gamma23);
  }
  else if(hohoselect == 2){
    ub[] = loadhoho(fileroot, meshin, qNm, qNma, um[], qma, symN, sym1, omegaN, omega, alphaN, alpha, betaN, beta, gamma1, gamma2, gamma12, gamma13, gamma22, gamma23);
  }
  uh(:, 0) = um[];
}
else if (fileext == "mode") {
  complex eigenvalue;
  um[] = loadmode(fileroot, meshin, sym1, eigenvalue);
  omega = imag(eigenvalue);
}
else if (fileext == "rslv") {
  real gain;
  complex[int] fm;
  uh(:, 0) = loadrslv(fileroot, meshin, fm, sym1, omega, gain);
}
else assert(false); // invalid input filetype
Nh = max(1, Nh); // Nh must be at least 1, otherwise use basecompute.edp
if (basefileext == "base") {
  ub[] = loadbase(basefileroot, meshin);
}
else if(basefileext == "fold") {
  real[string] alpha;
  real beta;
  real[int] qm, qma;
  ub[] = loadfold(basefileroot, meshin, qm, qma, alpha, beta);
}
else if(basefileext == "hopf") {
  int sym;
  real omega;
  complex[string] alpha;
  complex beta;
  complex[int] qm, qma;
  ub[] = loadhopf(basefileroot, meshin, qm, qma, sym, omega, alpha, beta);
}
else if(basefileext == "foho") {
  int sym;
  real omega;
  complex[string] alpha1;
  complex beta1, gamma12, gamma13;
  real[string] alpha2;
  real beta22, beta23, gamma22, gamma23;
  complex[int] q1m, q1ma;
  real[int] q2m, q2ma;
  ub[] = loadfoho(basefileroot, meshin, q1m, q1ma, q2m, q2ma, sym, omega, alpha1, alpha2, beta1, beta22, beta23, gamma12, gamma13, gamma22, gamma23);
}
else if(basefileext == "hoho") {
  int sym1, sym2;
  real omega1, omega2;
  complex[string] alpha1, alpha2;
  complex beta1, beta2, gamma1, gamma2, gamma12, gamma13, gamma22, gamma23;
  complex[int] q1m, q1ma, q2m, q2ma;
  ub[] = loadhoho(basefileroot, meshin, q1m, q1ma, q2m, q2ma, sym1, sym2, omega1, omega2, alpha1, alpha2, beta1, beta2, gamma1, gamma2, gamma12, gamma13, gamma22, gamma23);
}
else if(basefileext == "tdns") {
  real time;
  ub[] = loadtdns(basefileroot, meshin, time);
}
else if (basefileext == "porb") {
  complex[int,int] qh(um[].n,1);
  int sym, Nh;
  real omega;
  ub[] = loadporb(basefileroot, meshin, qh, sym, omega, Nh);
}
// Create distributed Mat
Mat J;
createMatu(Th, J, Pk);
// MESH ADAPTATION
bool adapt = false;
if(meshout == "") meshout = meshin; // if no adaptation
else { // if output meshfile is given, adapt mesh
  adapt = true;
  meshout = meshout + "." + meshext;
  real[int] q, qm;
  ChangeNumbering(J, ub[], q);
  ChangeNumbering(J, ub[], q, inverse = true);
  for (int nh = 0; nh < Nh; nh++){
    ChangeNumbering([J, J], [uh(:, nh).re, uh(:, nh).im], qm);
    ChangeNumbering([J, J], [uh(:, nh).re, uh(:, nh).im], qm, inverse = true);
  }
  XMhg defu(uG), defu(u1rG), defu(u1iG), defu(u2rG), defu(u2iG), defu(tempu), defu(tempu2);
  real[int, int] uhrG(uG[].n, Nh), uhiG(uG[].n, Nh); // create private global FE functions
  tempu[](restu) = ub[]; // populate local portion of global soln
  mpiAllReduce(tempu[], uG[], mpiCommWorld, mpiSUM);
  for (int nh = 0; nh < Nh; nh++){
    tempu[](restu) = uh(:, nh).re;
    mpiAllReduce(tempu[], uhrG(:, nh), mpiCommWorld, mpiSUM);
    tempu[](restu) = uh(:, nh).im;
    mpiAllReduce(tempu[], uhiG(:, nh), mpiCommWorld, mpiSUM);
  }
  u1rG[] = uhrG(:, 0);
  u1iG[] = uhiG(:, 0);
  if (Nh > 1){
    u2rG[] = uhrG(:, 1);
    u2iG[] = uhiG(:, 1);
  }
  if(mpirank == 0) { // Perform mesh adaptation (serially) on processor 0
    IFMACRO(dimension,2)
      if(adaptto == "0") Thg = adaptmesh(Thg, adaptu(uG), adaptmeshoptions);
      else if(adaptto == "01") Thg = adaptmesh(Thg, adaptu(uG), adaptu(u1rG), adaptu(u1iG), adaptmeshoptions);
      else if(Nh > 1 && adaptto == "02") Thg = adaptmesh(Thg, adaptu(uG), adaptu(u2rG), adaptu(u2iG), adaptmeshoptions);
      else if(Nh > 1 && adaptto == "012") Thg = adaptmesh(Thg, adaptu(uG), adaptu(u1rG), adaptu(u1iG), adaptu(u2rG), adaptu(u2iG), adaptmeshoptions);
    ENDIFMACRO
    IFMACRO(dimension,3)
      cout << "NOTE: 3D mesh adaptation is still under development." << endl;
      load "mshmet"
      load "mmg"
      real anisomax = getARGV("-anisomax",1.0);
      real[int] met((bool(anisomax > 1) ? 6 : 1)*Thg.nv);
      if(adaptto == "0") met = mshmet(Thg, adaptu(uG), normalization = getARGV("-normalization",1), aniso = bool(anisomax > 1.0), hmin = getARGV("-hmin", 1.0e-6), hmax = getARGV("-hmax", 1.0e+2), err = getARGV("-err", 1.0e-2));
      else if(adaptto == "01") met = mshmet(Thg, adaptu(uG), adaptu(u1rG), adaptu(u1iG), normalization = getARGV("-normalization",1), aniso = bool(anisomax > 1.0), hmin = getARGV("-hmin", 1.0e-6), hmax = getARGV("-hmax", 1.0e+2), err = getARGV("-err", 1.0e-2));
      else if(Nh > 1 && adaptto == "02") met = mshmet(Thg, adaptu(uG), adaptu(u2rG), adaptu(u2iG), normalization = getARGV("-normalization",1), aniso = bool(anisomax > 1.0), hmin = getARGV("-hmin", 1.0e-6), hmax = getARGV("-hmax", 1.0e+2), err = getARGV("-err", 1.0e-2));
      else if(Nh > 1 && adaptto == "012") met = mshmet(Thg, adaptu(uG), adaptu(u1rG), adaptu(u1iG), adaptu(u2rG), adaptu(u2iG), normalization = getARGV("-normalization",1), aniso = bool(anisomax > 1.0), hmin = getARGV("-hmin", 1.0e-6), hmax = getARGV("-hmax", 1.0e+2), err = getARGV("-err", 1.0e-2));
      if(anisomax > 1.0) {
        load "aniso"
        boundaniso(6, met, anisomax);
      }
      Thg = mmg3d(Thg, metric = met, hmin = getARGV("-hmin", 1.0e-6), hmax = getARGV("-hmax", 1.0e+2), hgrad = -1, verbose = verbosity-(verbosity==0));
    ENDIFMACRO
  }
  broadcast(processor(0), Thg);
  defu(uG) = defu(uG);
  for (int nh = 0; nh < Nh; nh++){
    tempu[] = uhrG(:, nh);
    defu(tempu2) = defu(tempu);
    uhrG(:, nh) = tempu2[];
    tempu[] = uhiG(:, nh);
    defu(tempu2) = defu(tempu);
    uhiG(:, nh) = tempu2[];
  }
  Th = Thg; //Reinitialize local mesh with global mesh
  Mat Adapt;
  createMatu(Th, Adapt, Pk); // Partition new mesh and update the PETSc numbering
  J = Adapt;
  defu(ub) = initu(0.0); // set local values to zero
  defu(um) = initu(0.0); // set local values to zero
  defu(uma) = initu(0.0); // set local values to zero
  defu(um2) = initu(0.0); // set local values to zero
  defu(um3) = initu(0.0); // set local values to zero
  uh.resize(um[].n, Nh);
  restu.resize(ub[].n); // Change size of restriction operator
  restu = restrict(XMh, XMhg, n2o); // Compute new restriction from global mesh to local mesh
  ub[] = uG[](restu); //restrict global solution to each local mesh
  for (int nh = 0; nh < Nh; nh++) {
    tempu2[] = uhrG(:, nh);
    um[].re = tempu2[](restu);
    tempu2[] = uhiG(:, nh);
    um[].im = tempu2[](restu);
    uh(:, nh) = um[];
  }
}

complex ik, ik2, ik3, iomega, iomega2, iomega3;
include "eqns.idp" // load equations
// Build bordered block matrix from only Mat components
Mat JHBa, JHB((1+2*Nh)*J.n, (1+2*Nh)*J.n), dwHB((1+2*Nh)*J.n, mpirank == 0 ? 1 : 0); // Initialize Mat objects for bordered matrix
if(zerofreq) JHBa = JHB;
else JHBa = [[JHB, dwHB],[dwHB',0]];
// Function to build residual operator in PETSc numbering
  func real[int] funcRHB(real[int]& qPETSc) {
      ChangeNumbering(J, ub[], qPETSc(0:J.n-1), inverse = true, exchange = true);
      for (int harm = 0; harm < Nh; harm++)
        ChangeNumbering([J, J], [uh(:, harm).re, uh(:, harm).im], qPETSc((1+2*harm)*J.n:(3+2*harm)*J.n-1), inverse = true, exchange = true);
      if(mpirank == 0 && !zerofreq) omega = zerofreq ? 0.0 : qPETSc(qPETSc.n-1); 
      broadcast(processor(0), omega);
      sym = 0;
      real[int] Rtemp, RPETSc(qPETSc.n), R = vR(0, XMh, tgv = -1);
      for (int nh = 0; nh < Nh; nh++){
        um[] = uh(:, nh);
        um2[] = conj(um[]);
        ik = 1i*(1+nh)*sym1;
        ik2 = -ik;
        complex[int] Rc = vH(0, XMh, tgv = -10);
        R += Rc.re;
      }
      ChangeNumbering(J, R, Rtemp);
      RPETSc(0:J.n-1) = Rtemp;
      for (int nh = 0; nh < Nh; ++nh) {
        complex[int] Rc(ub[].n);
        sym = (1+nh)*sym1;
        iomega = 1i*(1+nh)*omega;
        for (int harm = 0; harm < Nh; harm++){
          um[] = uh(:, harm);
          ik = 1i*(1+harm)*sym1;
          if (harm < nh){
            um2[] = 0.5*uh(:, nh-harm-1);
            ik2 = 1i*(nh-harm)*sym1;
            Rc += vH(0, XMh, tgv = -10);
          } 
          else if (harm == nh) Rc += vJ(0, XMh, tgv = -1);
          else { // if (harm > nh)
            um2[] = conj(uh(:, harm-nh-1));
            ik2 = -1i*(harm-nh)*sym1;
            Rc += vH(0, XMh, tgv = -10);
          }
        }
        ChangeNumbering([J, J], [Rc.re, Rc.im], Rtemp);
        RPETSc((1+2*nh)*J.n:(3+2*nh)*J.n-1) = Rtemp;
      }
      if(mpirank == 0 && !zerofreq) RPETSc(RPETSc.n-1) = 0.0;
      return RPETSc;
  }

// Function to build Jacobian operator in PETSc numbering
func int funcJHB(real[int]& qPETSc) {
    ChangeNumbering(J, ub[], qPETSc(0:J.n-1), inverse = true, exchange = true);
    for (int harm = 0; harm < Nh; harm++)
      ChangeNumbering([J, J], [uh(:, harm).re, uh(:, harm).im], qPETSc((1+2*harm)*J.n:(3+2*harm)*J.n-1), inverse = true, exchange = true);
    if(mpirank == 0 && !zerofreq) omega = zerofreq ? 0.0 : qPETSc(qPETSc.n-1); 
    broadcast(processor(0), omega);
    sym = 0;
    ik = 0;
    iomega = 0;
    matrix<complex> Cmat = vJ(XMh, XMh, tgv = -1);
    matrix An1r = Cmat.re, An2r, An3r, An1i, An2i, An3i; // mean flow jacobian
    Mat row1(J), row2, row3, A1(J), A2(J), temp;
    row1 = An1r;
    for (int n = 0; n < Nh; n++){
      um[] = 2.0*uh(:, n);
      ik = 1i*(1+n)*sym1;
      ik2 = -1i*(1+n)*sym1;
      Cmat = vH(XMh, XMh, tgv = -10);
      An1r = Cmat.re;
      ChangeOperator(A1, An1r);
      An2r = Cmat.im;
      ChangeOperator(A2, An2r);
      temp = [[row1, A1, A2]];
      MatConvert(temp, row1);
    }
    for (int n = 0; n < Nh; n++){
      sym = (1+n)*sym1;
      um[] = uh(:, n);
      ik = 1i*(1+n)*sym1;
      ik2 = 0;
      Cmat = vH(XMh, XMh, tgv = -10);
      An1r = Cmat.re;
      ChangeOperator(A1, An1r);
      MatConvert(A1, row2);
      An1i = Cmat.im;
      ChangeOperator(A2, An1i);
      MatConvert(A2, row3);
      for (int j = 0; j < Nh; j++){
        if (j < n){ // subharmonics
          um[] = uh(:, n-j-1);
          ik = 1i*(n-j)*sym1;
          ik2 = 1i*(1+j)*sym1;
          Cmat = vH(XMh, XMh, tgv = -10);
        } else if (j == n) { // diagonal
          iomega = 1i*(1+n)*omega;
          ik = 1i*(1+n)*sym1;
          Cmat = vJ(XMh, XMh, tgv = -1);
        } else { //if (j > n) superharmonics
          um[] = conj(uh(:, j-n-1));
          ik = -1i*(j-n)*sym1;
          ik2 = 1i*(1+j)*sym1;
          Cmat = vH(XMh, XMh, tgv = -10);
        }
        An2r = Cmat.re;
        An2i = Cmat.im;
        An3r = -An2i;
        An3i = Cmat.re;
        if (1+j+n < Nh) {
          um[] = uh(:, 1+n+j);
          ik = 1i*(2+n+j)*sym1;
          ik2 = -1i*(1+j)*sym1;
          Cmat = vH(XMh, XMh, tgv = -10);
          An2r += Cmat.re;
          An2i += Cmat.im;
          An3r += Cmat.im;
          An3i -= Cmat.re;
        }
        ChangeOperator(A1, An2r);
        ChangeOperator(A2, An3r);
        temp = [[row2, A1, A2]];
        MatConvert(temp, row2);
        ChangeOperator(A1, An2i);
        ChangeOperator(A2, An3i);
        temp = [[row3, A1, A2]];
        MatConvert(temp, row3);
      }
      temp = [[row1], [row2], [row3]];
      MatConvert(temp, row1);
    }
    JHB = row1;
    if (zerofreq) JHBa = JHB;
    else {
      real[int] Mtemp = 0, MqHB((1+2*Nh)*J.n);
      for (int nh = 0; nh < Nh; nh++) {
        sym = (1+nh)*sym1;
        um[] = 1i*(1+nh)*uh(:, nh);
        complex[int] Mc = vM(0, XMh, tgv = -10);
        ChangeNumbering([J, J], [Mc.re, Mc.im], Mtemp);
        MqHB((1+2*nh)*J.n:(3+2*nh)*J.n-1) = Mtemp;
      }
      matrix tempPms = [[MqHB]];
      ChangeOperator(dwHB, tempPms, parent = JHBa); // send to Mat
    }
    return 0;
}
// set up Mat parameters
real[int] fields((1+2*Nh)*J.n);
fields = 1;
for (int nh = 0; nh < Nh; nh++) fields((1+2*nh)*J.n:(3+2*nh)*J.n-1) = 1+gmres+nh;
string HBKSPparams = KSPparams;
if (gmres) HBKSPparams = "-ksp_type gmres -ksp_pc_side right -pc_type fieldsplit -pc_fieldsplit_type additive -fieldsplit_pc_type lu -fieldsplit_pc_factor_mat_solver_type mumps -ksp_gmres_classicalgramschmidt -ksp_gmres_cgs_refinement_type refine_ifneeded ";
if (zerofreq) set(JHBa, sparams = HBKSPparams);
else {
  set(JHBa, sparams = "-ksp_type preonly -pc_type fieldsplit -pc_fieldsplit_type schur -pc_fieldsplit_schur_precondition self", setup = 1);
  set(JHB, sparams = "-prefix_push fieldsplit_0_ " + HBKSPparams + " -prefix_pop", prefix = "fieldsplit_0_", parent = JHBa, fields = fields);
}
// initialize
real[int] qHB((1+2*Nh)*J.n);
{
  real[int] q;
  ChangeNumbering(J, ub[], q);
  qHB(0:J.n-1) = q;
}
for (int harm = 0; harm < Nh; harm++){
  real[int] qm;
  ChangeNumbering([J, J], [uh(:, harm).re, uh(:, harm).im], qm);
  qHB((1+2*harm)*J.n:(3+2*harm)*J.n-1) = qm;
}
if(mpirank == 0 && !zerofreq) {
  qHB.resize(qHB.n+1);
  qHB(qHB.n-1) = omega;
}
int ret;
// solve nonlinear problem with SNES
SNESSolve(JHBa, funcJHB, funcRHB, qHB, reason = ret,
          sparams = "-snes_linesearch_type " + sneslinesearchtype + " -snes_monitor -snes_converged_reason -options_left no");
if(ret > 0) { // Save solution if solver converged and output file is given
  if(mpirank==0 && adapt) { // Save adapted mesh
    cout << "  Saving adapted mesh '" + meshout + "' in '" + workdir + "'." << endl;
    savemesh(Thg, workdir + meshout);
  }
  ChangeNumbering(J, ub[], qHB(0:J.n-1), inverse = true);
  for (int harm = 0; harm < Nh; harm++)
    ChangeNumbering([J, J], [uh(:, harm).re, uh(:, harm).im], qHB((1+2*harm)*J.n:(3+2*harm)*J.n-1), inverse = true);
  if(mpirank == 0 && !zerofreq) omega = zerofreq ? 0.0 : qHB(qHB.n-1); 
  broadcast(processor(0), omega);
  saveporb(fileout, "", meshout, sym1, omega, Nh, true, true);
}