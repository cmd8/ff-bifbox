// Define KSP parameters
string KSPparams = "";
// RESIDUAL VECTOR
IFMACRO(formulation,compreact)
  varf vR(defu(dub), defu(v))
      = int2d(Th)(
          vY*ubR*(ugradf(ub, 0, ubY) + ubY*Daexp(ub)) + ubT^(params["a"])*diff(0, vY, 0, ubY)/(params["Le"]*params["Pe"])
        + vR*(ugradf(ub, 0, ubR) + ubR*divu(0, ub))
        + ubR*ugradu(v, ub, 0, ub) - 1.0/(params["ga"]*params["Ma"]^2)*divu(0, v)*(ubR*ubT - 1.0) + ubT^(params["a"])*visc(0, v, 0, ub)/params["Re"]
        + vT*(ubR*(ugradf(ub, 0, ubT) - params["ga"]*params["dT"]*ubY*Daexp(ub)) + (params["ga"] - 1.0)*ubR*ubT*divu(0, ub))
        - vT*params["ga"]*(params["ga"] - 1.0)*params["Ma"]^2./params["Re"]*ubT^(params["a"])*visc(0, ub, 0, ub)
        + params["ga"]/params["Pe"]*ubT^(params["a"])*diff(0, vT, 0, ubT)
      )
      - int1d(Th, BCopen) (
        ubT^(params["a"])*ndotvisc(v, 0, ub)/params["Re"]
      )
      + on(BCwall, dub = ub, duby = uby, IFMACRO(component,3) dubz = ubz, ENDIFMACRO dubT = ubT - 1.0)
      + on(BCslip, duby = uby IFMACRO(component,3), dubz = ubz ENDIFMACRO)
      + on(BCinflow, dub = ub - 2./5., duby = uby, IFMACRO(component,3) dubz = ubz, ENDIFMACRO dubY = ubY - 1.0, dubT = ubT - 1.0)
      + axisBCs(0, dub, ub, uby, ubz, ubY, ubT);

// JACOBIAN MATRIX
varf vJ(defu(dub), defu(v))
      = int2d(Th)(
          vY*(ubR*(ugradf(dub, 0, ubY) + ugradf(ub, ik, dubY)) + dubR*ugradf(ub, 0, ubY) + (ubR*dubY + dubR*ubY + ubR*ubY*dubT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.))*Daexp(ub)) + (ubT^(params["a"])*diff(-ik, vY, ik, dubY) + params["a"]*ubT^(params["a"]-1.)*dubT*diff(-ik, vY, 0, ubY))/(params["Le"]*params["Pe"])
        + vR*(ugradf(ub, ik, dubR) + ugradf(dub, 0, ubR) + dubR*divu(0, ub) + ubR*divu(ik, dub))
        + ubR*(ugradu(v, dub, 0, ub) + ugradu(v, ub, ik, dub)) + dubR*ugradu(v, ub, 0, ub) - 1.0/(params["ga"]*params["Ma"]^2)*divu(-ik, v)*(dubR*ubT + ubR*dubT) + (ubT^(params["a"])*visc(-ik, v , ik, dub ) + params["a"]*ubT^(params["a"]-1.)*dubT*visc(-ik, v , 0, ub ))/params["Re"]
        + vT*(ubR*(ugradf(dub, 0, ubT) + ugradf(ub, ik, dubT)) + dubR*ugradf(ub, 0, ubT) - params["ga"]*params["dT"]*(ubR*dubY + dubR*ubY + ubR*ubY*dubT*params["Ze"]*(1.0 + params["dT"])^2/(params["dT"]*ubT^2.))*Daexp(ub) + (params["ga"] - 1.0)*(dubR*ubT*divu(0, ub) + ubR*dubT*divu(0, ub) + ubR*ubT*divu(ik, dub)))
        + params["ga"]/params["Pe"]*(ubT^(params["a"])*diff(-ik, vT, ik, dubT) + params["a"]*ubT^(params["a"]-1.)*dubT*diff(-ik, vT, 0, ubT))
        - vT*params["ga"]*(params["ga"] - 1.0)*params["Ma"]^2./params["Re"]*(ubT^(params["a"])*(visc(-ik, dub, 0, ub) + visc(0, ub, ik, dub)) + params["a"]*ubT^(params["a"]-1.)*dubT*visc(0, ub, 0, ub))
      )
      - int1d(Th, BCopen) (
        (ubT^(params["a"])*ndotvisc(v, ik, dub) + params["a"]*ubT^(params["a"]-1.)*dubT*ndotvisc(v, 0, ub))/params["Re"]
      )
      + on(BCwall, dub = ub, duby = uby, IFMACRO(component,3) dubz = ubz, ENDIFMACRO dubT = ubT - 1.0)
      + on(BCslip, duby = uby IFMACRO(component,3), dubz = ubz, ENDIFMACRO)
      + on(BCinflow, dub = ub - 2./5., duby = uby, IFMACRO(component,3) dubz = ubz, ENDIFMACRO dubY = ubY - 1.0, dubT = ubT - 1.0)
      + axisBCs(0, dub, ub, uby, ubz, ubY, ubT);
ENDIFMACRO
// FUNCTIONS
  func real[int] funcR(real[int]& inPETSc) {
      changeNumbering(J, ub[], inPETSc, inverse = true, exchange = true);
      real[int] out(XMh.ndof);
      out = vR(0, XMh, tgv = -1);
      real[int] outPETSc;
      changeNumbering(J, out, outPETSc);
      return outPETSc;
  }

  func int funcJ(real[int]& inPETSc) {
      changeNumbering(J, ub[], inPETSc, inverse = true, exchange = true);
      J = vJ(XMh, XMh, tgv = -1);
      return 0;
  }

  // parameter functions
    func real[int] funcJl(real[int]& R, real[int]& inPETSc, string & param) {
      real lambda = getlambda(param);
      real eps = getARGV("-eps", 1e-7);
      updatelambda(param, lambda + eps);
      real[int] Jl(R.n);
      Jl = funcR(inPETSc);
      updatelambda(param, lambda);
      lambda -= eps;
      Jl -= R;
      Jl /= eps;
      return Jl;
    }
