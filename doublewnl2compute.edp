//
// doublewnl2compute.edp
// Chris Douglas
// chris.douglas@ladhyx.polytechnique.fr
//
// This script computes the normal form at a Hopf point.
// The normal form is written for the complex amplitudes Y = A*exp(1i*omegaA*t) and Z = B*exp(1i*omegaB*t) as:
//    dY/dt = Y*( alphaA*(lambda - lambda0) + 1i*omegaA + betaA*|Y|^2 + gammaA*|Z|^2 )
//    dZ/dt = Z*( alphaB*(lambda - lambda0) + 1i*omegaB + gammaB*|Y|^2 + betaB*|Z|^2 )
// where:
//    alpha are the coefficients for the linear terms from parameter changes,
//    beta are the coefficients for the cubic term from self-coupling harmonic interactions,
//    gamma are the coefficients for the cubic term from cross-coupling harmonic interactions.
//
// NOTE: This file should not be changed unless you know what you're doing.
//
load "iovtk"
load "PETSc-complex"
include "settings.idp"
include "macros_bifbox.idp"
// arguments
string meshin = getARGV("-mi", "");
string filein1 = getARGV("-fi1", "");
string filein2 = getARGV("-fi2", "");
string fileout1 = getARGV("-fo1", "");
string fileout2 = getARGV("-fo2", "");
real eps = getARGV("-eps", 1e-7);
string ksptype = getARGV("-ksp_type", "preonly");
string pctype = getARGV("-pc_type", "lu");
int sym, sym1, sym2;
real omega, omega1, omega2, lambda;

string fileroot1, fileroot2, meshroot, basefileroot;
string fileext1 = parsefilename(filein1, fileroot1); //extract file name and extension
string fileext2 = parsefilename(filein2, fileroot2); //extract file name and extension
parsefilename(fileout1, fileout1); // trim extension from output file, if given
parsefilename(fileout2, fileout2); // trim extension from output file, if given
if(meshin == "") meshin = readmeshname(workdir + filein1); // get mesh file
string meshext = parsefilename(meshin, meshroot);
assert(fileext1 == "hopf" && fileext2 == "hopf");
// Load mesh, make FE basis
Th = readmeshN(workdir + meshin);
Thg = Th;
buildDmesh(Th);
restu = restrict(XMh, XMhg, n2o);
XMh<complex> defu(ub), defu(um), defu(uma), defu(umA), defu(umAa), defu(umB), defu(umBa), defu(um2), defu(um3);
XMh<complex>[int] defu(q2param)(paramnames.n);
ub[].re = loadhopf(fileroot2, meshin, umB[], umBa[], sym2, omega2);
ub[].re = loadhopf(fileroot1, meshin, umA[], umAa[], sym1, omega1);
// Create distributed Mat
Mat<complex> J;
createMatu(Th, J, Pk);
complex ik, ik2 = 0.0, ik3 = 0.0, iomega, iomega2 = 0.0, iomega3 = 0.0;
include "eqns.idp"
set(J, sparams = " -ksp_type " + ksptype + " -pc_type " + pctype + " " + KSPparams);

// Initialize
{
  um[] = umA[];
  uma[] = umAa[];
  sym = sym1;
  complex[int] Mq = vM(0, XMh, tgv = -10);
  complex Mnorm = sqrt(J(um[], Mq));
  um[] /= Mnorm; // so that <um[],M*um[]> = 1
  uma[] *= conj(Mnorm/J(uma[], Mq)); // so that <uma[],M*um[]> = 1
  umA[] = um[];
  umAa[] = uma[];
}
{
  um[] = umB[];
  uma[] = umBa[];
  sym = sym2;
  complex[int] Mq = vM(0, XMh, tgv = -10);
  complex Mnorm = sqrt(J(um[], Mq));
  um[] /= Mnorm; // so that <um[],M*um[]> = 1
  uma[] *= conj(Mnorm/J(uma[], Mq)); // so that <uma[],M*um[]> = 1
  umB[] = um[];
  umBa[] = uma[];
}
complex[int] qAAs(J.n), qABs(J.n), qBBs(J.n), qAA(J.n), qAB(J.n), qBB(J.n), tempP(J.n), temp(um[].n), temp1(um[].n);
complex[int,int] qDa(paramnames.n, J.n);
// 2nd-order
//  A: base modifications due to parameter changes
ik = 0.0;
ik2 = 0.0;
iomega = 0.0;
iomega2 = 0.0;
sym = 0;
J = vJ(XMh, XMh, tgv = -1);
if(paramnames[0] != ""){
  for (int k = 0; k < paramnames.n; ++k){
    lambda = getlambda(paramnames[k]);
    updatelambda(paramnames[k], lambda + eps);
    temp = vR(0, XMh, tgv = -1);
    updatelambda(paramnames[k], lambda);
    temp1 = vR(0, XMh, tgv = -1);
    temp -= temp1;
    temp /= -eps;
    ChangeNumbering(J, temp, tempP); // FreeFEM to PETSc
    KSPSolve(J, tempP, qAAs);
    qDa(k, :) = qAAs;
  }
}
//  B: base modifications due to quadratic nonlinear interactions
um[] = umA[];
um2[] = conj(umA[]);
ik = 1i*real(sym1);
ik2 = -ik;
iomega = 1i*omega1;
iomega2 = -iomega;
temp = vH(0, XMh, tgv = -10);
temp.re *= -1.0; // -2.0/2.0
temp.im = 0.0;
ChangeNumbering(J, temp, tempP); // FreeFEM to PETSc
KSPSolve(J, tempP, qAAs);

um[] = umB[];
um2[] = conj(umB[]);
ik = 1i*real(sym2);
ik2 = -ik;
iomega = 1i*omega2;
iomega2 = -iomega;
temp = vH(0, XMh, tgv = -10);
temp.re *= -1.0; // -2.0/2.0
temp.im = 0.0;
ChangeNumbering(J, temp, tempP); // FreeFEM to PETSc
KSPSolve(J, tempP, qBBs);

um[] = umA[];
um2[] = conj(umB[]);
ik = 1i*real(sym1);
ik2 = -1i*real(sym2);
iomega = 1i*omega1;
iomega2 = -1i*omega2;
sym = sym1 - sym2;
temp = vH(0, XMh, tgv = -10);
temp *= -1.0; // -2.0/2.0
ChangeNumbering(J, temp, tempP); // FreeFEM to PETSc
ik = 1i*real(sym1 - sym2);
iomega = 1i*(omega1 - omega2);
J = vJ(XMh, XMh, tgv = -1);
KSPSolve(J, tempP, qABs);
//  C: harmonics generation due to quadratic nonlinear interactions
um[] = umA[];
um2[] = umA[];
ik = 1i*real(sym1);
ik2 = ik;
iomega = 1i*omega1;
iomega2 = iomega;
sym = 2*sym1;
temp = vH(0, XMh, tgv = -10);
temp *= -0.5; // -1.0/2.0
ChangeNumbering(J, temp, tempP); // FreeFEM to PETSc
ik = 2i*real(sym1);
iomega = 2i*omega1;
J = vJ(XMh, XMh, tgv = -1);
KSPSolve(J, tempP, qAA);

um[] = umA[];
um2[] = umB[];
ik = 1i*real(sym1);
ik2 = 1i*real(sym2);
iomega = 1i*omega1;
iomega2 = 1i*omega2;
sym = sym1 + sym2;
temp = vH(0, XMh, tgv = -10);
temp *= -1.0; // -2.0/2.0
ChangeNumbering(J, temp, tempP); // FreeFEM to PETSc
ik = 1i*real(sym1 + sym2);
iomega = 1i*(omega1 + omega2);
J = vJ(XMh, XMh, tgv = -1);
KSPSolve(J, tempP, qAB);

um[] = umB[];
um2[] = umB[];
ik = 1i*real(sym2);
ik2 = ik;
iomega = 1i*omega2;
iomega2 = iomega;
sym = 2*sym2;
temp = vH(0, XMh, tgv = -10);
temp *= -0.5; // -1.0/2.0
ChangeNumbering(J, temp, tempP); // FreeFEM to PETSc
ik = 2i*real(sym2);
iomega = 2i*omega2;
J = vJ(XMh, XMh, tgv = -1);
KSPSolve(J, tempP, qBB);
// 3rd-order
// fundamental modifications due to parameter changes and quadratic interaction of fundamental with 2nd order base modification.
// A
um[] = umA[];
sym = sym1;
ik = 1i*real(sym1);
ik2 = 0.0;
iomega = 1i*omega1;
iomega2 = 0.0;
complex[string] alphaA;
if(paramnames[0] != ""){
  for (int k = 0; k < paramnames.n; ++k){
    lambda = getlambda(paramnames[k]);
    updatelambda(paramnames[k], lambda + eps);
    temp = vJ(0, XMh, tgv = -10);
    updatelambda(paramnames[k], lambda);
    temp1 = vJ(0, XMh, tgv = -10);
    temp -= temp1;
    temp /= eps;
    ChangeNumbering(J, um2[], qDa(k, :), inverse = true, exchange = true); // FreeFEM to PETSc
    temp += vH(0, XMh, tgv = -10); // 2.0/2.0
    alphaA[paramnames[k]] = -J(umAa[], temp);
  }
}
// B
um[] = umB[];
sym = sym2;
ik = 1i*real(sym2);
ik2 = 0.0;
iomega = 1i*omega2;
iomega2 = 0.0;
complex[string] alphaB;
if(paramnames[0] != ""){
  for (int k = 0; k < paramnames.n; ++k){
    lambda = getlambda(paramnames[k]);
    updatelambda(paramnames[k], lambda + eps);
    temp = vJ(0, XMh, tgv = -10);
    updatelambda(paramnames[k], lambda);
    temp1 = vJ(0, XMh, tgv = -10);
    temp -= temp1;
    temp /= eps;
    ChangeNumbering(J, um2[], qDa(k, :), inverse = true, exchange = true); // FreeFEM to PETSc
    temp += vH(0, XMh, tgv = -10); // 2.0/2.0
    alphaB[paramnames[k]] = -J(umBa[], temp);
  }
}
// A|A|^2
//  B: fundamental modification due to cubic self-interaction of fundamental
um[] = umA[];
um2[] = umA[];
um3[] = conj(umA[]);
sym = sym1;
ik = 1i*real(sym1);
ik2 = 1i*real(sym1);
ik3 = -1i*real(sym1);
iomega = 1i*omega1;
iomega2 = 1i*omega1;
iomega3 = -1i*omega1;
temp = vT(0, XMh, tgv = -10);
temp *= 0.5; //3.0/6.0
//  C: fundamental modification due to quadratic interaction of fundamental with 2nd order modification B
ik = 1i*real(sym1);
ik2 = 0.0;
iomega = 1i*omega1;
iomega2 = 0.0;
ChangeNumbering(J, um2[], qAAs, inverse = true, exchange = true); // FreeFEM to PETSc
temp += vH(0, XMh, tgv = -10);
//  D: fundamental modification due to quadratic interaction of fundamental with 2nd order modification C
ik = -1i*real(sym1);
ik2 = 2i*real(sym1);
iomega = -1i*omega1;
iomega2 = 2i*omega1;
um[] = conj(um[]);
ChangeNumbering(J, um2[], qAA, inverse = true, exchange = true); // FreeFEM to PETSc
temp += vH(0, XMh, tgv = -10);
complex betaA = -J(umAa[], temp);

// B|B|^2
//  B: fundamental modification due to cubic self-interaction of fundamental
um[] = umB[];
um2[] = umB[];
um3[] = conj(umB[]);
sym = sym2;
ik = 1i*real(sym2);
ik2 = 1i*real(sym2);
ik3 = -1i*real(sym2);
iomega = 1i*omega2;
iomega2 = 1i*omega2;
iomega3 = -1i*omega2;
temp = vT(0, XMh, tgv = -10);
temp *= 0.5; //3.0/6.0
//  C: fundamental modification due to quadratic interaction of fundamental with 2nd order modification B
ik = 1i*real(sym2);
ik2 = 0.0;
iomega = 1i*omega2;
iomega2 = 0.0;
ChangeNumbering(J, um2[], qBBs, inverse = true, exchange = true); // FreeFEM to PETSc
temp += vH(0, XMh, tgv = -10);
//  D: fundamental modification due to quadratic interaction of fundamental with 2nd order modification C
ik = -1i*real(sym2);
ik2 = 2i*real(sym2);
iomega = -1i*omega2;
iomega2 = 2i*omega2;
um[] = conj(umB[]);
ChangeNumbering(J, um2[], qBB, inverse = true, exchange = true); // FreeFEM to PETSc
temp += vH(0, XMh, tgv = -10);
complex betaB = -J(umBa[], temp);

// A|B|^2
//  B: fundamental modification due to cubic self-interaction of fundamental
um[] = umA[];
um2[] = umB[];
um3[] = conj(umB[]);
sym = sym1;
ik = 1i*real(sym1);
ik2 = 1i*real(sym2);
ik3 = -1i*real(sym2);
iomega = 1i*omega1;
iomega2 = 1i*omega2;
iomega3 = -1i*omega2;
temp = vT(0, XMh, tgv = -10);
//  C: fundamental modification due to quadratic interaction of fundamental with 2nd order modification B
um[] = umB[];
ik = 1i*real(sym2);
ik2 = 1i*real(sym1 - sym2);
iomega = 1i*omega2;
iomega2 = 1i*(omega1 - omega2);
ChangeNumbering(J, um2[], qABs, inverse = true, exchange = true); // FreeFEM to PETSc
temp += vH(0, XMh, tgv = -10);

um[] = umA[];
ik = 1i*real(sym1);
ik2 = 0.0;
iomega = 1i*omega1;
iomega2 = 0.0;
ChangeNumbering(J, um2[], qBBs, inverse = true, exchange = true); // FreeFEM to PETSc
temp += vH(0, XMh, tgv = -10);
//  D: fundamental modification due to quadratic interaction of fundamental with 2nd order modification C
um[] = conj(umB[]);
ik = -1i*real(sym2);
ik2 = 1i*real(sym1 + sym2);
iomega = -1i*omega2;
iomega2 = 1i*(omega1 + omega2);
ChangeNumbering(J, um2[], qAB, inverse = true, exchange = true); // FreeFEM to PETSc
temp += vH(0, XMh, tgv = -10);
complex gammaA = -J(umAa[], temp);


// B|A|^2
//  B: fundamental modification due to cubic self-interaction of fundamental
um[] = umB[];
um2[] = umA[];
um3[] = conj(umA[]);
sym = sym2;
ik = 1i*real(sym2);
ik2 = 1i*real(sym1);
ik3 = -1i*real(sym1);
iomega = 1i*omega2;
iomega2 = 1i*omega1;
iomega3 = -1i*omega1;
temp = vT(0, XMh, tgv = -10);
//  C: fundamental modification due to quadratic interaction of fundamental with 2nd order modification B
um[] = umA[];
ik = 1i*real(sym1);
ik2 = 1i*real(sym2 - sym1);
iomega = 1i*omega1;
iomega2 = 1i*(omega2 - omega1);
ChangeNumbering(J, um2[], qABs, inverse = true, exchange = true); // FreeFEM to PETSc
um2[] = conj(um2[]);
temp += vH(0, XMh, tgv = -10);

um[] = umB[];
ik = 1i*real(sym2);
ik2 = 0.0;
iomega = 1i*omega2;
iomega2 = 0.0;
ChangeNumbering(J, um2[], qAAs, inverse = true, exchange = true); // FreeFEM to PETSc
temp += vH(0, XMh, tgv = -10);
//  D: fundamental modification due to quadratic interaction of fundamental with 2nd order modification C
um[] = conj(umA[]);
ik = -1i*real(sym1);
ik2 = 1i*real(sym1 + sym2);
iomega = -1i*omega1;
iomega2 = 1i*(omega1 + omega2);
ChangeNumbering(J, um2[], qAB, inverse = true, exchange = true); // FreeFEM to PETSc
temp += vH(0, XMh, tgv = -10);
complex gammaB = -J(umBa[], temp);

if(mpirank == 0){
  cout << " alphaA = " << alphaA << endl;
  cout << " alphaB = " << alphaB << endl;
  cout << " betaA = " << betaA << endl;
  cout << " betaB = " << betaB << endl;
  cout << " gammaA = " << gammaA << endl;
  cout << " gammaB = " << gammaB << endl;
}
