// Define KSP parameters
string KSPparams = "";
string EPSparams = " -eps_pos_gen_non_hermitian ";
// RESIDUAL OPERATOR
varf vR(defu(um), defu(v))
      = int2d(Th)(
        vR*(ugradf(ub, 0, ubR) + ubR*divu(0, ub))
        + ubR*ugradu(v, ub, 0, ub) - 1.0/(params["ga"]*params["Ma"]^2)*divu(0, v)*(ubR*ubT - 1.0) + ubT^(params["a"])*visc(0, v, 0, ub)/params["Re"]
        + vT*(ubR*(ugradf(ub, 0, ubT) + (params["ga"] - 1.0)*ubR*ubT*divu(0, ub) - params["ga"]*(params["ga"] - 1.0)*params["Ma"]^2./params["Re"]*ubT^(params["a"])*visc(0, ub, 0, ub))
        + params["ga"]/params["Pe"]*ubT^(params["a"])*diff(0, vT, 0, ubT)
      )
      - int1d(Th, BCopen) (
        ubT^(params["a"])*ndotvisc(v, 0, ub)/params["Re"]
      )
      + BoundaryConditions(0, um, ub);

// JACOBIAN OPERATOR
varf vJ(defu(dum), defu(v))
      = int2d(Th)(
        iomega*(gdotf(vR, dumR) + ubR*(gdotf(vT, dumT) + vdotu(v, dum)))
        + vR*(ugradf(ub, ik, dumR) + ugradf(dum, 0, ubR) + dumR*divu(0, ub) + ubR*divu(ik, dum))
        + ubR*(ugradu(v, dum, 0, ub) + ugradu(v, ub, ik, dum)) + dumR*ugradu(v, ub, 0, ub) - 1.0/(params["ga"]*params["Ma"]^2)*divu(-ik, v)*(dumR*ubT + ubR*dumT) + (ubT^(params["a"])*visc(-ik, v , ik, dum ) + params["a"]*ubT^(params["a"]-1.)*dumT*visc(-ik, v , 0, ub ))/params["Re"]
        + vT*(ubR*(ugradf(dum, 0, ubT) + ugradf(ub, ik, dumT)) + dumR*ugradf(ub, 0, ubT) + (params["ga"] - 1.0)*(dumR*ubT*divu(0, ub) + ubR*dumT*divu(0, ub) + ubR*ubT*divu(ik, dum)))
        + params["ga"]/params["Pe"]*(ubT^(params["a"])*diff(-ik, vT, ik, dumT) + params["a"]*ubT^(params["a"]-1.)*dumT*diff(-ik, vT, 0, ubT))
        - vT*params["ga"]*(params["ga"] - 1.0)*params["Ma"]^2./params["Re"]*(ubT^(params["a"])*(visc(ik, dum, 0, ub) + visc(0, ub, ik, dum)) + params["a"]*ubT^(params["a"]-1.)*dumT*visc(0, ub, 0, ub))
      )
      - int1d(Th, BCopen) (
        (ubT^(params["a"])*ndotvisc(v, ik, dum) + params["a"]*ubT^(params["a"]-1.)*dumT*ndotvisc(v, 0, ub))/params["Re"]
      )
      + int2d(Th)(
        iomega*(gdotf(vR, umR) + ubR*(gdotf(vT, umT) + vdotu(v, um)))
        + vR*(ugradf(ub, ik, umR) + ugradf(um, 0, ubR) + umR*divu(0, ub) + ubR*divu(ik, um))
        + ubR*(ugradu(v, um, 0, ub) + ugradu(v, ub, ik, um)) + umR*ugradu(v, ub, 0, ub) - 1.0/(params["ga"]*params["Ma"]^2)*divu(-ik, v)*(umR*ubT + ubR*umT) + (ubT^(params["a"])*visc(-ik, v , ik, um ) + params["a"]*ubT^(params["a"]-1.)*umT*visc(-ik, v , 0, ub ))/params["Re"]
        + vT*(ubR*(ugradf(um, 0, ubT) + ugradf(ub, ik, umT)) + umR*ugradf(ub, 0, ubT) + (params["ga"] - 1.0)*(umR*ubT*divu(0, ub) + ubR*umT*divu(0, ub) + ubR*ubT*divu(ik, um)))
        + params["ga"]/params["Pe"]*(ubT^(params["a"])*diff(-ik, vT, ik, umT) + params["a"]*ubT^(params["a"]-1.)*umT*diff(-ik, vT, 0, ubT))
        - vT*params["ga"]*(params["ga"] - 1.0)*params["Ma"]^2./params["Re"]*(ubT^(params["a"])*(visc(ik, um, 0, ub) + visc(0, ub, ik, um)) + params["a"]*ubT^(params["a"]-1.)*umT*visc(0, ub, 0, ub))
      )
      - int1d(Th, BCopen) (
        (ubT^(params["a"])*ndotvisc(v, ik, um) + params["a"]*ubT^(params["a"]-1.)*umT*ndotvisc(v, 0, ub))/params["Re"]
      )
      + HomBoundaryConditions(m, dum);

// MASS OPERATOR
varf vM(defu(dum), defu(v))
      = int2d(Th)(
          gdotf(vR, dumR) + ubR*(gdotf(vT, dumT) + vdotu(v, dum))
      )
      + int2d(Th)(
          gdotf(vR, umR) + ubR*(gdotf(vT, umT) + vdotu(v, um))
      )
      + HomBoundaryConditions(m, dum);

// FORCING/RESPONSE WEIGHTING MATRICES (FOR RESOLVENT ANALYSIS)
varf vMq(defu(dum), defu(v))
      = int2d(Th)( gdotf(vR, umR) + ubR*(gdotf(vT, umT) + vdotu(v, um)) );

varf vMf(deff(dum), deff(v))
      = int2d(Th)( ubR*vdotu(v, dum) );

varf vP(deff(fm), defu(v))
      = int2d(Th)( vdotu(v, fm) );

// HESSIAN OPERATOR (FOR BIFURCATION ANALYSIS AND WEAKLY NONLINEAR ANALYSIS)
varf vH(defu(dum), defu(v))
      = int2d(Th)(
        iomega*um2R*(gdotf(vT, umT) + vdotu(v, um)) + iomega2*umR*(gdotf(vT, um2T) + vdotu(v, um2))
        + vR*(ugradf(um2, ik, umR) + ugradf(um, ik2, um2R) + umR*divu(ik2, um2) + um2R*divu(ik, um))
        + um2R*(ugradu(v, um, 0, ub) + ugradu(v, ub, ik, um)) + ubR*(ugradu(v, um, ik2, um2) + ugradu(v, um2, ik, um)) + umR*(ugradu(v, um2, 0, ub) + ugradu(v, ub, ik2, um2)) - 1.0/(params["ga"]*params["Ma"]^2)*divu(-ik-ik2, v)*(umR*um2T + um2R*umT)
        + params["a"]*ubT^(params["a"]-1.)*(um2T*visc(-ik-ik2, v, ik, um ) + (params["a"]-1.)*um2T/ubT*umT*visc(-ik-ik2, v, 0, ub ) + umT*visc(-ik-ik2, v, ik2, um2 ))/params["Re"]
        + vT*(um2R*(ugradf(um, 0, ubT) + ugradf(ub, ik, umT)) + ubR*(ugradf(um, ik2, um2T) + ugradf(um2, ik, umT)) + umR*(ugradf(um2, 0, ubT) + ugradf(ub, ik2, um2T))
        + (params["ga"] - 1.0)*(umR*(um2T*divu(0, ub) + ubT*divu(ik2, um2)) + umT*(um2R*divu(0, ub) + ubR*divu(ik2, um2)) + (um2R*ubT + ubR*um2T)*divu(ik, um)))
        + params["ga"]*params["a"]*ubT^(params["a"]-1.)*(um2T*diff(-ik-ik2, vT, ik, umT) + (params["a"]-1.)*um2T/ubT*umT*diff(-ik-ik2, vT, 0, ubT) + umT*diff(-ik-ik2, vT, ik2, um2T))/params["Pe"]
        - vT*params["ga"]*(params["ga"] - 1.0)*params["Ma"]^2./params["Re"]*(params["a"]*ubT^(params["a"]-1.)*(um2T*(visc(ik, um, 0, ub) + visc(0, ub, ik, um)) + umT*(visc(ik2, um2, 0, ub) + visc(0, ub, ik2, um2) + (params["a"]-1.)*um2T/ubT*visc(0, ub, 0, ub))) + ubT^(params["a"])*(visc(ik, um, ik2, um2) + visc(ik2, um2, ik, um)))
      )
      - int1d(Th, BCopen) (
        params["a"]*ubT^(params["a"]-1.)*(um2T*ndotvisc(v, ik, um) + umT*ndotvisc(v, ik2, um2) + (params["a"]-1.)*um2T/ubT*umT*ndotvisc(v, 0, ub))/params["Re"]
      )
      + int2d(Th)(
        iomega*dumR*(gdotf(vT, umT) + vdotu(v, um)) + iomega2*umR*(gdotf(vT, dumT) + vdotu(v, dum))
        + vR*(ugradf(dum, ik, umR) + ugradf(um, ik2, dumR) + umR*divu(ik2, dum) + dumR*divu(ik, um))
        + dumR*(ugradu(v, um, 0, ub) + ugradu(v, ub, ik, um)) + ubR*(ugradu(v, um, ik2, dum) + ugradu(v, dum, ik, um)) + umR*(ugradu(v, dum, 0, ub) + ugradu(v, ub, ik2, dum)) - 1.0/(params["ga"]*params["Ma"]^2)*divu(-ik-ik2, v)*(umR*dumT + dumR*umT)
        + params["a"]*ubT^(params["a"]-1.)*(dumT*visc(-ik-ik2, v, ik, um ) + (params["a"]-1.)*dumT/ubT*umT*visc(-ik-ik2, v, 0, ub ) + umT*visc(-ik-ik2, v, ik2, dum ))/params["Re"]
        + vT*(dumR*(ugradf(um, 0, ubT) + ugradf(ub, ik, umT)) + ubR*(ugradf(um, ik2, dumT) + ugradf(dum, ik, umT)) + umR*(ugradf(dum, 0, ubT) + ugradf(ub, ik2, dumT))
        + (params["ga"] - 1.0)*(umR*(dumT*divu(0, ub) + ubT*divu(ik2, dum)) + umT*(dumR*divu(0, ub) + ubR*divu(ik2, dum)) + (dumR*ubT + ubR*dumT)*divu(ik, um)))
        + params["ga"]*params["a"]*ubT^(params["a"]-1.)*(dumT*diff(-ik-ik2, vT, ik, umT) + (params["a"]-1.)*dumT/ubT*umT*diff(-ik-ik2, vT, 0, ubT) + umT*diff(-ik-ik2, vT, ik2, dumT))/params["Pe"]
        - vT*params["ga"]*(params["ga"] - 1.0)*params["Ma"]^2./params["Re"]*(params["a"]*ubT^(params["a"]-1.)*(dumT*(visc(ik, um, 0, ub) + visc(0, ub, ik, um)) + umT*(visc(ik2, dum, 0, ub) + visc(0, ub, ik2, dum) + (params["a"]-1.)*dumT/ubT*visc(0, ub, 0, ub))) + ubT^(params["a"])*(visc(ik, um, ik2, dum) + visc(ik2, dum, ik, um)))
      )
      - int1d(Th, BCopen) (
        params["a"]*ubT^(params["a"]-1.)*(dumT*ndotvisc(v, ik, um) + umT*ndotvisc(v, ik2, dum) + (params["a"]-1.)*dumT/ubT*umT*ndotvisc(v, 0, ub))/params["Re"]
      )
      + HomBoundaryConditions(m, dum);

// TRESSIAN OPERATOR (FOR WEAKLY NONLINEAR ANALYSIS)
varf vT(defu(dum), defu(v))
      = int2d(Th)(
        um2R*(ugradu(v, um, ik3, dum) + ugradu(v, dum, ik, um)) + dumR*(ugradu(v, um, ik2, um2) + ugradu(v, um2, ik, um)) + umR*(ugradu(v, um2, ik3, dum) + ugradu(v, dum, ik2, um2))
        + params["a"]*(params["a"]-1.)*ubT^(params["a"]-2.)*(dumT*(um2T*visc(-ik-ik2-ik3, v, ik, um ) + umT*visc(-ik-ik2-ik3, v, ik2, um2 )) + um2T*umT*visc(-ik-ik2-ik3, v, ik3, dum) + (params["a"]-2.)*dumT/ubT*um2T*umT*visc(-ik-ik2-ik3, v, 0, ub ))/params["Re"]
        + vT*(um2R*(ugradf(um, ik3, dumT) + ugradf(dum, ik, umT)) + dumR*(ugradf(um, ik2, um2T) + ugradf(um2, ik, umT)) + umR*(ugradf(um2, ik3, dumT) + ugradf(dum, ik2, um2T))
        + (params["ga"] - 1.0)*(umR*(um2T*divu(ik3, dum) + dumT*divu(ik2, um2)) + umT*(um2R*divu(ik3, dum) + dumR*divu(ik2, um2)) + (um2R*dumT + dumR*um2T)*divu(ik, um)))
        + params["ga"]*params["a"]*(params["a"]-1.)*ubT^(params["a"]-2.)*(dumT*(um2T*diff(-ik-ik2-ik3, vT, ik, umT) + umT*diff(-ik-ik2-ik3, vT, ik2, um2T)) + um2T*umT*diff(-ik-ik2-ik3, vT, ik3, dumT) + (params["a"]-2.)*dumT/ubT*um2T*umT*diff(-ik-ik2-ik3, vT, 0, ubT))/params["Pe"]
        - vT*params["ga"]*(params["ga"] - 1.0)*params["Ma"]^2./params["Re"]*(
            params["a"]*ubT^(params["a"]-1.)*(um2T*(visc(ik, um, ik3, dum) + visc(ik3, dum, ik, um)) + umT*(visc(ik2, um2, ik3, dum) + visc(ik3, dum, ik2, um2)) + dumT*(visc(ik, um, ik2, um2) + visc(ik2, um2, ik, um)))
            + params["a"]*(params["a"]-1.)*ubT^(params["a"]-2.)*(dumT*(um2T*(visc(ik, um, 0, ub) + visc(0, ub, ik, um)) + umT*(visc(ik2, um2, 0, ub) + visc(0, ub, ik2, um2))) + umT*um2T*((params["a"]-2.)*dumT/ubT*visc(0, ub, 0, ub) + visc(ik3, dum, 0, ub) + visc(0, ub, ik3, dum)))
          )
      )
      - int1d(Th, BCopen) (
        params["a"]*(params["a"]-1.)*ubT^(params["a"]-2.)*(dumT*um2T*ndotvisc(v, ik, um) + dumT*umT*ndotvisc(v, ik2, um2) + um2T*umT*ndotvisc(v, ik3, dum) + (params["a"]-2.)*dumT/ubT*um2T*umT*ndotvisc(v, 0, ub))/params["Re"]
      )
      + HomBoundaryConditions(m, dum);
