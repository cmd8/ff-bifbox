//
// foldcompute.edp
// Chris Douglas
// chris.douglas@ladhyx.polytechnique.fr
//
// EXAMPLE USAGE:
//  Initialize with fold guess from base file, solve on same mesh
// mpirun -n 4 FreeFem++-mpi -v 0 foldcompute.edp -param <PARAM> -fi <FILEIN> -fo <FILEOUT>
//
//  Initialize with fold from base and mode file, solve on same mesh
// mpirun -n 4 FreeFem++-mpi -v 0 foldcompute.edp -param <PARAM> -fi <FILEIN> -fo <FILEOUT>
//
//  Initialize with fold guess from file on a mesh from file
// mpirun -n 4 FreeFem++-mpi -v 0 foldcompute.edp -param <PARAM> -mi <MESHIN> -fi <FILEIN> -fo <FILEOUT>
//
//  Initialize with fold from file, adapt mesh/solution
// mpirun -n 4 FreeFem++-mpi -v 0 foldcompute.edp -param <PARAM> -fi <FILEIN> -fo <FILEOUT> -mo <MESHOUT>
//
// NOTE: This file should not be changed unless you know what you're doing.
//
load "iovtk"
load "PETSc"
include "settings.idp"
include "macros_bifbox.idp"
// arguments
string meshin = getARGV("-mi", "");
string meshout = getARGV("-mo", "");
string filein = getARGV("-fi", "");
string fileout = getARGV("-fo", "");
bool normalform = getARGV("-nf", 1);
string param = getARGV("-param", "");
string adaptto = getARGV("-adaptto", "b");
real eps = getARGV("-eps", 1e-7);
string ksptype = getARGV("-ksp_type", "preonly");
string pctype = getARGV("-pc_type", "lu");
string sneslinesearchtype = getARGV("-snes_linesearch_type", "basic"); // set -snes_linesearch_type
int sym = 0;
real[string] alpha;
real beta;

string fileroot, meshroot;
string fileext = parsefilename(filein, fileroot); //extract file name and extension
parsefilename(fileout, fileout); // trim extension from output file, if given
if(fileext == "mode" || fileext == "rslv") {
  filein = readbasename(workdir + filein);
  fileext = parsefilename(filein, fileroot);
}
if(meshin == "") meshin = readmeshname(workdir + filein); // get mesh file
string meshext = parsefilename(meshin, meshroot);
parsefilename(meshout, meshout); // trim extension from output mesh, if given
// Load mesh, make FE basis
Th = readmeshN(workdir + meshin);
Thg = Th;
buildDmesh(Th);
restu = restrict(XMh, XMhg, n2o);
XMh defu(ub), defu(um), defu(uma), defu(um2), defu(um3);
// Initialize solution with guess or file
if(fileext == "base") {
  ub[] = loadbase(fileroot, meshin);
}
else if(fileext == "fold") {
  ub[] = loadfold(fileroot, meshin, um[], uma[], alpha, beta);
}
else if(fileext == "hopf") {
  int sym;
  real omega;
  complex[string] alpha;
  complex beta;
  complex[int] qm, qma;
  ub[] = loadhopf(fileroot, meshin, qm, qma, sym, omega, alpha, beta);
}
else if(fileext == "dhpf") {
  int sym1, sym2;
  real omega1, omega2;
  complex[string] alpha1, alpha2;
  complex beta1, beta2, gamma1, gamma2;
  complex[int] q1m, q1ma, q2m, q2ma;
  ub[] = loaddhpf(fileroot, meshin, q1m, q1ma, q2m, q2ma, sym1, sym2, omega1, omega2, alpha1, alpha2, beta1, beta2, gamma1, gamma2);
}
else if(fileext == "tdns") {
  real time;
  ub[] = loadtdns(fileroot, meshin, time);
}
real lambda = getlambda(param);
// Create distributed Mat
Mat J;
createMatu(Th, J, Pk);
real ik = 0.0, ik2 = 0.0, ik3 = 0.0, iomega = 0.0, iomega2 = 0.0, iomega3 = 0.0;
include "eqns.idp"

// MESH ADAPTATION
bool adapt = false;
if(meshout == "") meshout = meshin; // if no adaptation
else { // if output meshfile is given, adapt mesh
  adapt = true;
  meshout = meshout + "." + meshext;
  real[int] q;
  ChangeNumbering(J, ub[], q);
  ChangeNumbering(J, ub[], q, inverse = true);
  ChangeNumbering(J, um[], q);
  ChangeNumbering(J, um[], q, inverse = true);
  ChangeNumbering(J, uma[], q);
  ChangeNumbering(J, uma[], q, inverse = true);
  XMhg defu(uG), defu(umG), defu(umaG), defu(tempu); // create private global FE functions
  for[i, v : restu] tempu[][v] = ub[][i]; // populate local portion of global soln
  mpiAllReduce(tempu[], uG[], mpiCommWorld, mpiSUM); //aggregate local solns into global soln
  for[i, v : restu] tempu[][v] = um[][i]; // populate local portion of global soln
  mpiAllReduce(tempu[], umG[], mpiCommWorld, mpiSUM); //aggregate local solns into global soln
  for[i, v : restu] tempu[][v] = uma[][i]; // populate local portion of global soln
  mpiAllReduce(tempu[], umaG[], mpiCommWorld, mpiSUM); //aggregate local solns into global soln
  if(mpirank == 0) {  // Perform mesh adaptation (serially) on processor 0
    if(adaptto == "b") Thg = adaptmesh(Thg, adaptu(uG), adaptmeshoptions);
    else if(adaptto == "bd") Thg = adaptmesh(Thg, adaptu(uG), adaptu(umG), adaptmeshoptions);
    else if(adaptto == "ba") Thg = adaptmesh(Thg, adaptu(uG), adaptu(umaG), adaptmeshoptions);
    else if(adaptto == "bda") Thg = adaptmesh(Thg, adaptu(uG), adaptu(umG), adaptu(umaG), adaptmeshoptions);
  } // TODO: add adaptation to endogeneity and structural sensitivity
  broadcast(processor(0), Thg); // broadcast global mesh to all processors
  defu(uG) = defu(uG); //interpolate global solution from old mesh to new mesh
  defu(umG) = defu(umG); //interpolate global solution from old mesh to new mesh
  defu(umaG) = defu(umaG); //interpolate global solution from old mesh to new mesh
  Th = Thg; //Reinitialize local mesh with global mesh
  Mat Adapt; // Partition new mesh and update the PETSc numbering
  createMatu(Th, Adapt, Pk);
  J = Adapt;
  defu(ub) = initu(0.0); // set local values to zero
  defu(um) = initu(0.0); // set local values to zero
  defu(uma) = initu(0.0); // set local values to zero
  defu(um2) = initu(0.0);
  defu(um3) = initu(0.0);
  restu.resize(ub[].n); // Change size of restriction operator
  restu = restrict(XMh, XMhg, n2o); // Compute new restriction from global mesh to local mesh
  ub[] = uG[](restu); //restrict global solution to each local mesh
  um[] = umG[](restu); //restrict global solution to each local mesh
  uma[] = umaG[](restu); //restrict global solution to each local mesh
}
// Build bordered block matrix from only Mat components
Mat H(J);
Mat JlPM(J.n, mpirank == 0 ? 1 : 0), gqPM(J.n, mpirank == 0 ? 1 : 0), glPM(mpirank == 0 ? 1 : 0, mpirank == 0 ? 1 : 0); // Initialize Mat objects for bordered matrix
Mat Ja = [[J, JlPM], [gqPM', glPM]]; // make dummy Jacobian

real[int] qm(J.n), qma(J.n), pP(J.n), qP(J.n);
// FUNCTIONS
  func real[int] funcRa(real[int]& qa) {
      ChangeNumbering(J, ub[], qa(0:qa.n - (mpirank == 0 ? 2 : 1)), inverse = true, exchange = true); // PETSc to FreeFEM
      if(mpirank == 0) lambda = qa(qa.n-1); // Extract parameter value from state vector on proc 0
      broadcast(processor(0), lambda);
      updatelambda(param, lambda);
      real[int] Ra, R = vR(0, XMh, tgv = -1);
      ChangeNumbering(J, R, Ra); // FreeFEM to PETSc
      J = vJ(XMh, XMh, tgv = -1);
      KSPSolve(J, pP, qm);
      KSPSolveTranspose(J, qP, qma);
      ChangeNumbering(J, R, qP, inverse = true);
      ChangeNumbering(J, um[], qm, inverse = true);
      real g = 1.0/J(R, um[]);
      qm *= g;
      qma *= g;
      if(mpirank == 0) {
          Ra.resize(Ra.n + 1); // Append 0 to residual vector on proc 0
          Ra(Ra.n - 1) = g;
      }
      return Ra;
  }

  func int funcJa(real[int]& qa) {
      ChangeNumbering(J, ub[], qa(0:qa.n - (mpirank == 0 ? 2 : 1)), inverse = true, exchange = true); // PETSc to FreeFEM
      if(mpirank == 0) lambda = qa(qa.n-1); // Extract parameter value from state vector on proc 0
      broadcast(processor(0), lambda);
      ChangeNumbering(J, um[], qm, inverse = true, exchange = true);
      ChangeNumbering(J, uma[], qma, inverse = true);
      updatelambda(param, lambda + eps);
      real[int] Jl = vR(0, XMh, tgv = -1);
      real[int] Hl = vJ(0, XMh, tgv = -10);
      updatelambda(param, lambda);
      real[int] tempP, a0 = vR(0, XMh, tgv = -1);
      Jl -= a0;
      Jl /= eps;
      a0 = vJ(0, XMh, tgv = -10);
      Hl -= a0;
      Hl /= eps;
      ChangeNumbering(J, Jl, tempP); // FreeFEM to PETSc
      matrix tempPms = [[tempP]]; // dense array to sparse matrix
      ChangeOperator(JlPM, tempPms, parent = Ja); // send to Mat
      H = vH(XMh, XMh, tgv = -10);
      MatMultTranspose(H, qma, tempP);
      tempPms = [[tempP]]; // dense array to sparse matrix
      ChangeOperator(gqPM, tempPms, parent = Ja); // send to Mat
      tempPms = [[J(uma[], Hl)]]; // dense array to sparse matrix
      ChangeOperator(glPM, tempPms, parent = Ja); // send to Mat
      return 0;
  }

set(Ja, sparams = "-ksp_type preonly -pc_type fieldsplit -pc_fieldsplit_type schur -pc_fieldsplit_schur_precondition self", setup = 1);
set(J, sparams = " -fieldsplit_0_ksp_type " + ksptype + " -fieldsplit_0_pc_type " + pctype + " " + KSPparams, prefix = "fieldsplit_0_", parent = Ja);

// Initialize
real[int] qa;
ChangeNumbering(J, ub[], qa);
if(mpirank == 0) {
  qa.resize(qa.n + 1);
  qa(qa.n - 1) = lambda;
}
if (fileext != "fold"){
  updatelambda(param, lambda + eps);
  real[int] Jl = vR(0, XMh, tgv = -1);
  updatelambda(param, lambda);
  real[int] a0 = vR(0, XMh, tgv = -1);
  Jl -= a0;
  Jl /= eps;
  J = vJ(XMh, XMh, tgv = -1);
  ChangeNumbering(J, Jl, qP);
  KSPSolve(J, qP, qm);
}
{
  ChangeNumbering(J, um[], qm, inverse = true, exchange = true);
  real[int] Mq = vM(0, XMh, tgv = -10);
  ChangeNumbering(J, um[], qm, inverse = true);
  real Mnorm = sqrt(real(J(um[], Mq)));
  Mq /= Mnorm;
  ChangeNumbering(J, Mq, qP);
  if (fileext == "fold") um[] = uma[];
  else {
    KSPSolveTranspose(J, qP, qma);
    ChangeNumbering(J, um[], qma, inverse = true, exchange = true);
  }
  Mq = vM(0, XMh, tgv = -10);
  ChangeNumbering(J, um[], qm, inverse = true);
  Mq *= (Mnorm/J(um[], Mq)); // so that <uma[],M*um[]> = 1
  ChangeNumbering(J, Mq, pP);
}
// solve nonlinear problem with SNES
int ret;
SNESSolve(Ja, funcJa, funcRa, qa, reason = ret, sparams = " -snes_linesearch_type " + sneslinesearchtype
                                                        + " -snes_monitor -snes_converged_reason "
                                                        );
if (ret > 0) { // Save solution if solver converged and output file is given
  ChangeNumbering(J, ub[], qa(0:qa.n - (mpirank == 0 ? 2 : 1)), inverse = true, exchange = true);
  if(mpirank == 0) lambda = qa(qa.n - 1);
  broadcast(processor(0), lambda);
  updatelambda(param, lambda);
  ChangeNumbering(J, um[], qm, inverse = true, exchange = true);
  real[int] Mq = vM(0, XMh, tgv = -10);
  ChangeNumbering(J, um[], qm, inverse = true);
  ChangeNumbering(J, uma[], qma, inverse = true);
  real Mnorm = sqrt(J(um[], Mq));
  um[] /= Mnorm; // so that <um[],M*um[]> = 1
  uma[] *= (Mnorm/J(uma[], Mq)); // so that <uma[],M*um[]> = 1
  ChangeNumbering(J, um[], qm);
  ChangeNumbering(J, uma[], qma);
  if (normalform){
    real[int] temp(um[].n), temp1(um[].n);
    // 2nd-order
    //  A: base modification due to parameter changes
    if(paramnames[0] != ""){
      for (int k = 0; k < paramnames.n; ++k){
        lambda = getlambda(paramnames[k]);
        updatelambda(paramnames[k], lambda + eps);
        temp = vR(0, XMh, tgv = -1);
        updatelambda(paramnames[k], lambda);
        temp1 = vR(0, XMh, tgv = -1);
        temp -= temp1;
        temp /= -eps;
        alpha[paramnames[k]] = -J(uma[], temp);
      }
    }
    //  B: base modification due to quadratic nonlinear interaction
    ChangeNumbering(J, um[], qm, inverse = true, exchange = true);
    um2[] = um[];
    temp = vH(0, XMh, tgv = -10);
    beta = -0.5*J(uma[], temp);
  }
  else {
    for (int k = 0; k < paramnames.n; ++k){
      alpha[paramnames[k]] = 0.0;
    }
    beta = 0.0;
  }
  if(mpirank==0 && adapt) { // Save adapted mesh
    cout << "  Saving adapted mesh '" + meshout + "' in '" + workdir + "'." << endl;
    savemesh(Thg, workdir + meshout);
  }
  ChangeNumbering(J, ub[], qa(0:qa.n - (mpirank == 0 ? 2 : 1)), inverse = true);
  ChangeNumbering(J, um[], qm, inverse = true);
  savefold(fileout, "", meshout, alpha, beta, true, true);
}
