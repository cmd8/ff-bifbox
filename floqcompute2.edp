//
// floqcompute.edp
// Chris Douglas
// christopher.douglas@duke.edu
//
// EXAMPLE USAGE:
//  Solve Floquet eigenvalue problem, store Floquet exponent spectrum without storing Floquet eigenvectors:
// ff-mpirun -np 4 floqcompute.edp -eps_target 0.1+1.0i -eps_nev 10 -fi <FILEIN> -so <VALFILE>
//
//  Solve Floquet eigenvalue problem, store Floquet exponent spectrum and Floquet eigenvectors:
// ff-mpirun -np 4 floqcompute.edp -eps_target 0.1+1.0i -eps_nev 4 -fi <FILEIN> -fo <VECFILE> -so <VALFILE>
//
//  Solve Floquet eigenvalue problem, store Floquet eigenvectors without storing Floquet exponent spectrum:
// ff-mpirun -np 4 floqcompute.edp -eps_target 0.1+1.0i -eps_nev 4 -fi <FILEIN> -fo <VECFILE>
//
//  Solve Floquet eigenvalue problems over a sequence of shifts, store Floquet exponent spectra and Floquet eigenvectors:
// ff-mpirun -np 4 floqcompute.edp -eps_target 0.1+0.2i -ntarget 10 -targetf 0.1+2.0i -eps_nev 4 -fi <FILEIN> -fo <VECFILE> -so <VALFILE>
//
// NOTE: This file should not be changed unless you know what you're doing.
//
load "iovtk"
load "PETSc-complex"
include "settings.idp"
include "macros_bifbox.idp"
// arguments
string meshin = getARGV("-mi", ""); // input meshfile with extension
string filein = getARGV("-fi", ""); // input file with extension
string fileout = getARGV("-fo", ""); // output file without extension
string statout = getARGV("-so", "");
bool adj = getARGV("-adj", 0); // not possible yet
string symstr = getARGV("-sym", "0");
string epstarget = getARGV("-eps_target", "0+0i");
int ntarget = getARGV("-ntarget", 1);
string targetf = getARGV("-targetf", epstarget);
int epsnev = getARGV("-eps_nev", 1);
bool strictnev = getARGV("-strict", 0);
int select = getARGV("-select", 1);
int Nh = getARGV("-Nh", 0); //if 0, will read Nh from file. In practice, Nh must be at least 1, otherwise use basecompute.edp
int blocks = getARGV("-blocks", 1); //if blocks = 1, use monolithic LU; if blocks = N w/ 2 <= N <= Nh+1, use block preconditioner with N blocks
real[int] sym0(sym.n), sym1(sym.n);
real omega;

macro JacobianHBcplx(JHB, J, ub, uh, sym0, sym1, omega, shift) {
    sym = (sym1);
    ik.im = (sym1);
    iomega = (shift);
    Mat<complex>[int, int] JHBtemp(1+2*Nh, 1+2*Nh);
    matrix<complex> Cmat, An3i, An2r = vJ(XMh, XMh, tgv = -2);
    ik3.im = (sym1);
    iomega3 = (shift);
    for (int j = 0; j < Nh; j++){
      um[] = uh(:, j);
      um2[] = conj(um[]);
      ik.im = (1+j)*(sym0);
      ik2 = conj(ik);
      iomega = 1i*(1+j)*(omega);
      iomega2 = -iomega;
      Cmat = vT(XMh, XMh, tgv = -20);
      An2r += Cmat;
    }
    constructor(JHBtemp(0, 0), J, An2r);
    for (int j = 0; j < Nh; j++){
      um[] = uh(:, j);
      ik.im = (1+j)*(sym0);
      ik2.im = -(1+j)*(sym0) + (sym1);
      iomega = 1i*(1+j)*(omega);
      iomega2 = -iomega + (shift);
      An3i = vH(XMh, XMh, tgv = -20);
      um[] = conj(um[]);
      ik.im *= -1.0;
      ik2.im = (1+j)*(sym0) + (sym1);
      iomega *= -1.0;
      iomega2 = -iomega + (shift);
      An2r = vH(XMh, XMh, tgv = -20);
      for (int k = 0; k < Nh; k++){
        if (k < Nh-j-1) {
          um[] = uh(:, 1+j+k);
          um2[] = conj(uh(:, k));
          ik.im = (2+j+k)*(sym0);
          ik2.im = -(1+k)*(sym0);
          ik3.im = -(1+j)*(sym0) + (sym1);
          iomega = 1i*(2+j+k)*(omega);
          iomega2 = -1i*(1+k)*(omega);
          iomega3 = -1i*(1+j)*(omega) + (shift);
          Cmat = vT(XMh, XMh, tgv = -20);
          An3i += Cmat;
          um[] = conj(um[]);
          um2[] = conj(um2[]);
          ik.im *= -1.0;
          ik2.im *= -1.0;
          ik3.im = (1+j)*(sym0) + (sym1);
          iomega *= -1.0;
          iomega2 *= -1.0;
          iomega3 = 1i*(1+j)*(omega) + (shift);
          Cmat = vT(XMh, XMh, tgv = -20);
          An2r += Cmat;
        }
        if (k < j) {
          um[] = 0.5*uh(:, j-k-1);
          um2[] = uh(:, k);
          ik.im = (j-k)*(sym0);
          ik2.im = (1+k)*(sym0);
          ik3.im = -(1+j)*(sym0) + (sym1);
          iomega = 1i*(j-k)*(omega);
          iomega2 = 1i*(1+k)*(omega);
          iomega3 = -1i*(1+j)*(omega) + (shift);
          Cmat = vT(XMh, XMh, tgv = -20);
          An3i += Cmat;
          um[] = conj(um[]);
          um2[] = conj(um2[]);
          ik.im *= -1.0;
          ik2.im *= -1.0;
          ik3.im = (1+j)*(sym0) + (sym1);
          iomega *= -1.0;
          iomega2 *= -1.0;
          iomega3 = 1i*(1+j)*(omega) + (shift);
          Cmat = vT(XMh, XMh, tgv = -20);
          An2r += Cmat;
        }
      }
      constructor(JHBtemp(0, 1+2*j), J, An2r);
      constructor(JHBtemp(0, 2+2*j), J, An3i);
    }
    for (int nh = 0; nh < Nh; nh++){
      sym = (1+nh)*(sym0) + (sym1);
      um[] = uh(:, nh);
      ik.im = (1+nh)*(sym0);
      ik2.im = (sym1);
      iomega = 1i*(1+nh)*(omega);
      iomega2 = (shift);
      An2r = vH(XMh, XMh, tgv = -20);
      sym = -(1+nh)*(sym0) + (sym1);
      um[] = conj(um[]);
      ik.im *= -1.0;
      iomega *= -1.0;
      An3i = vH(XMh, XMh, tgv = -20);
      ik3.im = (sym1);
      iomega3 = (shift);
      for (int j = 0; j < Nh; j++) {
        if (j != nh) {
          sym = (1+nh)*(sym0) + (sym1);
          um[] = uh(:, j);
          if (j < nh) um2[] = 0.5*uh(:, nh-j-1);
          else um2[] = conj(uh(:, j-nh-1));
          ik.im = (1+j)*(sym0);
          ik2.im = (nh-j)*(sym0);
          iomega = 1i*(1+j)*(omega);
          iomega2 = 1i*(nh-j)*(omega);
          Cmat = vT(XMh, XMh, tgv = -20);
          An2r += Cmat;
          sym = -(1+nh)*(sym0) + (sym1);
          um[] = conj(um[]);
          um2[] = conj(um2[]);
          ik.im *= -1.0;
          ik2.im *= -1.0;
          iomega *= -1.0;
          iomega2 *= -1.0;
          Cmat = vT(XMh, XMh, tgv = -20);
          An3i += Cmat;
        }
      }
      constructor(JHBtemp(1+2*nh, 0), J, An2r);
      constructor(JHBtemp(2+2*nh, 0), J, An3i);
      for (int j = 0; j < Nh; j++) {
        matrix<complex> An3r(ub[].n,ub[].n), An2i(ub[].n,ub[].n);
        if (j == nh) {
          sym = (1+nh)*(sym0) + (sym1);
          ik.im = sym;
          iomega = 1i*(1+nh)*(omega) + (shift);
          An2r = vJ(XMh, XMh, tgv = -2);
          sym = -(1+nh)*(sym0) + (sym1);
          ik.im = sym;
          iomega = -1i*(1+nh)*(omega) + (shift);
          An3i = vJ(XMh, XMh, tgv = -2);
        }
        else if (j < nh) {
          sym = (1+nh)*(sym0) + (sym1);
          um[] = uh(:, nh-j-1);
          ik.im = (nh-j)*(sym0);
          ik2.im = (1+j)*(sym0) + (sym1);
          iomega = 1i*(nh-j)*(omega);
          iomega2 = 1i*(1+j)*(omega) + (shift);
          An2r = vH(XMh, XMh, tgv = -20);
          sym = -(1+nh)*(sym0) + (sym1);
          um[] = conj(um[]);
          ik.im *= -1.0;
          ik2.im = -(1+j)*(sym0) + (sym1);
          iomega *= -1.0;
          iomega2 = -1i*(1+j)*(omega) + (shift);
          An3i = vH(XMh, XMh, tgv = -20);
        }
        else {
          sym = (1+nh)*(sym0) + (sym1);
          um[] = conj(uh(:, j-nh-1));
          ik.im = (nh-j)*(sym0);
          ik2.im = (1+j)*(sym0) + (sym1);
          iomega = 1i*(nh-j)*(omega);
          iomega2 = 1i*(1+j)*(omega) + (shift);
          An2r = vH(XMh, XMh, tgv = -20);
          sym = -(1+nh)*(sym0) + (sym1);
          um[] = conj(um[]);
          ik.im *= -1.0;
          ik2.im = -(1+j)*(sym0) + (sym1);
          iomega *= -1.0;
          iomega2 = -1i*(1+j)*(omega) + (shift);
          An3i = vH(XMh, XMh, tgv = -20);
        }
        if (j < Nh-nh-1) {
          sym = (1+nh)*(sym0) + (sym1);
          um[] = uh(:, 1+nh+j);
          ik.im = (2+nh+j)*(sym0);
          ik2.im = -(1+j)*(sym0) + (sym1);
          iomega = 1i*(2+nh+j)*(omega);
          iomega2 = -1i*(1+j)*(omega) + (shift);
          An3r = vH(XMh, XMh, tgv = -20);
          sym = -(1+nh)*(sym0) + (sym1);
          um[] = conj(um[]);
          ik.im *= -1.0;
          ik2.im = (1+j)*(sym0) + (sym1);
          iomega *= -1.0;
          iomega2 = 1i*(1+j)*(omega) + (shift);
          An2i = vH(XMh, XMh, tgv = -20);
        }
        for (int k = 0; k < Nh; k++) {
          if (k != nh-j-1 && k < Nh+nh-j) {
            sym = (1+nh)*(sym0) + (sym1);
            if (k < nh-j-1) um[] = 0.5*uh(:, nh-j-k-2);
            else um[] = conj(uh(:, j+k-nh));
            um2[] = uh(:, k);
            ik.im = (nh-j-k-1)*(sym0);
            ik2.im = (1+k)*(sym0);
            ik3.im = (1+j)*(sym0) + (sym1);
            iomega = 1i*(nh-j-k-1)*(omega);
            iomega2 = 1i*(1+k)*(omega);
            iomega3 = 1i*(1+j)*(omega) + (shift);
            Cmat = vT(XMh, XMh, tgv = -20);
            An2r += Cmat;
            sym = -(1+nh)*(sym0) + (sym1);
            um[] = conj(um[]);
            um2[] = conj(um2[]);
            ik.im *= -1.0;
            ik2.im *= -1.0;
            ik3.im = -(1+j)*(sym0) + (sym1);
            iomega *= -1.0;
            iomega2 *= -1.0;
            iomega3 = -1i*(1+j)*(omega) + (shift);
            Cmat = vT(XMh, XMh, tgv = -20);
            An3i += Cmat;
          }
          if (k < 1+j+nh && k > j+nh-Nh) {
            sym = (1+nh)*(sym0) + (sym1);
            um[] = 0.5*uh(:, nh+j-k);
            um2[] = uh(:, k);
            ik.im = (1+nh+j-k)*(sym0);
            ik2.im = (1+k)*(sym0);
            ik3.im = -(1+j)*(sym0) + (sym1);
            iomega = 1i*(1+nh+j-k)*(omega);
            iomega2 = 1i*(1+k)*(omega);
            iomega3 = -1i*(1+j)*(omega) + (shift);
            Cmat = vT(XMh, XMh, tgv = -20);
            An3r += Cmat;
            sym = -(1+nh)*(sym0) + (sym1);
            um[] = conj(um[]);
            um2[] = conj(um2[]);
            ik.im *= -1.0;
            ik2.im *= -1.0;
            ik3.im = (1+j)*(sym0) + (sym1);
            iomega *= -1.0;
            iomega2 *= -1.0;
            iomega3 = 1i*(1+j)*(omega) + (shift);
            Cmat = vT(XMh, XMh, tgv = -20);
            An2i += Cmat;
          }
          if (k < j-nh-1) {
            sym = (1+nh)*(sym0) + (sym1);
            um[] = conj(uh(:, j-k-nh-2));
            um[] *= 0.5;
            um2[] = conj(uh(:, k));
            ik.im = -(j-k-nh-1)*(sym0);
            ik2.im = -(1+k)*(sym0);
            ik3.im = (1+j)*(sym0) + (sym1);
            iomega = -1i*(j-k-nh-1)*(omega);
            iomega2 = -1i*(1+k)*(omega);
            iomega3 = 1i*(1+j)*(omega) + (shift);
            Cmat = vT(XMh, XMh, tgv = -20);
            An2r += Cmat;
            sym = -(1+nh)*(sym0) + (sym1);
            um[] = conj(um[]);
            um2[] = conj(um2[]);
            ik.im *= -1.0;
            ik2.im *= -1.0;
            ik3.im = -(1+j)*(sym0) + (sym1);
            iomega *= -1.0;
            iomega2 *= -1.0;
            iomega3 = -1i*(1+j)*(omega) + (shift);
            Cmat = vT(XMh, XMh, tgv = -20);
            An3i += Cmat;
          }
          if (k < Nh-nh-j-2) {
            sym = (1+nh)*(sym0) + (sym1);
            um[] = uh(:, j+k+nh+2);
            um2[] = conj(uh(:, k));
            ik.im = (3+j+k+nh)*(sym0);
            ik2.im = -(1+k)*(sym0);
            ik3.im = -(1+j)*(sym0) + (sym1);
            iomega = 1i*(3+j+k+nh)*(omega);
            iomega2 = -1i*(1+k)*(omega);
            iomega3 = -1i*(1+j)*(omega) + (shift);
            Cmat = vT(XMh, XMh, tgv = -20);
            An3r += Cmat;
            sym = -(1+nh)*(sym0) + (sym1);
            um[] = conj(um[]);
            um2[] = conj(um2[]);
            ik.im *= -1.0;
            ik2.im *= -1.0;
            ik3.im = (1+j)*(sym0) + (sym1);
            iomega *= -1.0;
            iomega2 *= -1.0;
            iomega3 = 1i*(1+j)*(omega) + (shift);
            Cmat = vT(XMh, XMh, tgv = -20);
            An2i += Cmat;
          }
        }
        constructor(JHBtemp(1+2*nh, 1+2*j), J, An2r);
        constructor(JHBtemp(1+2*nh, 2+2*j), J, An3r);
        constructor(JHBtemp(2+2*nh, 1+2*j), J, An2i);
        constructor(JHBtemp(2+2*nh, 2+2*j), J, An3i);
      }
    }
    Mat<complex> convert(JHBtemp);
    MatConvert(convert, JHB);
} // EOM

macro MassHBcplx(MHB, J, ub, uh, sym0, sym1) {
    sym = (sym1);
    ik.im = (sym1);
    Mat<complex>[int, int] MHBtemp(1+2*Nh, 1+2*Nh);
    matrix<complex> An3i, An2r = vM(XMh, XMh, tgv = -20);
    constructor(MHBtemp(0, 0), J, An2r);
    for (int nh = 0; nh < Nh; nh++) {
      sym = (1+nh)*(sym0) + (sym1);
      ik.im = sym;
      An2r = vM(XMh, XMh, tgv = -20);
      sym = -(1+nh)*(sym0) + (sym1);
      ik.im = sym;
      An3i = vM(XMh, XMh, tgv = -20);
      constructor(MHBtemp(1+2*nh, 1+2*nh), J, An2r);
      constructor(MHBtemp(2+2*nh, 2+2*nh), J, An3i);
    }
    Mat<complex> convert(MHBtemp);
    MatConvert(convert, MHB);
} // EOM
/*
macro MassHBcplx(MHB, J, ub, uh, sym0, sym1) {
    sym = (sym1);
    ik.im = (sym1);
    Mat<complex>[int, int] MHBtemp(1+2*Nh, 1+2*Nh);
    matrix<complex> Cmat, An3i, An2r = vM(XMh, XMh, tgv = -20);
    ik3.im = (sym1);
    for (int j = 0; j < Nh; j++){
      um[] = uh(:, j);
      um2[] = conj(um[]);
      ik.im = (1+j)*(sym0);
      ik2 = conj(ik);
      Cmat = vddM(XMh, XMh, tgv = -20);
      An2r += Cmat;
    }
    constructor(MHBtemp(0, 0), J, An2r);
    for (int j = 0; j < Nh; j++){
      um[] = uh(:, j);
      ik.im = (1+j)*(sym0);
      ik2.im = -(1+j)*(sym0) + (sym1);
      An3i = vdM(XMh, XMh, tgv = -20);
      um[] = conj(um[]);
      ik.im *= -1.0;
      ik2.im = (1+j)*(sym0) + (sym1);
      An2r = vdM(XMh, XMh, tgv = -20);
      for (int k = 0; k < Nh; k++){
        if (k < Nh-j-1) {
          um[] = uh(:, 1+j+k);
          um2[] = conj(uh(:, k));
          ik.im = (2+j+k)*(sym0);
          ik2.im = -(1+k)*(sym0);
          ik3.im = -(1+j)*(sym0) + (sym1);
          Cmat = vddM(XMh, XMh, tgv = -20);
          An3i += Cmat;
          um[] = conj(um[]);
          um2[] = conj(um2[]);
          ik.im *= -1.0;
          ik2.im *= -1.0;
          ik3.im = (1+j)*(sym0) + (sym1);
          Cmat = vddM(XMh, XMh, tgv = -20);
          An2r += Cmat;
        }
        if (k < j) {
          um[] = 0.5*uh(:, j-k-1);
          um2[] = uh(:, k);
          ik.im = (j-k)*(sym0);
          ik2.im = (1+k)*(sym0);
          ik3.im = -(1+j)*(sym0) + (sym1);
          Cmat = vddM(XMh, XMh, tgv = -20);
          An3i += Cmat;
          um[] = conj(um[]);
          um2[] = conj(um2[]);
          ik.im *= -1.0;
          ik2.im *= -1.0;
          ik3.im = (1+j)*(sym0) + (sym1);
          Cmat = vddM(XMh, XMh, tgv = -20);
          An2r += Cmat;
        }
      }
      constructor(MHBtemp(0, 1+2*j), J, An2r);
      constructor(MHBtemp(0, 2+2*j), J, An3i);
    }
    for (int nh = 0; nh < Nh; nh++){
      sym = (1+nh)*(sym0) + (sym1);
      um[] = uh(:, nh);
      ik.im = (1+nh)*(sym0);
      ik2.im = (sym1);
      An2r = vdM(XMh, XMh, tgv = -20);
      sym = -(1+nh)*(sym0) + (sym1);
      um[] = conj(um[]);
      ik.im *= -1.0;
      ik2.im = (sym1);
      An3i = vdM(XMh, XMh, tgv = -20);
      ik3.im = (sym1);
      for (int j = 0; j < Nh; j++) {
        if (j != nh) {
          sym = (1+nh)*(sym0) + (sym1);
          um[] = uh(:, j);
          if (j < nh) um2[] = 0.5*uh(:, nh-j-1);
          else um2[] = conj(uh(:, j-nh-1));
          ik.im = (1+j)*(sym0);
          ik2.im = (nh-j)*(sym0);
          Cmat = vddM(XMh, XMh, tgv = -20);
          An2r += Cmat;
          sym = -(1+nh)*(sym0) + (sym1);
          um[] = conj(um[]);
          um2[] = conj(um2[]);
          ik.im *= -1.0;
          ik2.im *= -1.0;
          Cmat = vddM(XMh, XMh, tgv = -20);
          An3i += Cmat;
        }
      }
      constructor(MHBtemp(1+2*nh, 0), J, An2r);
      constructor(MHBtemp(2+2*nh, 0), J, An3i);
      for (int j = 0; j < Nh; j++) {
        matrix<complex> An3r(ub[].n,ub[].n), An2i(ub[].n,ub[].n);
        if (j == nh) {
          sym = (1+nh)*(sym0) + (sym1);
          ik.im = sym;
          An2r = vM(XMh, XMh, tgv = -20);
          sym = -(1+nh)*(sym0) + (sym1);
          ik.im = sym;
          An3i = vM(XMh, XMh, tgv = -20);
        }
        else if (j < nh) {
          sym = (1+nh)*(sym0) + (sym1);
          um[] = uh(:, nh-j-1);
          ik.im = (nh-j)*(sym0);
          ik2.im = (1+j)*(sym0) + (sym1);
          An2r = vdM(XMh, XMh, tgv = -20);
          sym = -(1+nh)*(sym0) + (sym1);
          um[] = conj(um[]);
          ik.im *= -1.0;
          ik2.im = -(1+j)*(sym0) + (sym1);
          An3i = vdM(XMh, XMh, tgv = -20);
        }
        else {
          sym = (1+nh)*(sym0) + (sym1);
          um[] = conj(uh(:, j-nh-1));
          ik.im = (nh-j)*(sym0);
          ik2.im = (1+j)*(sym0) + (sym1);
          An2r = vdM(XMh, XMh, tgv = -20);
          sym = -(1+nh)*(sym0) + (sym1);
          um[] = conj(um[]);
          ik.im *= -1.0;
          ik2.im = -(1+j)*(sym0) + (sym1);
          An3i = vdM(XMh, XMh, tgv = -20);
        }
        if (j < Nh-nh-1) {
          sym = (1+nh)*(sym0) + (sym1);
          um[] = uh(:, 1+nh+j);
          ik.im = (2+nh+j)*(sym0);
          ik2.im = -(1+j)*(sym0) + (sym1);
          An3r = vdM(XMh, XMh, tgv = -20);
          sym = -(1+nh)*(sym0) + (sym1);
          um[] = conj(um[]);
          ik.im *= -1.0;
          ik2.im = (1+j)*(sym0) + (sym1);
          An2i = vdM(XMh, XMh, tgv = -20);
        }
        for (int k = 0; k < Nh; k++) {
          if (k != nh-j-1 && k < Nh+nh-j) {
            sym = (1+nh)*(sym0) + (sym1);
            if (k < nh-j-1) um[] = 0.5*uh(:, nh-j-k-2);
            else um[] = conj(uh(:, j+k-nh));
            um2[] = uh(:, k);
            ik.im = (nh-j-k-1)*(sym0);
            ik2.im = (1+k)*(sym0);
            ik3.im = (1+j)*(sym0) + (sym1);
            Cmat = vddM(XMh, XMh, tgv = -20);
            An2r += Cmat;
            sym = -(1+nh)*(sym0) + (sym1);
            um[] = conj(um[]);
            um2[] = conj(um2[]);
            ik.im *= -1.0;
            ik2.im *= -1.0;
            ik3.im = -(1+j)*(sym0) + (sym1);
            Cmat = vddM(XMh, XMh, tgv = -20);
            An3i += Cmat;
          }
          if (k < 1+j+nh && k > j+nh-Nh) {
            sym = (1+nh)*(sym0) + (sym1);
            um[] = 0.5*uh(:, nh+j-k);
            um2[] = uh(:, k);
            ik.im = (1+nh+j-k)*(sym0);
            ik2.im = (1+k)*(sym0);
            ik3.im = -(1+j)*(sym0) + (sym1);
            Cmat = vddM(XMh, XMh, tgv = -20);
            An3r += Cmat;
            sym = -(1+nh)*(sym0) + (sym1);
            um[] = conj(um[]);
            um2[] = conj(um2[]);
            ik.im *= -1.0;
            ik2.im *= -1.0;
            ik3.im = (1+j)*(sym0) + (sym1);
            Cmat = vddM(XMh, XMh, tgv = -20);
            An2i += Cmat;
          }
          if (k < j-nh-1) {
            sym = (1+nh)*(sym0) + (sym1);
            um[] = conj(uh(:, j-k-nh-2));
            um[] *= 0.5;
            um2[] = conj(uh(:, k));
            ik.im = -(j-k-nh-1)*(sym0);
            ik2.im = -(1+k)*(sym0);
            ik3.im = (1+j)*(sym0) + (sym1);
            Cmat = vddM(XMh, XMh, tgv = -20);
            An2r += Cmat;
            sym = -(1+nh)*(sym0) + (sym1);
            um[] = conj(um[]);
            um2[] = conj(um2[]);
            ik.im *= -1.0;
            ik2.im *= -1.0;
            ik3.im = -(1+j)*(sym0) + (sym1);
            Cmat = vddM(XMh, XMh, tgv = -20);
            An3i += Cmat;
          }
          if (k < Nh-nh-j-2) {
            sym = (1+nh)*(sym0) + (sym1);
            um[] = uh(:, j+k+nh+2);
            um2[] = conj(uh(:, k));
            ik.im = (3+j+k+nh)*(sym0);
            ik2.im = -(1+k)*(sym0);
            ik3.im = -(1+j)*(sym0) + (sym1);
            Cmat = vddM(XMh, XMh, tgv = -20);
            An3r += Cmat;
            sym = -(1+nh)*(sym0) + (sym1);
            um[] = conj(um[]);
            um2[] = conj(um2[]);
            ik.im *= -1.0;
            ik2.im *= -1.0;
            ik3.im = (1+j)*(sym0) + (sym1);
            Cmat = vddM(XMh, XMh, tgv = -20);
            An2i += Cmat;
          }
        }
        constructor(MHBtemp(1+2*nh, 1+2*j), J, An2r);
        constructor(MHBtemp(1+2*nh, 2+2*j), J, An3r);
        constructor(MHBtemp(2+2*nh, 1+2*j), J, An2i);
        constructor(MHBtemp(2+2*nh, 2+2*j), J, An3i);
      }
    }
    Mat<complex> convert(MHBtemp);
    MatConvert(convert, MHB);
} // EOM
*/
// Load mesh, make FE basis
string fileroot, fileext = parsefilename(filein, fileroot); //extract file name and extension
parsefilename(fileout, fileout); // trim extension from output file, if given
if(fileext == "floq"){
  filein = readbasename(workdir + filein);
  fileext = parsefilename(filein, fileroot);
}
if(filein != "" && meshin == "") meshin = readmeshname(workdir + filein); // get mesh file
Th = readmeshN(workdir + meshin);
Thg = Th;
buildDmesh(Th);
restu = restrict(XMh, XMhg, n2o);
XMh defu(ub);
XMh<complex> defu(um), defu(um2), defu(um3);
complex[int, int] uh(um[].n, max(1, Nh));
if (fileext == "porb") {
  ub[] = loadporb(fileroot, meshin, uh, sym0, omega, Nh);
}
else assert(false); // invalid input filetype
Nh = max(1, Nh); // Nh must be at least 1, otherwise use basecompute.edp

// Create distributed Mat
Mat<complex> J;
createMatu(Th, J, Pk);

complex[int] val(epsnev);
complex[int, int] arr((1+2*Nh)*J.n, epsnev);

sym1 = parsesymstr(symstr);
complex[int] ik(sym.n), ik2(sym.n), ik3(sym.n);
complex iomega, iomega2, iomega3;
include "eqns.idp" // load equations

int sepcharind = max(epstarget.rfind("+"), epstarget.rfind("-"));
complex shifts = atof(epstarget(0:sepcharind)) + 1i*atof(epstarget(sepcharind:epstarget.length-2));
complex shift = shifts;
sepcharind = max(targetf.rfind("+"), targetf.rfind("-"));
complex shiftf = atof(targetf(0:sepcharind)) + 1i*atof(targetf(sepcharind:targetf.length-2));

Mat<complex> JHB, MHB;
JacobianHBcplx(JHB, J, ub, uh, sym0, sym1, omega, 0);
JHB *= -1.0;
MassHBcplx(MHB, J, ub, uh, sym0, sym1);

real[int] fieldlabels(JHB.n);
fieldlabels(0: J.n-1) = 1;
blocks = min(blocks, 1+Nh);
for (int nh = 0; nh < Nh; nh++) fieldlabels((1+2*nh)*J.n:(3+2*nh)*J.n-1) = 1 + max(0, blocks + nh - Nh);
string HBKSPparams = KSPparams;
if (blocks > 1) HBKSPparams = "-ksp_type gmres -ksp_norm_type unpreconditioned -ksp_pc_side right -pc_type fieldsplit -pc_fieldsplit_type symmetric_multiplicative -fieldsplit_pc_type lu -ksp_gmres_cgs_refinement_type refine_ifneeded";
for (int n = 0; n < ntarget; ++n){
  if (ntarget > 1) shift = shifts + (shiftf - shifts)*real(n)/real(ntarget - 1);
  int k = EPSSolve(JHB, MHB, array = arr, values = val, fields = fieldlabels, 
                 sparams = "-st_type sinvert -options_left no -eps_monitor_conv -prefix_push st_ " + HBKSPparams + " -prefix_pop -eps_target " + string(shift));
  if (strictnev) {// activate to limit number of eigenpairs
    val.resize(min(k, epsnev));
    arr.resize((1+2*Nh)*J.n,min(k, epsnev));
  }
  complex[int, int] vec((1+2*Nh)*um[].n, val.n); 
  for (int ii = 0; ii < val.n; ++ii)
    for (int jj = 0; jj < (1+2*Nh); ++jj) {
      ChangeNumbering(J, um[], arr(jj*J.n:(1+jj)*J.n-1, ii), inverse = true);
      vec(jj*um[].n:(1+jj)*um[].n-1, ii) = um[];
    }
  savefloq(fileout + ((ntarget > 1) ? ("_" + n) : ""), statout, filein, meshin, vec, val, omega, Nh, sym0, sym1, (fileout != ""));
}