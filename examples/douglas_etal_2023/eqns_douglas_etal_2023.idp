//
// eqns_douglas_etal_2023.idp
// Chris Douglas
// cdoug@mit.edu
//
// Define KSP parameters
  string KSPparams = "-ksp_type preonly -pc_type lu";
// term macros ------------------------------------------------------
  macro ndotgrads(s) ( y*( N.x*dx(s) + N.y*dy(s))) // EOM

  macro gdotf(f, g) ( y*g*f )//EOM

  macro vdotu(v, u) ( y*(v*u + v#y*u#y + v#z*u#z) ) //EOM

  macro div(ik, u) ( y*(dx(u) + dy(u#y)) + u#y + (ik)*u#z ) // velocity divergence

  macro ndotvisc(v, ik, u) (  N.x*(y*(v*dx(u  ) + v#y*dy(u  )) + v#z*(ik)*u ) 
                            + N.y*(y*(v*dx(u#y) + v#y*dy(u#y)) + v#z*((ik)*u#y - u#z) )) //EOM

  macro ugradu(v, U, ik, u) ( v  *(y*(U*dx(u  ) + U#y*dy(u  )) + (ik)*U#z*u )
                            + v#y*(y*(U*dx(u#y) + U#y*dy(u#y)) + (ik)*U#z*u#y - U#z*u#z )
                            + v#z*(y*(U*dx(u#z) + U#y*dy(u#z)) + (ik)*U#z*u#z + U#z*u#y) ) // scaled convection term

  macro visc(ij, v, ik, u) ( 2.*y*dx(v  )*dx(u  )              +    y*dy(v  )*(dx(u#y) + dy(u  ))          +     (ij)*v         *( dx(u#z) + (ik)/y*u)
                              + y*dx(v#y)*(dx(u#y) + dy(u  ))  + 2.*y*dy(v#y)*dy(u#y)                      +    ((ij)*v#y - v#z)*(((ik)*u#y - u#z)/y + dy(u#z) )
                              +   dx(v#z)*((ik)*u + y*dx(u#z)) +      dy(v#z)*((ik)*u#y - u#z + y*dy(u#z)) + 2.*((ij)*v#z + v#y)*((ik)*u#z + u#y)/y ) // EOM

  macro diff(ij, g, ik, f) ( y*(dx(g)*dx(f) + dy(g)*dy(f)) + (ij)*(ik)*g*f/y ) // EOM

  macro ugradf(U, ik, f) ( y*(U*dx(f) + U#y*dy(f)) + (ik)*U#z*f ) // EOM

// Arrhenius reaction rate macro
  macro ubArr() ( params["Da"]*exp(params["Ze"]*(1. + 1./params["dT"])*(1. - (1. + params["dT"])/ubT)) ) // EOM
  macro dubArrdT() ( (params["Ze"]/params["dT"]*(1. + params["dT"])^2./ubT^2.)*ubArr ) // EOM
  macro d2ubArrdT2() ( (-2.*params["Ze"]/params["dT"]*(1. + params["dT"])^2./ubT^3. + (params["Ze"]/params["dT"]*(1. + params["dT"])^2./ubT^2.)^2.)*ubArr ) // EOM
  macro d3ubArrdT3() ( (6.*params["Ze"]/params["dT"]*(1. + params["dT"])^2./ubT^4. + (params["Ze"]/params["dT"]*(1. + params["dT"])^2./ubT^2.)^3. + 3.*(params["Ze"]/params["dT"]*(1. + params["dT"])^2./ubT^2.)*(-2.*params["Ze"]/params["dT"]*(1. + params["dT"])^2./ubT^3.))*ubArr ) // EOM
// power-law viscosity macro
  macro ubmu() ( ubT^(params["a"]) ) // EOM
  macro dubmudT() ( params["a"]*ubT^(params["a"] - 1.) ) // EOM
  macro d2ubmudT2() ( params["a"]*(params["a"] - 1.)*ubT^(params["a"] - 2.) ) // EOM
  macro d3ubmudT3() ( params["a"]*(params["a"] - 1.)*(params["a"] - 2.)*ubT^(params["a"] - 3.) ) // EOM

// Boundary conditions
  macro BoundaryConditions(u, U)
    on(BCinflow, u = U - (2. - 8.*y^2), u#y = U#y, u#z = U#z, u#Y = U#Y - 1., u#T = U#T - 1. )
  + on(BCwall, u = U, u#y = U#y, u#z = U#z, u#T = U#T - 1. )
  + on(BCaxis, u#y = U#y, u#z = U#z)
  // EOM
  macro HomBoundaryConditions(u)
    on(BCinflow, u = 0, u#y = 0, u#z = 0, u#Y = 0, u#T = 0 )
  + on(BCwall, u = 0, u#y = 0, u#z = 0, u#T = 0 )
  + on((abs(int(sym(0))) != 1)*BCaxis, u#y = 0, u#z = 0 )
  + on((abs(int(sym(0)))  > 0)*BCaxis, u = 0, u#Y = 0, u#T = 0 )
  // EOM
// RESIDUAL OPERATOR
varf vR(defu(um), defu(v))
      = int2d(Th)(
          vY*(ugradf(ub, 0, ubY) + ubY*ubArr)/ubT + ubmu*diff(0, vY, 0, ubY)/(params["Re"]*params["Pr"]*params["Le"])
        + vT*(ugradf(ub, 0, ubT) - params["dT"]*ubY*ubArr)/ubT + ubmu*diff(0, vT, 0, ubT)/(params["Re"]*params["Pr"])
        + ugradu(v, ub, 0, ub)/ubT - div(0, v)*ubp + ubmu*visc(0, v, 0, ub)/params["Re"]
        + vp*(div(0, ub) - params["dT"]*ubY*ubArr/ubT) + ubmu*diff(0, vp, 0, ubT)/(params["Re"]*params["Pr"])
      )
      - int1d(Th, BCopen)(
        ubmu*ndotvisc(v, 0, ub)/params["Re"]
      )
      - int1d(Th, BCaxis, BCopen, BCwall, BCinflow)(
        vp*ubmu*ndotgrads(ubT)/(params["Re"]*params["Pr"])
      )
      + BoundaryConditions(um, ub);

// JACOBIAN OPERATOR
varf vJ(defu(dum), defu(v))
      = int2d(Th)(
        iomega*(gdotf(vY, dumY) + gdotf(vT, dumT) + vdotu(v, dum))/ubT
        + vY*((ugradf(dum, 0, ubY) + ugradf(ub, ik(0), dumY) + dumY*ubArr + ubY*dubArrdT*dumT)/ubT - (ugradf(ub, 0, ubY) + ubY*ubArr)/ubT^2.*dumT) + (dubmudT*dumT*diff(-ik(0), vY, 0, ubY) + ubmu*diff(-ik(0), vY, ik(0), dumY))/(params["Re"]*params["Pr"]*params["Le"])
        + vT*((ugradf(dum, 0, ubT) + ugradf(ub, ik(0), dumT) - params["dT"]*(dumY*ubArr + ubY*dubArrdT*dumT))/ubT - (ugradf(ub, 0, ubT) - params["dT"]*ubY*ubArr)/ubT^2.*dumT) + (dubmudT*dumT*diff(-ik(0), vT, 0, ubT) + ubmu*diff(-ik(0), vT, ik(0), dumT))/(params["Re"]*params["Pr"])
        + (ugradu(v, dum, 0, ub) + ugradu(v, ub, ik(0), dum))/ubT - ugradu(v, ub, 0, ub)/ubT^2.*dumT - div(-ik(0), v)*dump + (dubmudT*dumT*visc(-ik(0), v, 0, ub) + ubmu*visc(-ik(0), v, ik(0), dum))/params["Re"]
        + vp*(div(ik(0), dum) - params["dT"]*((dumY*ubArr + ubY*dubArrdT*dumT)/ubT - ubY*ubArr/ubT^2.*dumT)) + (dubmudT*dumT*diff(-ik(0), vp, 0, ubT) + ubmu*diff(-ik(0), vp, ik(0), dumT))/(params["Re"]*params["Pr"])
      )
      - int1d(Th, BCopen)(
        (dubmudT*dumT*ndotvisc(v, 0, ub) + ubmu*ndotvisc(v, ik(0), dum))/params["Re"]
      )
      - int1d(Th, BCaxis, BCopen, BCwall, BCinflow)(
        vp*(dubmudT*dumT*ndotgrads(ubT) + ubmu*ndotgrads(dumT))/(params["Re"]*params["Pr"])
      )
      + int2d(Th)(
        iomega*(gdotf(vY, umY) + gdotf(vT, umT) + vdotu(v, um))/ubT
        + vY*((ugradf(um, 0, ubY) + ugradf(ub, ik(0), umY) + umY*ubArr + ubY*dubArrdT*umT)/ubT - (ugradf(ub, 0, ubY) + ubY*ubArr)/ubT^2.*umT) + (dubmudT*umT*diff(-ik(0), vY, 0, ubY) + ubmu*diff(-ik(0), vY, ik(0), umY))/(params["Re"]*params["Pr"]*params["Le"])
        + vT*((ugradf(um, 0, ubT) + ugradf(ub, ik(0), umT) - params["dT"]*(umY*ubArr + ubY*dubArrdT*umT))/ubT - (ugradf(ub, 0, ubT) - params["dT"]*ubY*ubArr)/ubT^2.*umT) + (dubmudT*umT*diff(-ik(0), vT, 0, ubT) + ubmu*diff(-ik(0), vT, ik(0), umT))/(params["Re"]*params["Pr"])
        + (ugradu(v, um, 0, ub) + ugradu(v, ub, ik(0), um))/ubT - ugradu(v, ub, 0, ub)/ubT^2.*umT - div(-ik(0), v)*ump + (dubmudT*umT*visc(-ik(0), v, 0, ub) + ubmu*visc(-ik(0), v, ik(0), um))/params["Re"]
        + vp*(div(ik(0), um) - params["dT"]*((umY*ubArr + ubY*dubArrdT*umT)/ubT - ubY*ubArr/ubT^2.*umT)) + (dubmudT*umT*diff(-ik(0), vp, 0, ubT) + ubmu*diff(-ik(0), vp, ik(0), umT))/(params["Re"]*params["Pr"])
      )
      - int1d(Th, BCopen)(
        (dubmudT*umT*ndotvisc(v, 0, ub) + ubmu*ndotvisc(v, ik(0), um))/params["Re"]
      )
      - int1d(Th, BCaxis, BCopen, BCwall, BCinflow)(
        vp*(dubmudT*umT*ndotgrads(ubT) + ubmu*ndotgrads(umT))/(params["Re"]*params["Pr"])
      )
      + HomBoundaryConditions(dum);

// MASS OPERATOR
varf vM(defu(dum), defu(v))
      = int2d(Th)( (gdotf(vY, dumY) + gdotf(vT, dumT) + vdotu(v, dum))/ubT )
      + int2d(Th)( (gdotf(vY, umY) + gdotf(vT, umT) + vdotu(v, um))/ubT )
      + HomBoundaryConditions(dum);

// FORCING/RESPONSE WEIGHTING MATRICES (FOR RESOLVENT ANALYSIS)
varf vMq(defu(dum), defu(v))
      = int2d(Th)( (gdotf(vY, dumY) + gdotf(vT, dumT) + vdotu(v, dum))/ubT );

varf vMf(deff(dum), deff(v))
      = int2d(Th)( vdotu(v, dum)/ubT );

varf vP(deff(fm), defu(v))
      = int2d(Th)( vdotu(v, fm) );

// HESSIAN OPERATOR
/*varf vH(defu(dum), defu(v))
      = int2d(Th)(
          vY*(ugradf(um, ik2(0), um2Y) + ugradf(um2, ik(0), umY) +              ddDaYexp(ub, um, um2)                                                          + dddiffdot1Pe(Y, ub, ik(0), um, ik2(0), um2)*params["1/Le"]) + dddiff1Pe(vY, Y, ub, ik(0), um, ik2(0), um2)*params["1/Le"]
        + vT*(ugradf(um, ik2(0), um2T) + ugradf(um2, ik(0), umT) - params["dT"]*ddDaYexp(ub, um, um2)                                                          + dddiffdot1Pe(T, ub, ik(0), um, ik2(0), um2))                + dddiff1Pe(vT, T, ub, ik(0), um, ik2(0), um2)
        + ugradu(v, um, ik2(0), um2) + ugradu(v, um2, ik(0), um) - div(-ik-ik2(0), v)*(ump*um2T + um2p*umT) - ugradf(v, ik(0), umT)*um2p - ugradf(v, ik2(0), um2T)*ump + ddgfdgu1Re(v, ub, ik(0), um, ik2(0), um2)                   + ddvisc1Re(v, ub, ik(0), um, ik2(0), um2)
        + vp*( -um2T*div(ik(0), um) - umT*div(ik2(0), um2)     + params["dT"]*ddDaYexp(ub, um, um2)                                                          - dddiffdot1Pe(T, ub, ik(0), um, ik2(0), um2))                - dddiff1Pe(vp, T, ub, ik(0), um, ik2(0), um2)
      )
      - int1d(Th, BCopen) (
        ddndotvisc1Re(v, ub, ik(0), um, ik2(0), um2)
      )
      + int1d(Th, BCaxis, BCopen, BCwall, BCpipe, BCinflow) (
        vp*ddndotgradT1Pe(ub, um, um2)
      )
      + int2d(Th)(
          vY*(ugradf(um, ik2(0), dumY) + ugradf(dum, ik(0), umY) +              ddDaYexp(ub, um, dum)                                                          + dddiffdot1Pe(Y, ub, ik(0), um, ik2(0), dum)*params["1/Le"]) + dddiff1Pe(vY, Y, ub, ik(0), um, ik2(0), dum)*params["1/Le"]
        + vT*(ugradf(um, ik2(0), dumT) + ugradf(dum, ik(0), umT) - params["dT"]*ddDaYexp(ub, um, dum)                                                          + dddiffdot1Pe(T, ub, ik(0), um, ik2(0), dum))                + dddiff1Pe(vT, T, ub, ik(0), um, ik2(0), dum)
        + ugradu(v, um, ik2(0), dum) + ugradu(v, dum, ik(0), um) - div(-ik-ik2(0), v)*(ump*dumT + dump*umT) - ugradf(v, ik(0), umT)*dump - ugradf(v, ik2(0), dumT)*ump + ddgfdgu1Re(v, ub, ik(0), um, ik2(0), dum)                   + ddvisc1Re(v, ub, ik(0), um, ik2(0), dum)
        + vp*( -dumT*div(ik(0), um) - umT*div(ik2(0), dum)     + params["dT"]*ddDaYexp(ub, um, dum)                                                          - dddiffdot1Pe(T, ub, ik(0), um, ik2(0), dum))                - dddiff1Pe(vp, T, ub, ik(0), um, ik2(0), dum)
      )
      - int1d(Th, BCopen) (
        ddndotvisc1Re(v, ub, ik(0), um, ik2(0), dum)
      )
      + int1d(Th, BCaxis, BCopen, BCwall, BCpipe, BCinflow) (
        vp*ddndotgradT1Pe(ub, um, dum)
      )
      + HomBoundaryConditions(dum);

// TRESSIAN OPERATOR (FOR WEAKLY NONLINEAR ANALYSIS)

varf vT(defu(dum), defu(v))
= int2d(Th)(
    vY*(               dddDaYexp(ub, um, um2, um3) + ddddiffdot1Pe(Y, ub, ik(0), um, ik2(0), um2, ik3(0), um3)*params["1/Le"]) + ddddiff1Pe(vY, Y, ub, ik(0), um, ik2(0), um2, ik3(0), um3)*params["1/Le"]
  + vT*( -params["dT"]*dddDaYexp(ub, um, um2, um3) + ddddiffdot1Pe(T, ub, ik(0), um, ik2(0), um2, ik3(0), um3))                + ddddiff1Pe(vT, T, ub, ik(0), um, ik2(0), um2, ik3(0), um3)
                                                   + dddgfdgu1Re(v, ub, ik(0), um, ik2(0), um2, ik3(0), um3)                   + dddvisc1Re(v, ub, ik(0), um, ik2(0), um2, ik3(0), um3)
  + vp*(  params["dT"]*dddDaYexp(ub, um, um2, um3) - ddddiffdot1Pe(T, ub, ik(0), um, ik2(0), um2, ik3(0), um3))                - ddddiff1Pe(vp, T, ub, ik(0), um, ik2(0), um2, ik3(0), um3)
)
- int1d(Th, BCopen) (
  dddndotvisc1Re(v, ub, ik(0), um, ik2(0), um2, ik3(0), um3)
)
+ int1d(Th, BCaxis, BCopen, BCwall, BCpipe, BCinflow) (
  vp*dddndotgradT1Pe(ub, um, um2, um3)
)
+ HomBoundaryConditions(dum);
*/