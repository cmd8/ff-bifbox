// Define KSP parameters
string KSPparams = "";
string EPSparams = " -eps_pos_gen_non_hermitian ";
// RESIDUAL OPERATOR
varf vR(defu(dum), defu(v))
      = int2d(Th)(
        ugradu(v, ub, 0, ub) - divu(0, v)*ubp + visc(0, v, 0, ub)*params["1/Re"]
        - vp*divu(0, ub)
      )
      + BoundaryConditions(0, dum, ub);

// JACOBIAN OPERATOR
varf vJ(defu(dum), defu(v))
      = int2d(Th)(
        iomega*vdotu(v, dum)
        + ugradu(v, dum, 0, ub) + ugradu(v, ub, ik, dum) - divu(-ik, v)*dump + visc(-ik, v , ik, dum )*params["1/Re"]
        - vp*divu(ik, dum)
      )
      + int2d(Th)(
        iomega*vdotu(v, um)
        + ugradu(v, um, 0, ub) + ugradu(v, ub, ik, um) - divu(-ik, v)*ump + visc(-ik, v , ik, um )*params["1/Re"]
        - vp*divu(ik, um)
      )
      + HomBoundaryConditions(sym, dum);

// MASS OPERATOR
varf vM(defu(dum), defu(v))
      = int2d(Th)(
          vdotu(v, dum)
      )
      + int2d(Th)(
          vdotu(v, um)
      )
      + HomBoundaryConditions(sym, dum);

// FORCING/RESPONSE WEIGHTING MATRICES (FOR RESOLVENT ANALYSIS)
varf vMq(defu(dum), defu(v))
      = int2d(Th)( vdotu(v, dum) );

varf vMf(deff(dum), deff(v))
      = int2d(Th)( vdotu(v, dum) );

varf vP(deff(fm), defu(v))
      = int2d(Th)( vdotu(v, fm) );

// HESSIAN OPERATOR
varf vH(defu(dum), defu(v))
      = int2d(Th)(
        ugradu(v, um, ik2, um2) + ugradu(v, um2, ik, um)
      )
      + int2d(Th)(
        ugradu(v, um, ik2, dum) + ugradu(v, dum, ik, um)
      )
      + HomBoundaryConditions(sym, dum);

// TRESSIAN OPERATOR
varf vT(defu(dum), defu(v))
      = HomBoundaryConditions(sym, dum);
