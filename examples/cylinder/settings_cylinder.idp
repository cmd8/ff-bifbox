//
// solversettings.idp
// Chris Douglas
// chris.douglas@ladhyx.polytechnique.fr
//
// NOTE: When starting a project this is one of the main files that should be edited
//
// Set dimension macro for 'macro_ddm.idp' (2)
  macro dimension()2//EOM NOTE: only 2 for now
// Set coordinate system (cartesian or cylindrical)
  macro coordinates()cartesian//EOM
// Set number of vector components (2 or 3)
  macro component()2//EOM
// Load hpddm macros
  include "macro_ddm.idp"
  verbosity = getARGV("-v",0);
// Define parameter and monitor names
  string[int] paramnames = ["1/Re"]; // set parameter names
  string[int] monitornames = ["Cd"]; // set monitor names: Cd = 2*F_drag/(u^2*A)
// Define state vector and FE space
  macro defu(u)[u,u#y    IFMACRO(component,3) ,u#z ENDIFMACRO ,u#p]//EOM
  macro initu(i)[i, i    IFMACRO(component,3) ,i   ENDIFMACRO ,i]//EOM
  func Pk = [P2,P2       IFMACRO(component,3) ,P2  ENDIFMACRO ,P1];
// Define forcing vector and FE space (for resolvent analysis)
  macro deff(f)[f,f#y    IFMACRO(component,3) ,f#z ENDIFMACRO]//EOM
  macro initf(i)[i, i    IFMACRO(component,3) ,i   ENDIFMACRO]//EOM
  func Pkf = [P2,P2      IFMACRO(component,3) ,P2  ENDIFMACRO];
// Define quantities for mesh adaptation and plotting in Paraview
  macro adaptu(u)[u, u#y IFMACRO(component,3) ,u#z ENDIFMACRO] ,u#p//EOM
  macro adaptf(f)[f, f#y IFMACRO(component,3) ,f#z ENDIFMACRO] //EOM
// Name and order for real Paraview outputs
  string ParaviewDataName = "velocity pressure";
  string ParaviewDataNamef = "momentum";
  int[int] ParaviewOrder = [1,1];
  int[int] ParaviewOrderf = [1];
// Name and order for complex Paraview outputs
  string ParaviewDataNamec = "velocity_r pressure_r velocity_i pressure_i";
  string ParaviewDataNamefc = "momentum_r momentum_i";
  int[int] ParaviewOrderc = [ParaviewOrder,ParaviewOrder];
  int[int] ParaviewOrderfc = [ParaviewOrderf,ParaviewOrderf];
  // Initial conditions (if no guess)
  macro InitialConditions()initu(1)//EOM
// Boundary labels
  int BCnull = 0;
  int BCaxis = 1;
  int BCopen = 2;
  int BCinflow = 3;
  int BCwall = 4;
  int BCslip = 5;
// Boundary conditions
  macro BoundaryConditions(sym, u, U)
    on(BCwall, u = U, u#y = U#y IFMACRO(component,3) ,u#z = U#z ENDIFMACRO)
    + on(BCslip, u#y = U#y IFMACRO(component,3) ,u#z = U#z ENDIFMACRO)
    + on(BCinflow, u = U - 1., u#y = U#y IFMACRO(component,3) ,u#z = U#z ENDIFMACRO)
    + on((abs(int(sym)) % 2 == 0)*BCaxis, u#y = U#y IFMACRO(component,3) ,u#z = U#z ENDIFMACRO )
    + on((abs(int(sym)) % 2 != 0)*BCaxis, u = U)
  // EOM
  macro HomBoundaryConditions(sym, u)
    on(BCwall, u = 0, u#y = 0 IFMACRO(component,3) ,u#z = 0 ENDIFMACRO)
    + on(BCslip, u#y = 0 IFMACRO(component,3) ,u#z = 0 ENDIFMACRO)
    + on(BCinflow, u = 0., u#y = 0 IFMACRO(component,3) ,u#z = 0 ENDIFMACRO)
    + on((abs(int(sym)) % 2 == 0)*BCaxis, u#y = 0 IFMACRO(component,3) ,u#z = 0 ENDIFMACRO )
    + on((abs(int(sym)) % 2 != 0)*BCaxis, u = 0)
  // EOM
// Define solution monitors to extract: here drag (D) and lift (L)
  macro getmonitors(u){
    monitors["Cd"] = 4.0*int1d(Thg, BCwall)(u#p*N.x - params["1/Re"]*(2.0*dx(u)*N.x + (dx(u#y) + dy(u))*N.y));
  }// EOM

// term macros ------------------------------------------------------
  macro rinv() (1.0 /(y + 1.0e-12*(y == 0))) // 1/r

IFMACRO(coordinates,cartesian)
  macro vdotu(v, u) ( v*u + v#y*u#y IFMACRO(component,3)+ v#z*u#z ENDIFMACRO) // velocity inner product

  macro divu(ik, u) ( dx(u) + dy(u#y) IFMACRO(component,3) + (ik)*u#z ENDIFMACRO ) // velocity divergence

  macro ugradu(v, U, ik, u) (  v  *(U*dx(u  ) + U#y*dy(u  ) IFMACRO(component,3) + (ik)*U#z*u    ENDIFMACRO )
                             + v#y*(U*dx(u#y) + U#y*dy(u#y) IFMACRO(component,3) + (ik)*U#z*u#y  ENDIFMACRO )
        IFMACRO(component,3) + v#z*(U*dx(u#z) + U#y*dy(u#z)                      + (ik)*U#z*u#z) ENDIFMACRO ) // velocity advection term

  macro visc(ij, v, ik, u)   ( dx(v  )*dx(u  ) + dy(v  )*dy(u  ) IFMACRO(component,3) + (ij)*v  *(ik)*u   ENDIFMACRO
                             + dx(v#y)*dx(u#y) + dy(v#y)*dy(u#y) IFMACRO(component,3) + (ij)*v#y*(ik)*u#y ENDIFMACRO
        IFMACRO(component,3) + dx(v#z)*dx(u#z) + dy(v#z)*dy(u#z)                      + (ij)*v#z*(ik)*u#z ENDIFMACRO ) // viscous term
ENDIFMACRO
IFMACRO(coordinates,cylindrical)
  macro vdotu(v, u) ( y*v*u + y*v#y*u#y IFMACRO(component,3) + y*v#z*u#z ENDIFMACRO) // velocity inner product

  macro divu(ik, u) ( y*dx(u) + y*dy(u#y) + u#y IFMACRO(component,3) + (ik)*u#z ENDIFMACRO ) // velocity divergence

  macro ugradu(v, U, ik, u) (  v  *(y*U*dx(u  ) + y*U#y*dy(u  ) IFMACRO(component,3) + (ik)*U#z*u              ENDIFMACRO )
                             + v#y*(y*U*dx(u#y) + y*U#y*dy(u#y) IFMACRO(component,3) + (ik)*U#z*u#y - U#z*u#z  ENDIFMACRO )
        IFMACRO(component,3) + v#z*(y*U*dx(u#z) + y*U#y*dy(u#z)                      + (ik)*U#z*u#z + U#z*u#y) ENDIFMACRO ) // velocity advection term

  macro visc(ij, v, ik, u) (   y*dx(v  )*dx(u  ) + y*dy(v  )*dy(u  ) IFMACRO(component,3) + rinv*(ij)*v  *(ik)*u ENDIFMACRO
                             + y*dx(v#y)*dx(u#y) + y*dy(v#y)*dy(u#y) IFMACRO(component,3) + rinv*((ij)*v#y - v#z )*((ik)*u#y - u#z) ENDIFMACRO
        IFMACRO(component,3) + y*dx(v#z)*dx(u#z) + y*dy(v#z)*dy(u#z) ENDIFMACRO           + rinv*( IFMACRO(component,3) (ij)*v#z + ENDIFMACRO v#y)*(  IFMACRO(component,3) (ik)*u#z + ENDIFMACRO u#y) ) // viscous term
ENDIFMACRO
