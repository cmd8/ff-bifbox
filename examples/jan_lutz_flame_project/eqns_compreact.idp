//
// eqns_jan_project.idp
// Chris Douglas
// chris.douglas@ladhyx.polytechnique.fr
//
// Define KSP parameters
  string KSPparams = " -ksp_type preonly -pc_type lu ";
  string EPSparams = " -st_type sinvert -st_pc_type lu -eps_pos_gen_non_hermitian ";

// term macros ------------------------------------------------------
macro gdotf(g, f) ( g*f )//EOM

macro vdotu(v, u) ( v*u + v#y*u#y ) //EOM

macro div(ik, u) ( dx(u) + dy(u#y) ) // velocity divergence

macro ndotvisc(v, ik, u) (N.x*(v*(dx(u  ) - 2./3.*div(ik, u)) + v#y*dy(u  )                       )
                        + N.y*(v*dx(u#y)                       + v#y*(dy(u#y) - 2./3.*div(ik, u)) )) //EOM

macro ugradu(v, U, ik, u) (  v  *(U*dx(u  ) + U#y*dy(u  ) )
                           + v#y*(U*dx(u#y) + U#y*dy(u#y) ) ) // scaled convection term

macro visc(ij, v, ik, u)   ( dx(v  )*(2.*dx(u  ) - 2./3.*div(ik, u))  + dy(v  )*(dx(u#y) + dy(u  ))
                           + dx(v#y)*(dx(u#y) + dy(u  ))               + dy(v#y)*(2.*dy(u#y) - 2./3.*div(ik, u)) ) // EOM

macro diff(ij, g, ik, f) ( dx(g)*dx(f) + dy(g)*dy(f) ) // EOM

macro ugradf(U, ik, f)   ( U*dx(f) + U#y*dy(f) ) // EOM

macro Daexp(u) ( params["Da"]*exp(-params["Ze"]/params["dT"]*(1.0 + params["dT"])*(1.0 + params["dT"] - u#T)/u#T) ) // EOM
// Boundary conditions
  macro BoundaryConditions(u, U)
    on(BCwall, BCcyl, u = U, u#y = U#y, u#T = U#T - 1.0)
    + on(BCinflow, u = U - (2.0 - 8.0*y^2), u#y = U#y, u#T = U#T - 1.0, u#Y = U#Y - 1.0)
    + on(BCaxis, u#y = U#y)
  // EOM
  macro HomBoundaryConditions(sym, u)
    on(BCwall, BCcyl, u = 0, u#y = 0, u#T = 0)
    + on(BCinflow, u = 0, u#y = 0, u#T = 0, u#Y = 0)
    + on((abs(int(sym)) % 2 == 0)*BCaxis, u#y = 0 )
    + on((abs(int(sym)) % 2 != 0)*BCaxis, u = 0, u#T = 0, u#Y = 0)
  // EOM

// RESIDUAL OPERATOR
varf vR(defu(um), defu(v))
      = int2d(Th)(
        vY*ubR*(ugradf(ub, 0, ubY) + ubY*Daexp(ub)) + ubT^(params["a"])*diff(0, vY, 0, ubY)/(params["Re"]*params["Pr"]*params["Le"])
        + vR*(ugradf(ub, 0, ubR) + ubR*div(0, ub))
        + ubR*ugradu(v, ub, 0, ub) - 1.0/(params["gamma"]*params["Ma"]^2)*div(0, v)*(ubR*ubT - 1.0) + ubT^(params["a"])*visc(0, v, 0, ub)/params["Re"]
        + vT*(ubR*(ugradf(ub, 0, ubT) - params["gamma"]*params["dT"]*ubY*Daexp(ub)) + (params["gamma"] - 1.0)*ubR*ubT*div(0, ub))
        - vT*params["gamma"]*(params["gamma"] - 1.0)*params["Ma"]^2./params["Re"]*ubT^(params["a"])*visc(0, ub, 0, ub)
        + params["gamma"]/(params["Re"]*params["Pr"])*ubT^(params["a"])*diff(0, vT, 0, ubT)
      )
      - int1d(Th, BCopen) (
        ubT^(params["a"])*ndotvisc(v, 0, ub)/params["Re"]
      )
      + BoundaryConditions(um, ub);

// JACOBIAN OPERATOR
varf vJ(defu(dum), defu(v))
      = int2d(Th)(
        iomega*(gdotf(vR, dumR) + ubR*(gdotf(vY, dumY) + gdotf(vT, dumT) + vdotu(v, dum)))
        + vY*(ubR*(ugradf(dum, 0, ubY) + ugradf(ub, ik, dumY)) + dumR*ugradf(ub, 0, ubY) + (ubR*dumY + dumR*ubY + ubR*ubY*dumT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.))*Daexp(ub)) + (ubT^(params["a"])*diff(-ik, vY, ik, dumY) + params["a"]*ubT^(params["a"]-1.)*dumT*diff(-ik, vY, 0, ubY))/(params["Re"]*params["Pr"]*params["Le"])
        + vR*(ugradf(ub, ik, dumR) + ugradf(dum, 0, ubR) + dumR*div(0, ub) + ubR*div(ik, dum))
        + ubR*(ugradu(v, dum, 0, ub) + ugradu(v, ub, ik, dum)) + dumR*ugradu(v, ub, 0, ub) - 1.0/(params["gamma"]*params["Ma"]^2)*div(-ik, v)*(dumR*ubT + ubR*dumT) + (ubT^(params["a"])*visc(-ik, v , ik, dum ) + params["a"]*ubT^(params["a"]-1.)*dumT*visc(-ik, v , 0, ub ))/params["Re"]
        + vT*(ubR*(ugradf(dum, 0, ubT) + ugradf(ub, ik, dumT)) + dumR*ugradf(ub, 0, ubT) - params["gamma"]*params["dT"]*(ubR*dumY + dumR*ubY + ubR*ubY*dumT*params["Ze"]*(1.0 + params["dT"])^2/(params["dT"]*ubT^2.))*Daexp(ub) + (params["gamma"] - 1.0)*(dumR*ubT*div(0, ub) + ubR*dumT*div(0, ub) + ubR*ubT*div(ik, dum)))
        + params["gamma"]/(params["Re"]*params["Pr"])*(ubT^(params["a"])*diff(-ik, vT, ik, dumT) + params["a"]*ubT^(params["a"]-1.)*dumT*diff(-ik, vT, 0, ubT))
        - vT*params["gamma"]*(params["gamma"] - 1.0)*params["Ma"]^2./params["Re"]*(ubT^(params["a"])*(visc(ik, dum, 0, ub) + visc(0, ub, ik, dum)) + params["a"]*ubT^(params["a"]-1.)*dumT*visc(0, ub, 0, ub))
      )
      - int1d(Th, BCopen) (
        (ubT^(params["a"])*ndotvisc(v, ik, dum) + params["a"]*ubT^(params["a"]-1.)*dumT*ndotvisc(v, 0, ub))/params["Re"]
      )
      + int2d(Th)(
        iomega*(gdotf(vR, umR) + ubR*(gdotf(vY, umY) + gdotf(vT, umT) + vdotu(v, um)))
        + vY*(ubR*(ugradf(um, 0, ubY) + ugradf(ub, ik, umY)) + umR*ugradf(ub, 0, ubY) + (ubR*umY + umR*ubY + ubR*ubY*umT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.))*Daexp(ub)) + (ubT^(params["a"])*diff(-ik, vY, ik, umY) + params["a"]*ubT^(params["a"]-1.)*umT*diff(-ik, vY, 0, ubY))/(params["Re"]*params["Pr"]*params["Le"])
        + vR*(ugradf(ub, ik, umR) + ugradf(um, 0, ubR) + umR*div(0, ub) + ubR*div(ik, um))
        + ubR*(ugradu(v, um, 0, ub) + ugradu(v, ub, ik, um)) + umR*ugradu(v, ub, 0, ub) - 1.0/(params["gamma"]*params["Ma"]^2)*div(-ik, v)*(umR*ubT + ubR*umT) + (ubT^(params["a"])*visc(-ik, v , ik, um ) + params["a"]*ubT^(params["a"]-1.)*umT*visc(-ik, v , 0, ub ))/params["Re"]
        + vT*(ubR*(ugradf(um, 0, ubT) + ugradf(ub, ik, umT)) + umR*ugradf(ub, 0, ubT) - params["gamma"]*params["dT"]*(ubR*umY + umR*ubY + ubR*ubY*umT*params["Ze"]*(1.0 + params["dT"])^2/(params["dT"]*ubT^2.))*Daexp(ub) + (params["gamma"] - 1.0)*(umR*ubT*div(0, ub) + ubR*umT*div(0, ub) + ubR*ubT*div(ik, um)))
        + params["gamma"]/(params["Re"]*params["Pr"])*(ubT^(params["a"])*diff(-ik, vT, ik, umT) + params["a"]*ubT^(params["a"]-1.)*umT*diff(-ik, vT, 0, ubT))
        - vT*params["gamma"]*(params["gamma"] - 1.0)*params["Ma"]^2./params["Re"]*(ubT^(params["a"])*(visc(ik, um, 0, ub) + visc(0, ub, ik, um)) + params["a"]*ubT^(params["a"]-1.)*umT*visc(0, ub, 0, ub))
      )
      - int1d(Th, BCopen) (
        (ubT^(params["a"])*ndotvisc(v, ik, um) + params["a"]*ubT^(params["a"]-1.)*umT*ndotvisc(v, 0, ub))/params["Re"]
      )
      + HomBoundaryConditions(sym, dum);

// MASS OPERATOR
varf vM(defu(dum), defu(v))
      = int2d(Th)(
        gdotf(vR, dumR) + ubR*(gdotf(vY, dumY) + gdotf(vT, dumT) + vdotu(v, dum))
      )
      + int2d(Th)(
          gdotf(vR, umR) + ubR*(gdotf(vY, umY) + gdotf(vT, umT) + vdotu(v, um))
      )
      + HomBoundaryConditions(sym, dum);

// FORCING/RESPONSE WEIGHTING MATRICES (FOR RESOLVENT ANALYSIS)
varf vMq(defu(dum), defu(v))
      = int2d(Th)( gdotf(vR, umR) + ubR*(gdotf(vY, umY) + gdotf(vT, umT) + vdotu(v, um)) );

varf vMf(deff(dum), deff(v))
      = int2d(Th)( vdotu(v, dum) );

varf vP(deff(fm), defu(v))
      = int2d(Th)( vdotu(v, fm) );

// HESSIAN OPERATOR
varf vH(defu(dum), defu(v))
      = int2d(Th)(
        iomega*um2R*(gdotf(vY, umY) + gdotf(vT, umT) + vdotu(v, um)) + iomega2*umR*(gdotf(vY, um2Y) + gdotf(vT, um2T) + vdotu(v, um2))
        + vY*(um2R*(ugradf(um, 0, ubY) + ugradf(ub, ik, umY)) + ubR*(ugradf(um, ik2, um2Y) + ugradf(um2, ik, umY)) + umR*(ugradf(um2, 0, ubY) + ugradf(ub, ik2, um2Y))
        + (um2R*umY + umR*um2Y + (um2R*ubY + ubR*um2Y)*umT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.) - 2.*um2T*ubR*ubY*umT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^3.) + (ubR*umY + umR*ubY + ubR*ubY*umT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.))*um2T*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.))*Daexp(ub))
        + params["a"]*ubT^(params["a"]-1.)*(um2T*diff(-ik-ik2, vY, ik, umY) + (params["a"]-1.)*um2T/ubT*umT*diff(-ik-ik2, vY, 0, ubY) + umT*diff(-ik-ik2, vY, ik2, um2Y))/(params["Re"]*params["Pr"]*params["Le"])
        + vR*(ugradf(um2, ik, umR) + ugradf(um, ik2, um2R) + umR*div(ik2, um2) + um2R*div(ik, um))
        + um2R*(ugradu(v, um, 0, ub) + ugradu(v, ub, ik, um)) + ubR*(ugradu(v, um, ik2, um2) + ugradu(v, um2, ik, um)) + umR*(ugradu(v, um2, 0, ub) + ugradu(v, ub, ik2, um2)) - 1.0/(params["gamma"]*params["Ma"]^2)*div(-ik-ik2, v)*(umR*um2T + um2R*umT)
        + params["a"]*ubT^(params["a"]-1.)*(um2T*visc(-ik-ik2, v , ik, um ) + (params["a"]-1.)*um2T/ubT*umT*visc(-ik-ik2, v , 0, ub ) + umT*visc(-ik-ik2, v , ik2, um2 ))/params["Re"]
        + vT*(um2R*(ugradf(um, 0, ubT) + ugradf(ub, ik, umT)) + ubR*(ugradf(um, ik2, um2T) + ugradf(um2, ik, umT)) + umR*(ugradf(um2, 0, ubT) + ugradf(ub, ik2, um2T))
        - params["gamma"]*params["dT"]*(um2R*umY + umR*um2Y + (um2R*ubY + ubR*um2Y)*umT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.) - 2.*um2T*ubR*ubY*umT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^3.) + (ubR*umY + umR*ubY + ubR*ubY*umT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.))*um2T*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.))*Daexp(ub)
        + (params["gamma"] - 1.0)*(umR*(um2T*div(0, ub) + ubT*div(ik2, um2)) + umT*(um2R*div(0, ub) + ubR*div(ik2, um2)) + (um2R*ubT + ubR*um2T)*div(ik, um)))
        + params["gamma"]*params["a"]*ubT^(params["a"]-1.)*(um2T*diff(-ik-ik2, vT, ik, umT) + (params["a"]-1.)*um2T/ubT*umT*diff(-ik-ik2, vT, 0, ubT) + umT*diff(-ik-ik2, vT, ik2, um2T))/(params["Re"]*params["Pr"])
        - vT*params["gamma"]*(params["gamma"] - 1.0)*params["Ma"]^2./params["Re"]*(params["a"]*ubT^(params["a"]-1.)*(um2T*(visc(ik, um, 0, ub) + visc(0, ub, ik, um)) + umT*(visc(ik2, um2, 0, ub) + visc(0, ub, ik2, um2) + (params["a"]-1.)*um2T/ubT*visc(0, ub, 0, ub))) + ubT^(params["a"])*(visc(ik, um, ik2, um2) + visc(ik2, um2, ik, um)))
      )
      - int1d(Th, BCopen) (
        params["a"]*ubT^(params["a"]-1.)*(um2T*ndotvisc(v, ik, um) + umT*ndotvisc(v, ik2, um2) + (params["a"]-1.)*um2T/ubT*umT*ndotvisc(v, 0, ub))/params["Re"]
      )
      + int2d(Th)(
        iomega*dumR*(gdotf(vY, umY) + gdotf(vT, umT) + vdotu(v, um)) + iomega2*umR*(gdotf(vY, dumY) + gdotf(vT, dumT) + vdotu(v, dum))
        + vY*(dumR*(ugradf(um, 0, ubY) + ugradf(ub, ik, umY)) + ubR*(ugradf(um, ik2, dumY) + ugradf(dum, ik, umY)) + umR*(ugradf(dum, 0, ubY) + ugradf(ub, ik2, dumY))
        + (dumR*umY + umR*dumY + (dumR*ubY + ubR*dumY)*umT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.) - 2.*dumT*ubR*ubY*umT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^3.) + (ubR*umY + umR*ubY + ubR*ubY*umT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.))*dumT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.))*Daexp(ub))
        + params["a"]*ubT^(params["a"]-1.)*(dumT*diff(-ik-ik2, vY, ik, umY) + (params["a"]-1.)*dumT/ubT*umT*diff(-ik-ik2, vY, 0, ubY) + umT*diff(-ik-ik2, vY, ik2, dumY))/(params["Re"]*params["Pr"]*params["Le"])
        + vR*(ugradf(dum, ik, umR) + ugradf(um, ik2, dumR) + umR*div(ik2, dum) + dumR*div(ik, um))
        + dumR*(ugradu(v, um, 0, ub) + ugradu(v, ub, ik, um)) + ubR*(ugradu(v, um, ik2, dum) + ugradu(v, dum, ik, um)) + umR*(ugradu(v, dum, 0, ub) + ugradu(v, ub, ik2, dum)) - 1.0/(params["gamma"]*params["Ma"]^2)*div(-ik-ik2, v)*(umR*dumT + dumR*umT)
        + params["a"]*ubT^(params["a"]-1.)*(dumT*visc(-ik-ik2, v , ik, um ) + (params["a"]-1.)*dumT/ubT*umT*visc(-ik-ik2, v , 0, ub ) + umT*visc(-ik-ik2, v , ik2, dum ))/params["Re"]
        + vT*(dumR*(ugradf(um, 0, ubT) + ugradf(ub, ik, umT)) + ubR*(ugradf(um, ik2, dumT) + ugradf(dum, ik, umT)) + umR*(ugradf(dum, 0, ubT) + ugradf(ub, ik2, dumT))
        - params["gamma"]*params["dT"]*(dumR*umY + umR*dumY + (dumR*ubY + ubR*dumY)*umT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.) - 2.*dumT*ubR*ubY*umT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^3.) + (ubR*umY + umR*ubY + ubR*ubY*umT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.))*dumT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.))*Daexp(ub)
        + (params["gamma"] - 1.0)*(umR*(dumT*div(0, ub) + ubT*div(ik2, dum)) + umT*(dumR*div(0, ub) + ubR*div(ik2, dum)) + (dumR*ubT + ubR*dumT)*div(ik, um)))
        + params["gamma"]*params["a"]*ubT^(params["a"]-1.)*(dumT*diff(-ik-ik2, vT, ik, umT) + (params["a"]-1.)*dumT/ubT*umT*diff(-ik-ik2, vT, 0, ubT) + umT*diff(-ik-ik2, vT, ik2, dumT))/(params["Re"]*params["Pr"])
        - vT*params["gamma"]*(params["gamma"] - 1.0)*params["Ma"]^2./params["Re"]*(params["a"]*ubT^(params["a"]-1.)*(dumT*(visc(ik, um, 0, ub) + visc(0, ub, ik, um)) + umT*(visc(ik2, dum, 0, ub) + visc(0, ub, ik2, dum) + (params["a"]-1.)*dumT/ubT*visc(0, ub, 0, ub))) + ubT^(params["a"])*(visc(ik, um, ik2, dum) + visc(ik2, dum, ik, um)))
      )
      - int1d(Th, BCopen) (
        params["a"]*ubT^(params["a"]-1.)*(dumT*ndotvisc(v, ik, um) + umT*ndotvisc(v, ik2, dum) + (params["a"]-1.)*dumT/ubT*umT*ndotvisc(v, 0, ub))/params["Re"]
      )
      + HomBoundaryConditions(sym, dum);

// TRESSIAN OPERATOR (FOR WEAKLY NONLINEAR ANALYSIS)
varf vT(defu(dum), defu(v))
      = /*int2d(Th)(
        vY*(um2R*(ugradf(um, ik3, dumY) + ugradf(dum, ik, umY)) + dumR*(ugradf(um, ik2, um2Y) + ugradf(um2, ik, umY)) + umR*(ugradf(um2, ik3, dumY) + ugradf(dum, ik2, um2Y))
          + (params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.)*(dumT*(um2R*umY + umR*um2Y) + umT*((um2R*dumY + dumR*um2Y) - 2.*dumT*(um2R*ubY + ubR*um2Y)/ubT + params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.)*dumT*(um2R*ubY + ubR*um2Y)))
            - 2.*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.)*(um2T*umT*(dumR*ubY + ubR*dumY)/ubT - 3.*dumT*um2T*umT*ubR*ubY/(ubT^2.) + params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.)*dumT*um2T*umT*ubR*ubY/ubT)
            + um2T*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.)*(((dumR*umY + umR*dumY) - 2.*dumT*(ubR*umY + umR*ubY)/ubT + dumT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.)*(ubR*umY + umR*ubY)) + params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.)*(dumR*ubY*umT*um2T + ubR*dumY*umT*um2T - 4.*dumT*ubR*ubY*umT*um2T/ubT + params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.)*dumT*ubR*ubY*umT*um2T))
          )*Daexp(ub)
        )
        + params["a"]*(params["a"]-1.)*ubT^(params["a"]-2.)*(dumT*(um2T*diff(-ik-ik2-ik3, vY, ik, umY) + umT*diff(-ik-ik2-ik3, vY, ik2, um2Y)) + um2T*umT*diff(-ik-ik2-ik3, vY, ik3, dumY) + (params["a"]-2.)*dumT/ubT*um2T*umT*diff(-ik-ik2-ik3, vY, 0, ubY))/(params["Re"]*params["Pr"]*params["Le"])
        + um2R*(ugradu(v, um, ik3, dum) + ugradu(v, dum, ik, um)) + dumR*(ugradu(v, um, ik2, um2) + ugradu(v, um2, ik, um)) + umR*(ugradu(v, um2, ik3, dum) + ugradu(v, dum, ik2, um2))
        + params["a"]*(params["a"]-1.)*ubT^(params["a"]-2.)*(um2T*visc(-ik-ik2-ik3, v , ik, um ) + umT*visc(-ik-ik2-ik3, v , ik2, um2 ) + um2T*umT*visc(-ik-ik2-ik3, v , ik3, dum ) + (params["a"]-2.)*dumT/ubT*um2T*umT*visc(-ik-ik2-ik3, v, 0, ub ))/params["Re"]
        + vT*(um2R*(ugradf(um, ik3, dumT) + ugradf(dum, ik, umT)) + dumR*(ugradf(um, ik2, um2T) + ugradf(um2, ik, umT)) + umR*(ugradf(um2, ik3, dumT) + ugradf(dum, ik2, um2T))
          - params["gamma"]*params["dT"]*(params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.)*(dumT*(um2R*umY + umR*um2Y) + umT*((um2R*dumY + dumR*um2Y) - 2.*dumT*(um2R*ubY + ubR*um2Y)/ubT + params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.)*dumT*(um2R*ubY + ubR*um2Y)))
            - 2.*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.)*(um2T*umT*(dumR*ubY + ubR*dumY)/ubT - 3.*dumT*um2T*umT*ubR*ubY/(ubT^2.) + params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.)*dumT*um2T*umT*ubR*ubY/ubT)
            + um2T*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.)*(((dumR*umY + umR*dumY) - 2.*dumT*(ubR*umY + umR*ubY)/ubT + dumT*params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.)*(ubR*umY + umR*ubY)) + params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.)*(dumR*ubY*umT*um2T + ubR*dumY*umT*um2T - 4.*dumT*ubR*ubY*umT*um2T/ubT + params["Ze"]*(1.0 + params["dT"])^2./(params["dT"]*ubT^2.)*dumT*ubR*ubY*umT*um2T))
          )*Daexp(ub)
          + (params["gamma"] - 1.0)*(umR*(um2T*div(ik3, dum) + dumT*div(ik2, um2)) + umT*(um2R*div(ik3, dum) + dumR*div(ik2, um2)) + (um2R*dumT + dumR*um2T)*div(ik, um))
        )
        + params["gamma"]*params["a"]*(params["a"]-1.)*ubT^(params["a"]-2.)*(dumT*(um2T*diff(-ik-ik2-ik3, vT, ik, umT) + umT*diff(-ik-ik2-ik3, vT, ik2, um2T)) + um2T*umT*diff(-ik-ik2-ik3, vT, ik3, dumT) + (params["a"]-2.)*dumT/ubT*um2T*umT*diff(-ik-ik2-ik3, vT, 0, ubT))/(params["Re"]*params["Pr"])
        - vT*params["gamma"]*(params["gamma"] - 1.0)*params["Ma"]^2./params["Re"]*(
          params["a"]*ubT^(params["a"]-1.)*(um2T*(visc(ik, um, ik3, dum) + visc(ik3, dum, ik, um)) + umT*(visc(ik2, um2, ik3, dum) + visc(ik3, dum, ik2, um2)) + dumT*(visc(ik, um, ik2, um2) + visc(ik2, um2, ik, um)))
          + params["a"]*(params["a"]-1.)*ubT^(params["a"]-2.)*(dumT*(um2T*(visc(ik, um, 0, ub) + visc(0, ub, ik, um)) + umT*(visc(ik2, um2, 0, ub) + visc(0, ub, ik2, um2))) + umT*um2T*((params["a"]-2.)*dumT/ubT*visc(0, ub, 0, ub) + visc(ik3, dum, 0, ub) + visc(0, ub, ik3, dum)))
          )
      )
      - int1d(Th, BCopen) (
        params["a"]*(params["a"]-1.)*ubT^(params["a"]-2.)*(dumT*um2T*ndotvisc(v, ik, um) + dumT*umT*ndotvisc(v, ik2, um2) + um2T*umT*ndotvisc(v, ik3, dum) + (params["a"]-2.)*dumT/ubT*um2T*umT*ndotvisc(v, 0, ub))/params["Re"]
      )
      + */HomBoundaryConditions(sym, dum);
