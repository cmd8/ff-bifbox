//
// resolventcompute.edp
// Chris Douglas
// chris.douglas@ladhyx.polytechnique.fr
//
// NOTE: This file should not be changed unless you know what you're doing.
//
load "iovtk"
load "PETSc-complex"
include "solversettings.idp"
include "solvermacros.idp"
// arguments
string meshfilein = getARGV("-mshi", ""); // input meshfile
string basefilein = getARGV("-bfi", "");
string foldfilein = getARGV("-ffi", "");
string hopffilein = getARGV("-hfi", "");
string gainfileout = getARGV("-gfo", "");
string resolventfileout = getARGV("-rfo", "");
bool paraviewflag = getARGV("-pvo", 0); // toggle whether solution is also saved in Paraview format
int meshsplit = getARGV("-split", 1); // toggle whether mesh is split for P1 representation in Paraview
int m = getARGV("-m", 0);
real omega = getARGV("-omega", 1.0);
int nomega = getARGV("-nomega", 1);
real omegaf = getARGV("-omegaf", 1.0);
string ksptype = getARGV("-ksp_type", "preonly"); // set -ksp_method
string pctype = getARGV("-pc_type", "lu"); // set -pc_type
int epsnev = getARGV("-eps_nev", 1);
bool strictnev = getARGV("-strict", 1);

if(meshfilein == ""){
  if(basefilein != "") meshfilein = readmeshname(workdir + basefilein + ".base");
  else if(foldfilein != "") meshfilein = readmeshname(workdir + foldfilein + ".fold");
  else if(hopffilein != "") meshfilein = readmeshname(workdir + hopffilein + ".hopf");
}
// Load mesh, make FE basis
Th = readmeshN(workdir + meshfilein + meshext);
Thg = Th;
buildDmesh(Th);
restf = restrict(Xh, Xhg, n2o);
restu = restrict(XMh, XMhg, n2o);
XMh defu(ub);

if(foldfilein != "") {
  real[int] qm, qma;
  ub[] = loadfold(foldfilein, meshfilein, qm, qma);
  basefilein = foldfilein + ".fold";
} else if(hopffilein != "") {
  complex[int] qm, qma;
  int mtemp;
  real omegatemp;
  ub[] = loadhopf(hopffilein, meshfilein, qm, qma, mtemp, omegatemp);
  basefilein = hopffilein + ".hopf";
} else {
  ub[] = loadbase(basefilein, meshfilein);
  basefilein = basefilein + ".base";
}
complex[int] val(epsnev);
Xh<complex>[int] deff(fvec)(epsnev);
Xh<complex> deff(fm);
XMh<complex> defu(um);

Mat<complex> L, Mf;
createMatu(Th, L, Pk);
Mat<complex> M(L);
createMatf(Th, Mf, Pkf);
complex ik = 1i*real(m);
complex iomega;

IFMACRO(formulation,incomp)
include "eqns_incomp.idp"
ENDIFMACRO
IFMACRO(formulation,lowmach)
include "eqns_lowmach.idp"
ENDIFMACRO
IFMACRO(formulation,comp)
include "eqns_comp.idp"
ENDIFMACRO
IFMACRO(formulation,lowmachreact)
include "eqns_lowmachreact.idp"
ENDIFMACRO
IFMACRO(formulation,compreact)
include "eqns_compreact.idp"
ENDIFMACRO
IFMACRO(formulation,custom)
include "eqns_custom.idp"
ENDIFMACRO

// construct matrices
M  = vMq(XMh, XMh); // Response Norm
Mf = vMf(Xh, Xh); // Forcing Norm
matrix<complex> LocPQ = vP(Xh, XMh); // Forcing/Response Correspondence
Mat<complex> PQ(M, Mf, LocPQ);
set(L, sparams = " -ksp_type " + ksptype + " -pc_type " + pctype + " " + KSPparams);

func complex[int] LHSop(complex[int]& inPETSc) {
  complex[int] temp(XMh.ndof), outPETSc(inPETSc.n);
  MatMult(PQ, inPETSc, outPETSc);
  KSPSolve(L, outPETSc, temp);
  MatMult(M, temp, outPETSc);
  KSPSolveHermitianTranspose(L, outPETSc, temp);
  MatMultHermitianTranspose(PQ, temp, outPETSc);
  return outPETSc;
}

Mat<complex> LHS(Mf, LHSop);

real omegas = omega;
for (int n = 0; n < nomega; ++n){
  if (nomega > 1) {
    omega = omegas + (omegaf - omegas)*real(n)/real(nomega - 1);
  }
  iomega = 1i*omega;
  L  = vJ(XMh, XMh, tgv = -1); //Linear operator
  int k = EPSSolve(LHS, Mf, vectors = fvec, values = val,
                 sparams = " -eps_type krylovschur " +
                           " -eps_largest_real " +
                           " -eps_monitor_conv " +
                           " -eps_gen_hermitian ");
  if (strictnev) {// activate to limit number of eigenpairs
    val.resize(min(k, epsnev));
    fvec.resize(min(k, epsnev));
  }
  XMh<complex>[int] defu(uvec)(val.n);
  real[int] gains = sqrt(val.re);
  if(resolventfileout != ""){ //If saving modes, compute response modes
    for (int ii = 0; ii < val.n; ++ii){
      fm[] = fvec[ii][];
      complex[int] gm(Xh.ndof), qm(XMh.ndof), temp(XMh.ndof);
      ChangeNumbering(Mf, fm[], gm);
      ChangeNumbering(Mf, fm[], gm, inverse = true);
      fvec[ii][] = fm[];
      MatMult(PQ, gm, temp);
      KSPSolve(L, temp, qm);
      ChangeNumbering(L, um[], qm, inverse = true);
      uvec[ii][] = um[];
    }
  }
  saveresolvent(resolventfileout + "_" + n, gainfileout, basefilein, meshfilein, fvec, uvec, gains, m, omega, (resolventfileout != ""), paraviewflag);
}
