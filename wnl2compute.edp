//
// wnl2compute.edp
// Chris Douglas
// chris.douglas@ladhyx.polytechnique.fr
//
// This script computes the normal form at a Hopf point.
// The normal form is written for the complex amplitude Z = A*exp(1i*omega*t) as:
//    dZ/dt = Z*( alpha*(lambda - lambda0) + 1i*omega + beta*|Z|^2 )
// where:
//    alpha is the coefficient for the linear term from parameter changes,
//    beta is the coefficient for the cubic term from harmonic interactions.
// Using this convention, the bifurcation is supercritical for real(beta) < 0,
// and subcritical for real(beta) > 0.
//
// NOTE: This file should not be changed unless you know what you're doing.
//
load "iovtk"
load "PETSc-complex"
include "settings.idp"
include "macros_bifbox.idp"
// arguments
string meshin = getARGV("-mi", "");
string filein = getARGV("-fi", "");
string fileout = getARGV("-fo", "");
real eps = getARGV("-eps", 1e-7);
string ksptype = getARGV("-ksp_type", "preonly");
string pctype = getARGV("-pc_type", "lu");
int sym, mm;
real omega, lambda;

string fileroot, meshroot;
string fileext = parsefilename(filein, fileroot); //extract file name and extension
parsefilename(fileout, fileout); // trim extension from output file, if given
if(meshin == "") meshin = readmeshname(workdir + filein); // get mesh file
string meshext = parsefilename(meshin, meshroot);
assert(fileext == "hopf");
// Load mesh, make FE basis
Th = readmeshN(workdir + meshin);
Thg = Th;
buildDmesh(Th);
restu = restrict(XMh, XMhg, n2o);
XMh<complex> defu(ub), defu(um), defu(uma), defu(um2), defu(um3);
XMh<complex>[int] defu(q2param)(paramnames.n);
ub[].re = loadhopf(fileroot, meshin, um[], uma[], mm, omega);
// Create distributed Mat
Mat<complex> J;
createMatu(Th, J, Pk);
complex ik, ik2, ik3, iomega, iomega2, iomega3;
include "eqns.idp"
set(J, sparams = " -ksp_type " + ksptype + " -pc_type " + pctype + " " + KSPparams);

// Initialize
{
  complex[int] Mq = vM(0, XMh, tgv = -10);
  complex Mnorm = sqrt(J(um[], Mq));
  um[] /= Mnorm; // so that <um[],M*um[]> = 1
  uma[] *= conj(Mnorm/J(uma[], Mq)); // so that <uma[],M*um[]> = 1
}
complex[int] qAAs(J.n), qAA(J.n), tempP(J.n), temp(um[].n), temp1(um[].n);
complex[int,int] qDa(paramnames.n, J.n);
// 2nd-order
//  A: base modification due to parameter changes
ik = 0.0;
ik2 = 0.0;
iomega = 0.0;
iomega2 = 0.0;
sym = 0;
J = vJ(XMh, XMh, tgv = -1);
if(paramnames[0] != ""){
  for (int k = 0; k < paramnames.n; ++k){
    lambda = getlambda(paramnames[k]);
    updatelambda(paramnames[k], lambda + eps);
    temp = vR(0, XMh, tgv = -1);
    updatelambda(paramnames[k], lambda);
    temp1 = vR(0, XMh, tgv = -1);
    temp -= temp1;
    temp /= -eps;
    ChangeNumbering(J, temp, tempP); // FreeFEM to PETSc
    KSPSolve(J, tempP, qAAs);
    qDa(k, :) = qAAs;
  }
}
//  B: base modification due to quadratic nonlinear interaction
ik = 1i*real(mm);
ik2 = -ik;
iomega = 1i*omega;
iomega2 = -iomega;
um2[] = conj(um[]);
temp = vH(0, XMh, tgv = -10);
temp.re *= -1.0; // -2.0/2.0
temp.im = 0.0;
ChangeNumbering(J, temp, tempP); // FreeFEM to PETSc
KSPSolve(J, tempP, qAAs);
//  C: harmonic generation due to quadratic nonlinear interaction
ik = 1i*real(mm);
ik2 = ik;
iomega = 1i*omega;
iomega2 = iomega;
um2[] = um[];
sym = 2*mm;
temp = vH(0, XMh, tgv = -10);
temp *= -0.5; // -1.0/2.0
ChangeNumbering(J, temp, tempP); // FreeFEM to PETSc
ik = 2i*real(mm);
iomega = 2i*omega;
J = vJ(XMh, XMh, tgv = -1);
KSPSolve(J, tempP, qAA);
// 3rd-order
//  A: fundamental modification due to parameter change and quadratic interaction of fundamental with 2nd order modification A.
sym = mm;
ik = 1i*real(sym);
ik2 = 0.0;
iomega = 1i*omega;
iomega2 = 0.0;
complex[string] alpha;
if(paramnames[0] != ""){
  for (int k = 0; k < paramnames.n; ++k){
    lambda = getlambda(paramnames[k]);
    updatelambda(paramnames[k], lambda + eps);
    temp = vJ(0, XMh, tgv = -10);
    updatelambda(paramnames[k], lambda);
    temp1 = vJ(0, XMh, tgv = -10);
    temp -= temp1;
    temp /= eps;
    ChangeNumbering(J, um2[], qDa(k, :), inverse = true, exchange = true); // FreeFEM to PETSc
    temp += vH(0, XMh, tgv = -10); // 2.0/2.0
    alpha[paramnames[k]] = -J(uma[], temp);
  }
}
//  B: fundamental modification due to cubic self-interaction of fundamental
ik = 1i*real(sym);
ik2 = 1i*real(sym);
ik3 = -1i*real(sym);
iomega = 1i*omega;
iomega2 = 1i*omega;
iomega3 = -1i*omega;
um2[] = um[];
um3[] = conj(um[]);
temp = vT(0, XMh, tgv = -10);
temp *= 0.5; //3.0/6.0
//  C: fundamental modification due to quadratic interaction of fundamental with 2nd order modification B
ik = 1i*real(sym);
ik2 = 0.0;
iomega = 1i*omega;
iomega2 = 0.0;
ChangeNumbering(J, um2[], qAAs, inverse = true, exchange = true); // FreeFEM to PETSc
temp += vH(0, XMh, tgv = -10);
//  D: fundamental modification due to quadratic interaction of fundamental with 2nd order modification C
ik = -1i*real(sym);
ik2 = 2i*real(sym);
iomega = -1i*omega;
iomega2 = 2i*omega;
um[] = conj(um[]);
ChangeNumbering(J, um2[], qAA, inverse = true, exchange = true); // FreeFEM to PETSc
temp += vH(0, XMh, tgv = -10);
complex beta = -J(uma[], temp);
// Save output
if(paramnames[0] != ""){
  for (int k = 0; k < paramnames.n; ++k){
    ChangeNumbering(J, q2param[k][], qDa(k, :), inverse = true); // FreeFEM to PETSc
  }
}
ChangeNumbering(J, um2[], qAAs, inverse = true); // FreeFEM to PETSc
ChangeNumbering(J, um3[], qAA, inverse = true); // FreeFEM to PETSc
savewnl2(fileout, filein, meshin, q2param, mm, omega, alpha, beta, true);
