//
// solvermacros.idp
// Chris Douglas
// chris.douglas@ladhyx.polytechnique.fr
//
// NOTE: This file should not be changed unless you know what you're doing.
//

cout.precision(12);
string workdir = getARGV("-dir","./data/"); // set working directory
// Define local/global mesh variables
meshN Th; // local mesh
meshN Thg; // global mesh
fespace XMh(Th, Pk); // local FEspace
fespace XMhg(Thg, Pk); // global FEspace
IFMACRO(dimension,2)
macro meshext()".msh"//EOM
ENDIFMACRO

// Initialize parallel local/global numbering arrays
int[int] n2o, restu, restf;
macro ThN2O()n2o// EOM

// Initialize parameter/monitor arrays
real[string] params, monitors;

// Set parameter values
func int setparams(string[int] & paramnames, real[string] & params){
  for (int k = 0; k < paramnames.n; ++k){
    params[paramnames[k]] = getARGV("-"+ paramnames[k], params[paramnames[k]]);
  }
  return 0;
}
// Get parameter values
func string listparams(string[int] & paramnames, real[string] & params){
  string stringout;
  for (int k = 0; k < paramnames.n; ++k){
    if (k==0) stringout = paramnames[k] + " = " + params[paramnames[k]];
    else stringout = stringout + ", " + paramnames[k] + " = " + params[paramnames[k]];
  }
  return stringout;
}
// EOM
macro createMatu(th,A,P){
    NewMacro def(u)defu(u) EndMacro
    NewMacro init(i)initu(i) EndMacro
    createMat(th,A,P)
} // EOM

// FUNCTIONS -------------------------------------------------------------------
macro savebase(workdir, basefileout, statsfile, meshfile, saveflag, monitorflag, paraviewflag){
  XMhg defu(tempu), defu(ubg);
  for[i, v : restu] tempu[][v] = ub[][i];
  mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
  if (monitorflag) getmonitors(ubg);
  if (mpirank == 0 && statsfile != "") printstats(workdir + statsfile + ".txt", meshfile, 0, 0);
  if (saveflag && mpirank == 0 && basefileout != ""){
    cout << "  Saving '" + basefileout + ".base' on '" + meshfile + meshext + "' in '" + workdir + "'." << endl;
    cout << "\t" + listparams(paramnames,params)  + ", " + listparams(monitornames, monitors) + "." << endl;
    {
      ofstream file(workdir + basefileout + ".base", binary);
      file.precision(17);
      file << "mesh\t" << meshfile << endl << endl;
      for (int k = 0; k < paramnames.n; ++k){
        file << paramnames[k] << "\t" << params[paramnames[k]] << endl << endl;
      }
      for (int k = 0; k < monitornames.n; ++k){
        file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl << endl;
      }
      file << ubg[] << endl;
    }
    if (paraviewflag){
      cout << "  Saving '" + basefileout + "_base.vtu' in '" + workdir + "'." << endl;
      if (meshsplit != 1){
        meshN Thgs = trunc(Thg, 1, split = meshsplit);
        fespace XMhs(Thgs, Pk);
        XMhs defu(us) = defu(ubg);
        savevtk(workdir + basefileout + "_base.vtu", Thgs, adaptu(us), dataname = ParaviewDataName, order = ParaviewOrder);
      } else {
        savevtk(workdir + basefileout + "_base.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro savemode(workdir, modefileout, basefile, meshfile, m, eigenvalue, paraviewflag){
  XMhg<complex> defu(tempu), defu(umg);
  for[i, v : restu] tempu[][v] = um[][i];
  mpiAllReduce(tempu[], umg[], mpiCommWorld, mpiSUM);
  if (mpirank == 0 && modefileout != ""){
    cout << "  Saving '" + modefileout + ".mode' over '" + basefile + ".base' on '" + meshfile + meshext + "' in '" + workdir + "'." << endl;
    cout << "\t" + listparams(paramnames,params) + ", m = " + m + ", eval = " + eigenvalue + "."  << endl;
    {
      ofstream file(workdir + modefileout + ".mode", binary);
      file.precision(17);
      file << "mesh\t" << meshfile << endl << endl;
      file << "base\t" << basefile << endl << endl;
      for (int k = 0; k < paramnames.n; ++k){
        file << paramnames[k] << "\t" << params[paramnames[k]] << endl << endl;
      }
    file << "m\t" << m << endl << endl;
    file << "eval\t" << eigenvalue << endl << endl;
    file << umg[] << endl;
    }
    if (paraviewflag){
      cout << "  Saving '" + modefileout + "_mode_[real,imag].vtu' in '" + workdir + "'." << endl;
      if (meshsplit != 1){
        meshN Thgs = trunc(Thg, 1, split = meshsplit);
        fespace XMhs(Thgs, Pk);
        XMhs<complex> defu(uso) = defu(umg);
        XMhs defu(usr);
        usr[] = uso[].re;
        savevtk(workdir + modefileout + "_mode_real.vtu", Thgs, adaptu(usr), dataname = ParaviewDataName, order = ParaviewOrder);
        usr[] = uso[].im;
        savevtk(workdir + modefileout + "_mode_imag.vtu", Thgs, adaptu(usr), dataname = ParaviewDataName, order = ParaviewOrder);
      } else {
        XMhg defu(usr);
        usr[] = umg[].re;
        savevtk(workdir + modefileout + "_mode_real.vtu", Thg, adaptu(usr), dataname = ParaviewDataName, order = ParaviewOrder);
        usr[] = umg[].im;
        savevtk(workdir + modefileout + "_mode_imag.vtu", Thg, adaptu(usr), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro savefold(workdir, foldfileout, statsfile, meshfile, saveflag, monitorflag, paraviewflag){
  XMhg defu(tempu), defu(ubg), defu(umg), defu(umag);
  for[i, v : restu] tempu[][v] = ub[][i];
  mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
  for[i, v : restu] tempu[][v] = um[][i];
  mpiAllReduce(tempu[], umg[], mpiCommWorld, mpiSUM);
  for[i, v : restu] tempu[][v] = uma[][i];
  mpiAllReduce(tempu[], umag[], mpiCommWorld, mpiSUM);
  if (monitorflag) getmonitors(ubg);
  if (mpirank == 0 && statsfile != "") printstats(workdir + statsfile + ".txt", meshfile, 0, 0);
  if (saveflag && mpirank == 0 && foldfileout != ""){
    cout << "  Saving '" + foldfileout + ".fold' on '" + meshfile + meshext + "' in '" + workdir + "'." << endl;
    cout << "\t" + listparams(paramnames,params)  + ", " + listparams(monitornames, monitors) + "." << endl;
    {
      ofstream file(workdir + foldfileout + ".fold", binary);
      file.precision(17);
      file << "mesh\t" << meshfile << endl << endl;
      for (int k = 0; k < paramnames.n; ++k){
        file << paramnames[k] << "\t" << params[paramnames[k]] << endl << endl;
      }
      for (int k = 0; k < monitornames.n; ++k){
        file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl << endl;
      }
      file << ubg[] << endl << endl;
      file << umg[] << endl << endl;
      file << umag[] << endl << endl;
    }
    if (paraviewflag){
      cout << "  Saving '" + foldfileout + "_fold_[base,dirmode,adjmode].vtu' in '" + workdir + "'." << endl;
      if (meshsplit != 1){
        meshN Thgs = trunc(Thg, 1, split = meshsplit);
        fespace XMhs(Thgs, Pk);
        XMhs defu(ubs) = defu(ubg);
        XMhs defu(ums) = defu(umg);
        XMhs defu(umas) = defu(umag);
        savevtk(workdir + foldfileout + "_fold_base.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
        savevtk(workdir + foldfileout + "_fold_dirmode.vtu", Thgs, adaptu(ums), dataname = ParaviewDataName, order = ParaviewOrder);
        savevtk(workdir + foldfileout + "_fold_adjmode.vtu", Thgs, adaptu(umas), dataname = ParaviewDataName, order = ParaviewOrder);
      } else {
        savevtk(workdir + foldfileout + "_fold_base.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
        savevtk(workdir + foldfileout + "_fold_dirmode.vtu", Thg, adaptu(umg), dataname = ParaviewDataName, order = ParaviewOrder);
        savevtk(workdir + foldfileout + "_fold_adjmode.vtu", Thg, adaptu(umag), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro savehopf(workdir, hopffileout, statsfile, meshfile, m, omega, saveflag, monitorflag, paraviewflag){
  XMhg defu(tempu), defu(ubg);
  XMhg<complex> defu(cplxu), defu(umg), defu(umag);
  for[i, v : restu] tempu[][v] = real(ub[][i]);
  mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
  for[i, v : restu] cplxu[][v] = um[][i];
  mpiAllReduce(cplxu[], umg[], mpiCommWorld, mpiSUM);
  for[i, v : restu] cplxu[][v] = uma[][i];
  mpiAllReduce(cplxu[], umag[], mpiCommWorld, mpiSUM);
  if (monitorflag) getmonitors(ubg);
  if (mpirank == 0 && statsfile != "") printstats(workdir + statsfile + ".txt", meshfile, m, omega);
  if (saveflag && mpirank == 0 && hopffileout != ""){
    cout << "  Saving '" + hopffileout + ".hopf' on '" + meshfile + meshext + "' in '" + workdir + "'." << endl;
    cout << "\t" + listparams(paramnames,params)  + ", m = " + m + ", omega = " + omega + ", " + listparams(monitornames, monitors) + "." << endl;
    {
      ofstream file(workdir + hopffileout + ".hopf", binary);
      file.precision(17);
      file << "mesh\t" << meshfile << endl << endl;
      for (int k = 0; k < paramnames.n; ++k){
        file << paramnames[k] << "\t" << params[paramnames[k]] << endl << endl;
      }
      file << "m\t" << m << endl << endl;
      file << "omega\t" << omega << endl << endl;
      for (int k = 0; k < monitornames.n; ++k){
        file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl << endl;
      }
      file << ubg[] << endl << endl;
      file << umg[] << endl << endl;
      file << umag[] << endl << endl;
    }
    if (paraviewflag){
      cout << "  Saving '" + hopffileout + "_hopf_[base,dirmode_real,dirmode_imag,adjmode_real,adjmode_imag].vtu' in '" + workdir + "'." << endl;
      if (meshsplit != 1){
        meshN Thgs = trunc(Thg, 1, split = meshsplit);
        fespace XMhs(Thgs, Pk);
        XMhs defu(ubs) = defu(ubg);
        XMhs<complex> defu(ums) = defu(umg);
        XMhs<complex> defu(umas) = defu(umag);
        savevtk(workdir + hopffileout + "_hopf_base.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
        ubs[] = ums[].re;
        savevtk(workdir + hopffileout + "_hopf_dirmode_real.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
        ubs[] = ums[].im;
        savevtk(workdir + hopffileout + "_hopf_dirmode_imag.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
        ubs[] = umas[].re;
        savevtk(workdir + hopffileout + "_hopf_adjmode_real.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
        ubs[] = umas[].im;
        savevtk(workdir + hopffileout + "_hopf_adjmode_imag.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
      } else {
        savevtk(workdir + hopffileout + "_hopf_base.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
        ubg[] = umg[].re;
        savevtk(workdir + hopffileout + "_hopf_dirmode_real.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
        ubg[] = umg[].im;
        savevtk(workdir + hopffileout + "_hopf_dirmode_imag.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
        ubg[] = umag[].re;
        savevtk(workdir + hopffileout + "_hopf_adjmode_real.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
        ubg[] = umag[].im;
        savevtk(workdir + hopffileout + "_hopf_adjmode_imag.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

func bool printstats(string outputfilename, string meshfilename, int m, real omega) {
      cout << "  Saving solution stats in '" + outputfilename + "'." << endl;
      cout << "\t" + listparams(paramnames, params) + ", " + listparams(monitornames, monitors) << endl;
      if (omega != 0.0 | m != 0) cout << ", m = " + m + ", omega = " + omega;
      cout << "." << endl;
      { ofstream file(outputfilename, append);
        file.precision(17);
        file << meshfilename << "\t";
        for (int k = 0; k < paramnames.n; ++k){
          file << params[paramnames[k]] << "\t";
        }
        for (int k = 0; k < monitornames.n; ++k){
          file << monitors[monitornames[k]] << "\t";
        }
        if (omega != 0.0 | m != 0) file << "\t" << m << "\t" << omega;
        file << endl;
      }
      return 0;
    }

func string readmeshname(string inputfilename) {
  string meshfilename;
  { ifstream file(inputfilename);
    file >> meshfilename >> meshfilename;
  }
  return meshfilename;
}

func string readbasename(string inputfilename) {
  string basefilename;
  { ifstream file(inputfilename);
    file >> basefilename >> basefilename >> basefilename >> basefilename;
  }
  return basefilename;
}
func complex readmodeeval(string inputfilename, int & m) {
  complex eigenvalue;
  string dummy;
  { ifstream file(inputfilename);
    for (int k = 0; k < (paramnames.n+2); ++k){
      file >> dummy >> dummy;
    }
    file >> dummy >> m;
    file >> dummy >> eigenvalue;
  }
  return eigenvalue;
}


func real[int] loadbase(string directoryname, string inputfilename, string meshfilename) {
      XMhg defu(ubg);
      if (inputfilename == ""){
        defu(ubg) = InitialConditions;
      } else {
        if (mpirank == 0) cout << "  Loading '" + inputfilename + ".base' on '" + meshfilename + meshext + "' from '" + directoryname + "'." << endl;
        string filemesh;
        ifstream file(directoryname + inputfilename + ".base");
        file >> filemesh >> filemesh;
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
        if (mpirank == 0) cout << "\t" + listparams(paramnames,params) + ", " + listparams(monitornames,monitors) << endl;
        if (filemesh == meshfilename){ // no interpolation needed
          file >> ubg[];
        } else { // must interpolate
          if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh + meshext << "'." << endl;
          meshN Thg1 = readmeshN(directoryname + filemesh + meshext);
          fespace XMhg1(Thg1, Pk);
          XMhg1 defu(ubg1);
          file >> ubg1[];
          defu(ubg) = defu(ubg1);
        }
      }
      setparams(paramnames,params);
      real[int] qlocal = ubg[](restu);
      return qlocal;
    }

func real[int] loadfold(string directoryname, string inputfilename, string meshfilename, real[int] & qmlocal, real[int] & qmalocal) {
      XMhg defu(ubg), defu(umg), defu(umag);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".fold' on '" + meshfilename + meshext + "' from '" + directoryname + "'." << endl;
      string filemesh;
      ifstream file(directoryname + inputfilename + ".fold");
      file >> filemesh >> filemesh;
      for (int k = 0; k < paramnames.n; ++k){
        file >> paramnames[k] >> params[paramnames[k]];
      }
      for (int k = 0; k < monitornames.n; ++k){
        file >> monitornames[k] >> monitors[monitornames[k]];
      }
      if (mpirank == 0) cout << "\t" + listparams(paramnames,params) + ", " + listparams(monitornames,monitors) << endl;
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        file >> umg[];
        file >> umag[];
      } else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh + meshext << "'." << endl;
        meshN Thg1 = readmeshN(directoryname + filemesh + meshext);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1), defu(umg1), defu(umag1);
        file >> ubg1[];
        file >> umg1[];
        file >> umag1[];
        defu(ubg) = defu(ubg1);
        defu(umg) = defu(umg1);
        defu(umag) = defu(umag1);
      }
      setparams(paramnames,params);
      real[int] qlocal = ubg[](restu);
      qmlocal = umg[](restu);
      qmalocal = umag[](restu);
      return qlocal;
    }

func real[int] loadhopf(string directoryname, string inputfilename, string meshfilename, complex[int] & qmlocal, complex[int] & qmalocal, int & m, real & omega) {
      XMhg defu(ubg);
      XMhg<complex> defu(umg), defu(umag);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".hopf' on '" + meshfilename + meshext + "' from '" + directoryname + "'." << endl;
      string dummy, filemesh;
      ifstream file(directoryname + inputfilename + ".hopf");
      file >> dummy >> filemesh;
      for (int k = 0; k < paramnames.n; ++k){
        file >> paramnames[k] >> params[paramnames[k]];
      }
      file >> dummy >> m >> dummy >> omega;
      for (int k = 0; k < monitornames.n; ++k){
        file >> monitornames[k] >> monitors[monitornames[k]];
      }
      if (mpirank == 0) cout << "\t" + listparams(paramnames,params) << ", m = " + m + ", omega = " + omega + ", " + listparams(monitornames,monitors) << endl;
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        file >> umg[];
        file >> umag[];
      } else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh + meshext << "'." << endl;
        meshN Thg1 = readmeshN(directoryname + filemesh + meshext);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1);
        XMhg1<complex> defu(umg1), defu(umag1);
        file >> ubg1[];
        file >> umg1[];
        file >> umag1[];
        defu(ubg) = defu(ubg1);
        defu(umg) = defu(umg1);
        defu(umag) = defu(umag1);
      }
      setparams(paramnames,params);
      real[int] qlocal = ubg[](restu);
      qmlocal = umg[](restu);
      qmalocal = umag[](restu);
      return qlocal;
    }

func complex[int] loadmode(string directoryname, string inputfilename, string meshfilename, int & m, complex & eigenvalue) {
      XMhg<complex> defu(umg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".mode' over '";
      string filemesh, basefilename, dummy;
      real[string] tempparams;
      ifstream file(directoryname + inputfilename + ".mode");
      file >> filemesh >> filemesh >> basefilename >> basefilename;
      if (mpirank == 0) cout << basefilename + ".base' on '" + meshfilename + meshext + "' from '" + directoryname + "'." << endl;
      for (int k = 0; k < paramnames.n; ++k){
        file >> paramnames[k] >> tempparams[paramnames[k]];
      }
      file >> dummy >> m >> dummy >> eigenvalue;
      if (mpirank == 0) cout << "\t" + listparams(paramnames,tempparams) << ", m = " + m + ", eval = " + eigenvalue + "." << endl;
      if (filemesh == meshfilename){ // no interpolation needed
        file >> umg[];
      } else { // must interpolate
      if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh + meshext << "'." << endl;
        meshN Thg1 = readmeshN(directoryname + filemesh + meshext);
        fespace XMhg1(Thg1, Pk);
        XMhg1<complex> defu(umg1);
        file >> umg1[];
        defu(umg) = defu(umg1);
      }
      complex[int] qlocal = umg[](restu);
      return qlocal;
    }

// parameter functions
  func real getlambda(string& contparam){
    real lambda;
    for (int k = 0; k < paramnames.n; ++k){
    if (contparam == paramnames[k]) lambda = params[paramnames[k]];
      }
    return lambda;
  }

  func int updatelambda(string& contparam, real lambda){
    for (int k = 0; k < paramnames.n; ++k){
      if (contparam == paramnames[k]) params[paramnames[k]] = lambda;
    }
    return 0;
  }
