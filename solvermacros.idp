//
// solvermacros.idp
// Chris Douglas
// chris.douglas@ladhyx.polytechnique.fr
//
// NOTE: This file should not be changed unless you know what you're doing.
//

cout.precision(8);
string workdir = getARGV("-dir","./data/"); // set working directory
// Define local/global mesh variables
meshN Th; // local mesh
meshN Thg; // global mesh
fespace XMh(Th, Pk); // local FEspace
fespace XMhg(Thg, Pk); // global FEspace
IFMACRO(dimension,2)
macro meshext()".msh"//EOM
ENDIFMACRO

// Initialize parallel local/global numbering arrays
int[int] n2o, restu, restf;
macro ThN2O()n2o// EOM

// Initialize parameter/monitor arrays
real[string] params, monitors;

// Set parameter values
func int setparams(string[int] & paramnames, real[string] & params){
  for (int k = 0; k < paramnames.n; ++k){
    params[paramnames[k]] = getARGV("-"+ paramnames[k], params[paramnames[k]]);
  }
  return 0;
}
// Get parameter values
func string listparams(string[int] & paramnames, real[string] & params){
  string stringout;
  for (int k = 0; k < paramnames.n; ++k){
    if (k==0) stringout = paramnames[k] + " = " + params[paramnames[k]];
    else stringout = stringout + ", " + paramnames[k] + " = " + params[paramnames[k]];
  }
  return stringout;
}
// EOM
macro createMatu(th,A,P){
    NewMacro def(u)defu(u) EndMacro
    NewMacro init(i)initu(i) EndMacro
    createMat(th,A,P)
} // EOM

macro createMatf(th,A,P){
    NewMacro def(u)deff(u) EndMacro
    NewMacro init(i)initf(i) EndMacro
    createMat(th,A,P)
} // EOM

// FUNCTIONS -------------------------------------------------------------------
macro savebase(workdir, basefileout, statsfile, meshfile, q, m, omega, saveflag, monitorflag, paraviewflag){
  XMhg defu(ubg), defu(ubo);
  ChangeNumbering(J, ub[], q, inverse = true);
  for[i, v : restu] ubg[][v] = ub[][i];
  mpiAllReduce(ubg[], ubo[], mpiCommWorld, mpiSUM);
  if (monitorflag) getmonitors(ubo);
  if (mpirank == 0 && statsfile != "") printstats(workdir + statsfile + ".txt", meshfile, m, omega);
  if (saveflag && mpirank == 0 && basefileout != ""){
    cout << "  Saving '" + basefileout + ".base' on '" + meshfile + meshext + "' in '" + workdir + "'." << endl;
    cout << "\t" + listparams(paramnames,params)  + ", " + listparams(monitornames, monitors) + "." << endl;
    { ofstream file(workdir + basefileout + ".base", binary);
      file.precision(17);
      file << "mesh\t" << meshfile << endl << endl;
      for (int k = 0; k < paramnames.n; ++k){
        file << paramnames[k] << "\t" << params[paramnames[k]] << endl << endl;
      }
      for (int k = 0; k < monitornames.n; ++k){
        file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl << endl;
      }
      file << ubo[] << endl;
    }
    if (paraviewflag){
      cout << "  Saving '" + basefileout + "_base.vtu' in '" + workdir + "'." << endl;
      if (meshsplit != 1){
        meshN Thgs = trunc(Thg, 1, split = meshsplit);
        fespace XMhs(Thgs, Pk);
        XMhs defu(us) = defu(ubo);
        savevtk(workdir + basefileout + "_base.vtu", Thgs, adaptu(us), dataname = ParaviewDataName, order = ParaviewOrder);
      } else {
        savevtk(workdir + basefileout + "_base.vtu", Thg, adaptu(ubo), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro savemode(FFrealcomplex, PETScrealcomplex, workdir, modefileout, basefile, meshfile, eigenmode, m, eigenvalue, paraviewflag){
  NewMacro FFtype()FFrealcomplex EndMacro
  XMhg<FFtype> defu(umg), defu(umo);
  IFMACRO(FFtype,real)
    ChangeNumbering(J, um[], eigenmode, inverse = true);
  ENDIFMACRO
  IFMACRO(FFtype,complex)
  NewMacro PETSctype()PETScrealcomplex EndMacro
  IFMACRO(PETSctype,real)
    ChangeNumbering([J, J], [um[].re, um[].im], eigenmode, inverse = true);
  ENDIFMACRO
  IFMACRO(PETSctype,complex)
    ChangeNumbering(J, um[], eigenmode, inverse = true);
  ENDIFMACRO
  ENDIFMACRO
  for[i, v : restu] umg[][v] = um[][i];
  mpiAllReduce(umg[], umo[], mpiCommWorld, mpiSUM);
  if (mpirank == 0 && modefileout != ""){
    cout << "  Saving '" + modefileout + ".mode' over '" + basefile + ".base' on '" + meshfile + meshext + "' in '" + workdir + "'." << endl;
    cout << "\t" + listparams(paramnames,params) + ", m = " + m + ", eval = " + eigenvalue + "."  << endl;
    { ofstream file(workdir + modefileout + ".mode", binary);
      file.precision(17);
      file << "mesh\t" << meshfile << endl << endl;
      file << "base\t" << basefile << endl << endl;
      for (int k = 0; k < paramnames.n; ++k){
        file << paramnames[k] << "\t" << params[paramnames[k]] << endl << endl;
      }
    file << "m\t" << m << endl << endl;
    file << "eval\t" << eigenvalue << endl << endl;
    file << umo[] << endl;
    }
    if (paraviewflag){
      cout << "  Saving '" + modefileout + "_mode_[real,imag].vtu' in '" + workdir + "'." << endl;
      IFMACRO(FFtype,complex)
      if (meshsplit != 1){
        meshN Thgs = trunc(Thg, 1, split = meshsplit);
        fespace XMhs(Thgs, Pk);
        XMhs<complex> defu(uso) = defu(umo);
        XMhs defu(usr);
        usr[] = uso[].re;
        savevtk(workdir + modefileout + "_mode_real.vtu", Thgs, adaptu(usr), dataname = ParaviewDataName, order = ParaviewOrder);
        usr[] = uso[].im;
        savevtk(workdir + modefileout + "_mode_imag.vtu", Thgs, adaptu(usr), dataname = ParaviewDataName, order = ParaviewOrder);
      } else {
        XMhg defu(usr);
        usr[] = umo[].re;
        savevtk(workdir + modefileout + "_mode_real.vtu", Thg, adaptu(usr), dataname = ParaviewDataName, order = ParaviewOrder);
        usr[] = umo[].im;
        savevtk(workdir + modefileout + "_mode_imag.vtu", Thg, adaptu(usr), dataname = ParaviewDataName, order = ParaviewOrder);
      }
      ENDIFMACRO
      IFMACRO(FFtype,real)
      if (meshsplit != 1){
        meshN Thgs = trunc(Thg, 1, split = meshsplit);
        fespace XMhs(Thgs, Pk);
        XMhs defu(uso) = defu(umo);
        savevtk(workdir + modefileout + "_mode.vtu", Thgs, adaptu(uso), dataname = ParaviewDataName, order = ParaviewOrder);
      } else {
        savevtk(workdir + modefileout + "_mode.vtu", Thg, adaptu(umo), dataname = ParaviewDataName, order = ParaviewOrder);
      }
      ENDIFMACRO
    }
  }
}//EOM

macro saveoptf(K, workdir, modefile, basefile, meshfile, forcingmode, m, eigenvalue){
  NewMacro PETSctype()K EndMacro
  fespace Xhg(Thg, Pkf);
  IFMACRO(PETSctype,real)
    ChangeNumbering([Mf, Mf], [fm[].re, fm[].im], eigenmode, inverse = true);
  ENDIFMACRO
  IFMACRO(PETSctype,complex)
    ChangeNumbering(Mf, fm[], eigenmode, inverse = true);
  ENDIFMACRO
  Xhg<complex> deff(fmg), deff(fmo);
  for[i, v : restf] fmg[][v] = fm[][i];
  mpiAllReduce(fmg[], fmo[], mpiCommWorld, mpiSUM);
  XMhg<complex> defu(fmf) = f2u(fmo);
  if (mpirank == 0 && modefile != "") {
    string outputfile = workdir + modefile + ".optf";
    cout << "  Saving '" + modefile + ".optf' over '" + basefile + ".base' on '" + meshfile + meshext + "' in '" + workdir + "'." << endl;
    cout << "\t" + listparams(paramnames, params) + "."  << endl;
    { ofstream file(outputfile, binary);
      file.precision(17);
      file << "mesh\t" << meshfile << endl << endl;
      file << "base\t" << basefile << endl << endl;
      for (int k = 0; k < paramnames.n; ++k){
        file << paramnames[k] << "\t" << params[paramnames[k]] << endl << endl;
      }
    file << "m\t" << m << endl << endl;
    file << "eval\t" << eigenvalue << endl << endl;
    file << fmf[] << endl;
    }
  }
}//EOM

func bool printstats(string outputfilename, string meshfilename, int m, real omega) {
      cout << "  Saving solution stats in '" + outputfilename + "'." << endl;
      cout << "\t" + listparams(paramnames, params) + ", " + listparams(monitornames, monitors) << endl;
      if (omega != 0.0 | m != 0) cout << ", m = " + m + ", omega = " + omega;
      cout << "." << endl;
      { ofstream file(outputfilename, append);
        file.precision(17);
        file << meshfilename << "\t";
        for (int k = 0; k < paramnames.n; ++k){
          file << params[paramnames[k]] << "\t";
        }
        for (int k = 0; k < monitornames.n; ++k){
          file << monitors[monitornames[k]] << "\t";
        }
        if (omega != 0.0 | m != 0) file << "\t" << m << "\t" << omega;
        file << endl;
      }
      return 0;
    }

func string readmeshname(string inputfilename) {
  string meshfilename;
  { ifstream file(inputfilename);
    file >> meshfilename >> meshfilename;
  }
  return meshfilename;
}

func string readbasename(string inputfilename) {
  string basefilename;
  { ifstream file(inputfilename);
    file >> basefilename >> basefilename >> basefilename >> basefilename;
  }
  return basefilename;
}
func complex readmodeeval(string inputfilename, int & m) {
  complex eigenvalue;
  string dummy;
  { ifstream file(inputfilename);
    for (int k = 0; k < (paramnames.n+2); ++k){
      file >> dummy >> dummy;
    }
    file >> dummy >> m;
    file >> dummy >> eigenvalue;
  }
  return eigenvalue;
}


func real[int] loadbase(string directoryname, string inputfilename, string meshfilename) {
      XMhg defu(ubg);
      if (inputfilename == ""){
        defu(ubg) = InitialConditions;
      } else {
        if (mpirank == 0) cout << "  Loading '" + inputfilename + ".base' on '" + meshfilename + meshext + "' from '" + directoryname + "'." << endl;
        string filemesh;
        ifstream file(directoryname + inputfilename + ".base");
        file >> filemesh >> filemesh;
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
        if (mpirank == 0) cout << "\t" + listparams(paramnames,params) + ", " + listparams(monitornames,monitors) << endl;
        if (filemesh == meshfilename){ // no interpolation needed
          file >> ubg[];
        } else { // must interpolate
          if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh + meshext << "'." << endl;
          meshN Thg1 = readmeshN(directoryname + filemesh + meshext);
          fespace XMhg1(Thg1, Pk);
          XMhg1 defu(ubg1);
          file >> ubg1[];
          defu(ubg) = defu(ubg1);
        }
      }
      setparams(paramnames,params);
      real[int] qlocal = ubg[](restu);
      return qlocal;
    }

func real[int] load2Cbase(string directoryname, string inputfilename, string meshfilename) {
      XMhg defu(ubg);
      if (inputfilename != ""){
        if (mpirank == 0) cout << "  Loading '" + inputfilename + ".base' on '" + meshfilename + meshext + "' from '" + directoryname + "'." << endl;
        string filemesh;
        ifstream file(directoryname + inputfilename + ".base");
        file >> filemesh >> filemesh;
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
        if (mpirank == 0) cout << "\t" + listparams(paramnames,params) + ", " + listparams(monitornames,monitors) << endl;
        { // Add 3rd velocity component to 2-component flow
          if (filemesh == meshfilename){ // no interpolation needed
            fespace XMhg2C(Thg, Pk2C);
            XMhg2C defu2C(ubg2C);
            file >> ubg2C[];
            defu(ubg) = u2u(ubg2C);
          } else { // must interpolate
            if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh + meshext << "'." << endl;
            meshN Thg1 = readmeshN(directoryname + filemesh + meshext);
            fespace XMhg1(Thg1, Pk2C);
            XMhg1 defu2C(ubg1);
            file >> ubg1[];
            defu(ubg) = u2u(ubg1);
          }
        }
      }
      setparams(paramnames,params);
      real[int] qlocal = ubg[](restu);
      return qlocal;
    }

func complex[int] loadmode(string directoryname, string inputfilename, string meshfilename, int & m, complex & eigenvalue) {
      XMhg<complex> defu(umg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".mode' over '";
      string filemesh, basefilename, dummy;
      real[string] tempparams;
      ifstream file(directoryname + inputfilename + ".mode");
      file >> filemesh >> filemesh >> basefilename >> basefilename;
      if (mpirank == 0) cout << basefilename + ".base' on '" + meshfilename + meshext + "' from '" + directoryname + "'." << endl;
      for (int k = 0; k < paramnames.n; ++k){
        file >> paramnames[k] >> tempparams[paramnames[k]];
      }
      file >> dummy >> m >> dummy >> eigenvalue;
      if (mpirank == 0) cout << "\t" + listparams(paramnames,tempparams) << ", m = " + m + ", eval = " + eigenvalue + "." << endl;
      if (filemesh == meshfilename){ // no interpolation needed
        file >> umg[];
      } else { // must interpolate
      if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh + meshext << "'." << endl;
        meshN Thg1 = readmeshN(directoryname + filemesh + meshext);
        fespace XMhg1(Thg1, Pk);
        XMhg1<complex> defu(umg1);
        file >> umg1[];
        defu(umg) = defu(umg1);
      }
      complex[int] qlocal = umg[](restu);
      return qlocal;
    }

func complex[int] load2Cmode(string directoryname, string inputfilename, string meshfilename, int & m, complex & eigenvalue) {
      XMhg<complex> defu(umg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".mode' over '";
      string filemesh, basefilename, dummy;
      real[string] tempparams;
      ifstream file(directoryname + inputfilename + ".mode");
      file >> filemesh >> filemesh >> basefilename >> basefilename;
      if (mpirank == 0) cout << basefilename + ".base' on '" + meshfilename + meshext + "' from '" + directoryname + "'." << endl;
      for (int k = 0; k < paramnames.n; ++k){
        file >> paramnames[k] >> tempparams[paramnames[k]];
      }
      file >> dummy >> m >> dummy >> eigenvalue;
      if (mpirank == 0) cout << "\t" + listparams(paramnames,tempparams) << ", m = " + m + ", eval = " + eigenvalue + "." << endl;
      { // Add 3rd velocity component to 2-component flow
        if (filemesh == meshfilename){ // no interpolation needed
          fespace XMhg2C(Thg, Pk2C);
          XMhg2C<complex> defu2C(umg2C);
          file >> umg2C[];
          defu(umg) = u2u(umg2C);
        } else { // must interpolate
          if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh + meshext << "'." << endl;
          meshN Thg1 = readmeshN(directoryname + filemesh + meshext);
          fespace XMhg1(Thg1, Pk2C);
          XMhg1<complex> defu2C(umg1);
          file >> umg1[];
          defu(umg) = u2u(umg1);
        }
      }
      complex[int] qlocal = umg[](restu);
      return qlocal;
    }

// parameter functions
  func real getlambda(string& contparam){
    real lambda;
    for (int k = 0; k < paramnames.n; ++k){
    if (contparam == paramnames[k]) lambda = params[paramnames[k]];
      }
    return lambda;
  }

  func int updatelambda(string& contparam, real lambda){
    for (int k = 0; k < paramnames.n; ++k){
      if (contparam == paramnames[k]) params[paramnames[k]] = lambda;
    }
    return 0;
  }
