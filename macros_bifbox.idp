//
// macros_bifbox.idp
// Chris Douglas
// cdoug@mit.edu
//
// NOTE: This file should not be changed unless you know what you're doing.
//

cout.precision(12);
string workdir = getARGV("-dir","./data/"); // set working directory
if (workdir(workdir.length-1:workdir.length-1) != "/") workdir = workdir + "/";
int paraviewflag = getARGV("-pv", 0); // indicate whether solution is saved for Paraview
// paraviewflag <= 0: don't save data in Paraview format (only in FF format)
// paraviewflag == 1: save in Paraview format on current mesh
// paraviewflag >= 2: save in Paraview format on 2x, 3x, ... refined mesh using meshsplit

func string parsefilename(string & filename, string & fileroot){
  string fileext;
  if(filename.rfind(".") > 0){ // filename includes extension
    fileext = filename(filename.rfind(".")+1:filename.length-1); // get file extension
    fileroot = filename(0:filename.rfind(".")-1); // get file root
  }
  else {
    fileroot = filename;
    fileext = "";
  }
  return fileext;
}

// Define local/global mesh variables
meshN Th; // local mesh
meshN Thg; // global mesh
fespace Xh(Th, Pkf); // local FEspace
fespace Xhg(Thg, Pkf); // global FEspace
fespace XMh(Th, Pk); // local FEspace
fespace XMhg(Thg, Pk); // global FEspace

// Initialize parallel local/global numbering arrays
int[int] n2o, restu, restf;
macro ThN2O()n2o// EOM

// Initialize parameter/monitor arrays
real[string] params, monitors;

// Set parameter values
func int setparams(string[int] & paramnames, real[string] & params){
  for (int k = 0; k < paramnames.n; ++k){
    params[paramnames[k]] = getARGV("-" + paramnames[k], params[paramnames[k]]);
  }
  return 0;
}
// Get parameter values
func string listparams(string[int] & paramnames, real[string] & params){
  string stringout;
  for (int k = 0; k < paramnames.n; ++k){
    if (k == 0) stringout = paramnames[k] + " = " + params[paramnames[k]];
    else stringout = stringout + ", " + paramnames[k] + " = " + params[paramnames[k]];
  }
  return stringout;
}
// EOM
macro createMatu(th,A,P){
    NewMacro def(u)defu(u) EndMacro
    NewMacro init(i)initu(i) EndMacro
    createMat(th,A,P)
} // EOM
macro createMatf(th,A,P){
    NewMacro def(u)deff(u) EndMacro
    NewMacro init(i)initf(i) EndMacro
    createMat(th,A,P)
} // EOM

macro adaptmeshoptions()
hmin = getARGV("-hmin",1.0e-6),
hmax = getARGV("-hmax",1.0e+2),
err = getARGV("-err", 1.0e-2),
errg = getARGV("-errg", 1.0e-2),
nbvx = int(getARGV("-nbvx",1e+6)),
nbsmooth = int(getARGV("-nbsmooth",5)),
ratio = getARGV("-ratio",1.8),
iso = bool(getARGV("-anisomax",1.0) <= 1.0),
anisomax = getARGV("-anisomax",1.0),
rescaling = bool(getARGV("-rescaling", 1)),
power = getARGV("-power", 1.0),
thetamax = getARGV("-thetamax", 10.0)
//EOM

// FUNCTIONS -------------------------------------------------------------------
macro savebase(basefileout, statsfile, meshfile, saveflag, monitorflag){
  XMhg defu(tempu), defu(ubg);
  tempu[](restu) = ub[];
  mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
  if(monitorflag) getmonitors(ubg);
  if(mpirank == 0 && monitorflag) {
    if(paramnames[0] != "") cout << "\t" << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if (mpirank == 0 && statsfile != "") {
    cout << "  Saving solution stats to '" + statsfile + ".base.cont' in '" + workdir + "'." << endl;
    string dummy = basefileout;
    {
      ofstream file(workdir + statsfile + ".base.cont", append);
      file.precision(17);
      file << basefileout + ((dummy.rfind(".") > 0) ? "" : ".base") << "\t" << meshfile;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if (saveflag && mpirank == 0 && basefileout != ""){
    cout << "  Saving '" + basefileout + ".base' on '" + meshfile + "' in '" + workdir + "'." << endl;
    {
      ofstream file(workdir + basefileout + ".base", binary);
      file.precision(17);
      file << "mesh\t" << meshfile << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
        }
      }
      file << ubg[] << endl;
    }
    if (paraviewflag > 0){
      cout << "  Saving '" + basefileout + "_base.vtu' in '" + workdir + "'." << endl;
      if (paraviewflag > 1){
        meshN Thgs = trunc(Thg, 1, split = paraviewflag);
        fespace XMhs(Thgs, Pk);
        XMhs defu(us) = defu(ubg);
        savevtk(workdir + basefileout + "_base.vtu", Thgs, adaptu(us), dataname = ParaviewDataName, order = ParaviewOrder);
      }
      else {
        savevtk(workdir + basefileout + "_base.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro savemode(modefileout, evalsfile, basefile, meshfile, evecs, evals, sym, saveflag){
  if(mpirank == 0){
    cout << "\tsym = " + sym + ", eval(s) = [" + evals(0);
    for (int kk = 1; kk < evals.n; ++kk) cout << ", " + evals(kk);
    cout << "]";
    if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
    cout << "." << endl;
  }
  if(mpirank == 0 && evalsfile != "") {
        cout << "  Saving " + evals.n + " eigenvalues to '" + evalsfile + ".eval' in '" + workdir + "'." << endl;
        for (int kk = 0; kk < evals.n; ++kk){
          ofstream file(workdir + evalsfile + ".eval", append);
          file.precision(17);
          file << basefile << "\t" << meshfile << "\t" << sym << "\t" << evals(kk);
          if(paramnames[0] != ""){
            for (int k = 0; k < paramnames.n; ++k){
              file << "\t" << params[paramnames[k]];
            }
          }
          if(monitornames[0] != ""){
            for (int k = 0; k < monitornames.n; ++k){
              file << "\t" << monitors[monitornames[k]];
            }
          }
          file << endl;
        }
      }
  if(saveflag){
    XMhg<complex> defu(tempu), defu(umg);
    for (int ii = 0; ii < evals.n; ++ii){
      um[] = evecs[ii][];
      tempu[](restu) = um[];
      mpiAllReduce(tempu[], umg[], mpiCommWorld, mpiSUM);
      string modefileout0 = modefileout + ((ii > 0) ? ("_" + ii) : "");
      if (mpirank == 0 && modefileout != ""){
        cout << "  Saving '" + modefileout0 + ".mode' over '" + basefile + "' on '" + meshfile + "' in '" + workdir + "'." << endl;
        {
          ofstream file(workdir + modefileout0 + ".mode", binary);
          file.precision(17);
          file << "mesh\t" << meshfile << endl;
          file << "file\t" << basefile << endl;
          file << "sym\t" << sym << endl;
          file << "eval\t" << evals(ii) << endl;
          if(paramnames[0] != ""){
            for (int k = 0; k < paramnames.n; ++k){
              file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
            }
          }
          file << umg[] << endl;
        }
        if (paraviewflag > 0){
          cout << "  Saving '" + modefileout0 + "_mode.vtu' in '" + workdir + "'." << endl;
          if (paraviewflag > 1){
            meshN Thgs = trunc(Thg, 1, split = paraviewflag);
            fespace XMhs(Thgs, Pk);
            XMhs<complex> defu(uso) = defu(umg);
            XMhs defu(usr), defu(usi);
            usr[] = uso[].re;
            usi[] = uso[].im;
            savevtk(workdir + modefileout0 + "_mode.vtu", Thgs, adaptu(usr), adaptu(usi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
          }
          else {
            XMhg defu(usr), defu(usi);
            usr[] = umg[].re;
            usi[] = umg[].im;
            savevtk(workdir + modefileout0 + "_mode.vtu", Thg, adaptu(usr), adaptu(usi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
          }
        }
      }
    }
  }
}//EOM

macro saverslv(rslvfileout, gainsfile, basefile, meshfile, fvecs, uvecs, gains, sym, omega, saveflag){
  if(mpirank == 0){
    cout << "\tsym = " + sym + ", omega = " + omega + ", gain(s) = [" + gains(0);
    for (int kk = 1; kk < gains.n; ++kk) cout << ", " + gains(kk);
    cout << "]";
    if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && gainsfile != "") {
    cout << "  Saving " + gains.n + " optimal gain(s) to '" + gainsfile + ".gain' in '" + workdir + "'." << endl;
    for (int kk = 0; kk < gains.n; ++kk){
      ofstream file(workdir + gainsfile + ".gain", append);
      file.precision(17);
      file << basefile << "\t" << meshfile << "\t" << sym << "\t" << omega << "\t" << gains(kk);
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file <<  "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag){
    Xhg<complex> deff(tempf), deff(fmg);
    XMhg<complex> defu(tempu), defu(umg);
    for (int ii = 0; ii < gains.n; ++ii){
      fm[] = fvecs[ii][];
      um[] = uvecs[ii][];
      tempu[](restu) = um[];
      mpiAllReduce(tempu[], umg[], mpiCommWorld, mpiSUM);
      tempu[](restf) = fm[];
      mpiAllReduce(tempf[], fmg[], mpiCommWorld, mpiSUM);
      string fileout = rslvfileout + ((ii > 0) ? ("_" + ii) : "");
      if (mpirank == 0 && rslvfileout != ""){
        cout << "  Saving '" + fileout + ".rslv' over '" + basefile + "' on '" + meshfile + "' in '" + workdir + "'." << endl;
        {
          ofstream file(workdir + fileout + ".rslv", binary);
          file.precision(17);
          file << "mesh\t" << meshfile << endl;
          file << "file\t" << basefile << endl;
          file << "sym\t" << sym << endl;
          file << "omega\t" << omega << endl;
          file << "gain\t" << gains(ii) << endl;
          if(paramnames[0] != ""){
            for (int k = 0; k < paramnames.n; ++k){
              file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
            }
          }
          file << fmg[] << endl;
          file << umg[] << endl;
        }
        if (paraviewflag > 0){
          cout << "  Saving '" + fileout + "_rslv_[forcing,response].vtu' in '" + workdir + "'." << endl;
          if (paraviewflag > 1){
            meshN Thgs = trunc(Thg, 1, split = paraviewflag);
            fespace XMhs(Thgs, Pk);
            XMhs<complex> defu(uso) = defu(umg);
            fespace Xhs(Thgs, Pkf);
            Xhs<complex> deff(fso) = deff(fmg);
            Xhs deff(fsr), deff(fsi);
            fsr[] = fso[].re;
            fsi[] = fso[].im;
            savevtk(workdir + fileout + "_mode_forcing.vtu", Thg, adaptf(fsr), adaptf(fsi), dataname = ParaviewDataNamefc, order = ParaviewOrderfc);
            XMhs defu(usr), defu(usi);
            usr[] = uso[].re;
            usi[] = uso[].im;
            savevtk(workdir + fileout + "_rslv_response.vtu", Thgs, adaptu(usr), adaptu(usi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
          }
          else {
            Xhg deff(fsr), deff(fsi);
            fsr[] = fmg[].re;
            fsi[] = fmg[].im;
            savevtk(workdir + fileout + "_mode_forcing.vtu", Thg, adaptf(fsr), adaptf(fsi), dataname = ParaviewDataNamefc, order = ParaviewOrderfc);
            XMhg defu(usr), defu(usi);
            usr[] = umg[].re;
            usi[] = umg[].im;
            savevtk(workdir + fileout + "_mode_response.vtu", Thg, adaptu(usr), adaptu(usi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
          }
        }
      }
    }
  }
}//EOM

macro savefold(foldfileout, statsfile, meshfile, alpha, beta, saveflag, monitorflag){
  XMhg defu(tempu), defu(ubg), defu(umg), defu(umag);
  tempu[](restu) = ub[];
  mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
  tempu[](restu) = um[];
  mpiAllReduce(tempu[], umg[], mpiCommWorld, mpiSUM);
  tempu[](restu) = uma[];
  mpiAllReduce(tempu[], umag[], mpiCommWorld, mpiSUM);
  if(monitorflag) getmonitors(ubg);
  if(mpirank == 0 && monitorflag){
    cout << "\t";
    if(paramnames[0] != ""){
      for (int k = 0; k < paramnames.n; ++k){
        cout << "alpha[" + paramnames[k] + "] = " + alpha[paramnames[k]] + ", ";
      }
    }
    cout << "beta = " + beta;
    if(paramnames[0] != "") cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if (mpirank == 0 && statsfile != "") {
    cout << "  Saving solution stats to '" + statsfile + ".fold.cont' in '" + workdir + "'." << endl;
    string dummy = foldfileout;
    {
      ofstream file(workdir + statsfile + ".fold.cont", append);
      file.precision(17);
      file << foldfileout + ((dummy.rfind(".") > 0) ? "" : ".fold") << "\t" << meshfile;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << alpha[paramnames[k]];
        }
      }
      file << "\t" << beta;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if (saveflag && mpirank == 0 && foldfileout != ""){
    cout << "  Saving '" + foldfileout + ".fold' on '" + meshfile + "' in '" + workdir + "'." << endl;
    {
      ofstream file(workdir + foldfileout + ".fold", binary);
      file.precision(17);
      file << "mesh\t" << meshfile << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "alpha[" + paramnames[k] + "]\t" << alpha[paramnames[k]] << endl;
        }
      }
      file << "beta\t" << beta << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
        }
      }
      file << ubg[] << endl;
      file << umg[] << endl;
      file << umag[] << endl;
    }
    if (paraviewflag > 0){
      cout << "  Saving '" + foldfileout + "_fold_[base,dirmode,adjmode].vtu' in '" + workdir + "'." << endl;
      if (paraviewflag > 1){
        meshN Thgs = trunc(Thg, 1, split = paraviewflag);
        fespace XMhs(Thgs, Pk);
        XMhs defu(ubs) = defu(ubg);
        savevtk(workdir + foldfileout + "_fold_base.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
        defu(ubs) = defu(umg);
        savevtk(workdir + foldfileout + "_fold_dirmode.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
        defu(ubs) = defu(umag);
        savevtk(workdir + foldfileout + "_fold_adjmode.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
      }
      else {
        savevtk(workdir + foldfileout + "_fold_base.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
        savevtk(workdir + foldfileout + "_fold_dirmode.vtu", Thg, adaptu(umg), dataname = ParaviewDataName, order = ParaviewOrder);
        savevtk(workdir + foldfileout + "_fold_adjmode.vtu", Thg, adaptu(umag), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro savehopf(hopffileout, statsfile, meshfile, sym, omega, alpha, beta, saveflag, monitorflag){
  XMhg defu(tempu), defu(ubg);
  XMhg<complex> defu(cplxu), defu(umg), defu(umag);
  tempu[](restu) = ub[].re;
  mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
  cplxu[](restu) = um[];
  mpiAllReduce(cplxu[], umg[], mpiCommWorld, mpiSUM);
  cplxu[](restu) = uma[];
  mpiAllReduce(cplxu[], umag[], mpiCommWorld, mpiSUM);
  if(monitorflag) getmonitors(ubg);
  if(mpirank == 0 && monitorflag){
    cout << "\tsym = " + sym + ", omega = " + omega + ", ";
    if(paramnames[0] != ""){
      for (int k = 0; k < paramnames.n; ++k){
        cout << "alpha[" + paramnames[k] + "] = " + alpha[paramnames[k]] + ", ";
      }
    }
    cout << "beta = " + beta;
    if(paramnames[0] != "" ) cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != ""){
    cout << "  Saving solution stats to '" + statsfile + ".hopf.cont' in '" + workdir + "'." << endl;
    string dummy = hopffileout;
    {
      ofstream file(workdir + statsfile + ".hopf.cont", append);
      file.precision(17);
      file << hopffileout + ((dummy.rfind(".") > 0) ? "" : ".hopf") << "\t" << meshfile << "\t" << sym << "\t" << omega;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << alpha[paramnames[k]];
        }
      }
      file << "\t" << beta;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && mpirank == 0 && hopffileout != ""){
    cout << "  Saving '" + hopffileout + ".hopf' on '" + meshfile + "' in '" + workdir + "'." << endl;
    {
      ofstream file(workdir + hopffileout + ".hopf", binary);
      file.precision(17);
      file << "mesh\t" << meshfile << endl;
      file << "sym\t" << sym << endl;
      file << "omega\t" << omega << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "alpha[" + paramnames[k] + "]\t" << alpha[paramnames[k]] << endl;
        }
      }
      file << "beta\t" << beta << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
        }
      }
      file << ubg[] << endl;
      file << umg[] << endl;
      file << umag[] << endl;
    }
    if (paraviewflag > 0){
      cout << "  Saving '" + hopffileout + "_hopf_[base,dirmode,adjmode].vtu' in '" + workdir + "'." << endl;
      if (paraviewflag > 1){
        meshN Thgs = trunc(Thg, 1, split = paraviewflag);
        fespace XMhs(Thgs, Pk);
        XMhs defu(ubs) = defu(ubg), defu(ubsi);
        XMhs<complex> defu(ums) = defu(umg);
        savevtk(workdir + hopffileout + "_hopf_base.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
        ubs[] = ums[].re;
        ubsi[] = ums[].im;
        savevtk(workdir + hopffileout + "_hopf_dirmode.vtu", Thgs, adaptu(ubs), adaptu(ubsi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        defu(ums) = defu(umag);
        ubs[] = ums[].re;
        ubsi[] = ums[].im;
        savevtk(workdir + hopffileout + "_hopf_adjmode.vtu", Thgs, adaptu(ubs), adaptu(ubsi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
      }
      else {
        savevtk(workdir + hopffileout + "_hopf_base.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
        ubg[] = umg[].re;
        tempu[] = umg[].im;
        savevtk(workdir + hopffileout + "_hopf_dirmode.vtu", Thg, adaptu(ubg), adaptu(tempu), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ubg[] = umag[].re;
        tempu[] = umag[].im;
        savevtk(workdir + hopffileout + "_hopf_adjmode.vtu", Thg, adaptu(ubg), adaptu(tempu), dataname = ParaviewDataNamec, order = ParaviewOrderc);
      }
    }
  }
}//EOM

macro savetdns(tdnsfileout, statsfile, meshfile, ICfile, time, saveflag, monitorflag){
  XMhg defu(tempu), defu(ubg);
  tempu[](restu) = ub[];
  mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
  if(monitorflag) getmonitors(ubg);
  if(mpirank == 0 && monitorflag){
    cout << "\ttime = " + time;
    if(paramnames[0] != "") cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != "") {
    cout << "  Saving solution stats to '" + statsfile + ".tdns.cont' in '" + workdir + "'." << endl;
    string dummy = tdnsfileout;
    {
      ofstream file(workdir + statsfile + ".tdns.cont", append);
      file.precision(17);
      file << tdnsfileout + ((dummy.rfind(".") > 0) ? "" : ".tdns") << "\t" << meshfile << "\t" << ICfile << "\t" << time;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && mpirank == 0 && tdnsfileout != ""){
    cout << "  Saving '" + tdnsfileout + ".tdns' on '" + meshfile + "' in '" + workdir + "'." << endl;
    {
      ofstream file(workdir + tdnsfileout + ".tdns", binary);
      file.precision(17);
      file << "mesh\t" << meshfile << endl;
      file << "init\t" << ICfile << endl;
      file << "time\t" << time << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
        }
      }
      file << ubg[] << endl;
    }
    if (paraviewflag > 0){
      cout << "  Saving '" + tdnsfileout + "_tdns.vtu' in '" + workdir + "'." << endl;
      if (paraviewflag > 1){
        meshN Thgs = trunc(Thg, 1, split = paraviewflag);
        fespace XMhs(Thgs, Pk);
        XMhs defu(us) = defu(ubg);
        savevtk(workdir + tdnsfileout + "_tdns.vtu", Thgs, adaptu(us), dataname = ParaviewDataName, order = ParaviewOrder);
      }
      else {
        savevtk(workdir + tdnsfileout + "_tdns.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro savehoho(hohofileout, statsfile, meshfile, sym1, sym2, omega1, omega2, alpha1, alpha2, beta1, beta2, gamma1, gamma2, gamma12, gamma13, gamma22, gamma23, saveflag, monitorflag){
  XMhg defu(tempu), defu(ubg);
  XMhg<complex> defu(cplxu), defu(u1mg), defu(u1mag), defu(u2mg), defu(u2mag);
  tempu[](restu) = ub[].re;
  mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
  cplxu[](restu) = um[];
  mpiAllReduce(cplxu[], u1mg[], mpiCommWorld, mpiSUM);
  cplxu[](restu) = uma[];
  mpiAllReduce(cplxu[], u1mag[], mpiCommWorld, mpiSUM);
  cplxu[](restu) = um2[];
  mpiAllReduce(cplxu[], u2mg[], mpiCommWorld, mpiSUM);
  cplxu[](restu) = um3[];
  mpiAllReduce(cplxu[], u2mag[], mpiCommWorld, mpiSUM);
  if(monitorflag) getmonitors(ubg);
  if(mpirank == 0 && monitorflag){
    cout << "\tsym = [" + sym1 + "; " + sym2 + "], omega = [" + omega1 + "; " + omega2;
    if(paramnames[0] != ""){
      for (int k = 0; k < paramnames.n; ++k){
        cout << "], alpha[" + paramnames[k] + "] = [" + alpha1[paramnames[k]] + "; " + alpha2[paramnames[k]];
      }
    }
    cout << "], beta = [" + beta1 + "; " + beta2 << "], gamma = [" + gamma1 + "," + gamma12 + "," + gamma13 + "; " + gamma2 + "," + gamma22 + "," + gamma23 +  "]";
    if(paramnames[0] != "" ) cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != ""){
    cout << "  Saving solution stats to '" + statsfile + ".hoho.cont' in '" + workdir + "'." << endl;
    string dummy = hohofileout;
    {
      ofstream file(workdir + statsfile + ".hoho.cont", append);
      file.precision(17);
      file << hohofileout + ((dummy.rfind(".") > 0) ? "" : ".hoho") << "\t" << meshfile << "\t" << sym1 << "\t" << sym2 << "\t" << omega1 << "\t" << omega2;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << alpha1[paramnames[k]] << "\t" << alpha2[paramnames[k]];
        }
      }
      file << "\t" << beta1 << "\t" << beta2 << "\t" << gamma1 << "\t" << gamma2 << "\t" << gamma12 << "\t" << gamma13 << "\t" << gamma22 << "\t" << gamma23;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && mpirank == 0 && hohofileout != ""){
    cout << "  Saving '" + hohofileout + ".hoho' on '" + meshfile + "' in '" + workdir + "'." << endl;
    {
      ofstream file(workdir + hohofileout + ".hoho", binary);
      file.precision(17);
      file << "mesh\t" << meshfile << endl;
      file << "sym\t" << sym1 << "\t" << sym2 << endl;
      file << "omega\t" << omega1 << "\t" << omega2 << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "alpha[" + paramnames[k] + "]\t" << alpha1[paramnames[k]] << "\t" << alpha2[paramnames[k]] << endl;
        }
      }
      file << "beta\t" << beta1 << "\t" << beta2 << endl;
      file << "gamma\t" << gamma1 << "\t" << gamma2 << "\t" << gamma12 << "\t" << gamma13 << "\t" << gamma22 << "\t" << gamma23 << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
        }
      }
      file << ubg[] << endl;
      file << u1mg[] << endl;
      file << u1mag[] << endl;
      file << u2mg[] << endl;
      file << u2mag[] << endl;
    }
    if (paraviewflag > 0){
      cout << "  Saving '" + hohofileout + "_hoho_[base,dirmode1,adjmode1,dirmode2,adjmode2].vtu' in '" + workdir + "'." << endl;
      if (paraviewflag > 1){
        meshN Thgs = trunc(Thg, 1, split = paraviewflag);
        fespace XMhs(Thgs, Pk);
        XMhs defu(ubs) = defu(ubg), defu(ubsi);
        XMhs<complex> defu(ums) = defu(u1mg);
        savevtk(workdir + hohofileout + "_hoho_base.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
        ubs[] = ums[].re;
        ubsi[] = ums[].im;
        savevtk(workdir + hohofileout + "_hoho_dirmode1.vtu", Thgs, adaptu(ubs), adaptu(ubsi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        defu(ums) = defu(u1mag);
        ubs[] = ums[].re;
        ubsi[] = ums[].im;
        savevtk(workdir + hohofileout + "_hoho_adjmode1.vtu", Thgs, adaptu(ubs), adaptu(ubsi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        defu(ums) = defu(u2mg);
        ubs[] = ums[].re;
        ubsi[] = ums[].im;
        savevtk(workdir + hohofileout + "_hoho_dirmode2.vtu", Thgs, adaptu(ubs), adaptu(ubsi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        defu(ums) = defu(u2mag);
        ubs[] = ums[].re;
        ubsi[] = ums[].im;
        savevtk(workdir + hohofileout + "_hoho_adjmode2.vtu", Thgs, adaptu(ubs), adaptu(ubsi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
      }
      else {
        savevtk(workdir + hohofileout + "_hoho_base.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
        ubg[] = u1mg[].re;
        tempu[] = u1mg[].im;
        savevtk(workdir + hohofileout + "_hoho_dirmode1.vtu", Thg, adaptu(ubg), adaptu(tempu), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ubg[] = u1mag[].re;
        tempu[] = u1mag[].im;
        savevtk(workdir + hohofileout + "_hoho_adjmode1.vtu", Thg, adaptu(ubg), adaptu(tempu), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ubg[] = u2mg[].re;
        tempu[] = u2mg[].im;
        savevtk(workdir + hohofileout + "_hoho_dirmode2.vtu", Thg, adaptu(ubg), adaptu(tempu), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ubg[] = u2mag[].re;
        tempu[] = u2mag[].im;
        savevtk(workdir + hohofileout + "_hoho_adjmode2.vtu", Thg, adaptu(ubg), adaptu(tempu), dataname = ParaviewDataNamec, order = ParaviewOrderc);
      }
    }
  }
}//EOM

macro savefoho(fohofileout, statsfile, meshfile, sym, omega, alpha1, alpha2, beta1, beta22, beta23, gamma12, gamma13, gamma22, gamma23, saveflag, monitorflag){
  XMhg defu(tempu), defu(ubg), defu(u2mg), defu(u2mag);
  XMhg<complex> defu(cplxu), defu(u1mg), defu(u1mag);
  tempu[](restu) = ub[].re;
  mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
  cplxu[](restu) = um[];
  mpiAllReduce(cplxu[], u1mg[], mpiCommWorld, mpiSUM);
  cplxu[](restu) = uma[];
  mpiAllReduce(cplxu[], u1mag[], mpiCommWorld, mpiSUM);
  cplxu[](restu) = um2[];
  mpiAllReduce(tempu[], u2mg[], mpiCommWorld, mpiSUM);
  cplxu[](restu) = um3[];
  mpiAllReduce(tempu[], u2mag[], mpiCommWorld, mpiSUM);
  if(monitorflag) getmonitors(ubg);
  if(mpirank == 0 && monitorflag){
    cout << "\tsym = " + sym + ", omega = " + omega;
    if(paramnames[0] != ""){
      for (int k = 0; k < paramnames.n; ++k){
        cout << ", alpha[" + paramnames[k] + "] = [" + alpha1[paramnames[k]] + "; " + alpha2[paramnames[k]] + "]";
      }
    }
    cout << ", beta = [" + beta1 + "; " + beta22 + ", " + beta23 << "], gamma = [" + gamma12 + ", " + gamma13 + "; " + gamma22 + ", " + gamma23 + "]";
    if(paramnames[0] != "" ) cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != ""){
    cout << "  Saving solution stats to '" + statsfile + ".foho.cont' in '" + workdir + "'." << endl;
    string dummy = fohofileout;
    {
      ofstream file(workdir + statsfile + ".foho.cont", append);
      file.precision(17);
      file << fohofileout + ((dummy.rfind(".") > 0) ? "" : ".hoho") << "\t" << meshfile << "\t" << sym << "\t" << omega;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << alpha1[paramnames[k]] << "\t" << alpha2[paramnames[k]];
        }
      }
      file << "\t" << beta1 << "\t" << beta22 << "\t" << beta23 << "\t" << gamma12 << "\t" << gamma13 << "\t" << gamma22 << "\t" << gamma23;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && mpirank == 0 && fohofileout != ""){
    cout << "  Saving '" + fohofileout + ".foho' on '" + meshfile + "' in '" + workdir + "'." << endl;
    {
      ofstream file(workdir + fohofileout + ".foho", binary);
      file.precision(17);
      file << "mesh\t" << meshfile << endl;
      file << "sym\t" << sym << endl;
      file << "omega\t" << omega << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "alpha[" + paramnames[k] + "]\t" << alpha1[paramnames[k]] << "\t" << alpha2[paramnames[k]] << endl;
        }
      }
      file << "beta\t" << beta1 << "\t" << beta22 << "\t" << beta23 << endl;
      file << "gamma\t" << gamma12 << "\t" << gamma13 << "\t" << gamma22 << "\t" << gamma23 << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
        }
      }
      file << ubg[] << endl;
      file << u1mg[] << endl;
      file << u1mag[] << endl;
      file << u2mg[] << endl;
      file << u2mag[] << endl;
    }
    if (paraviewflag > 0){
      cout << "  Saving '" + fohofileout + "_foho_[base,dirmode1,adjmode1,dirmode2,adjmode2].vtu' in '" + workdir + "'." << endl;
      if (paraviewflag > 1){
        meshN Thgs = trunc(Thg, 1, split = paraviewflag);
        fespace XMhs(Thgs, Pk);
        XMhs defu(ubs) = defu(ubg), defu(ubsi);
        XMhs<complex> defu(ums) = defu(u1mg);
        savevtk(workdir + fohofileout + "_foho_base.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
        ubs[] = ums[].re;
        ubsi[] = ums[].im;
        savevtk(workdir + fohofileout + "_foho_dirmode1.vtu", Thgs, adaptu(ubs), adaptu(ubsi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        defu(ums) = defu(u1mag);
        ubs[] = ums[].re;
        ubsi[] = ums[].im;
        savevtk(workdir + fohofileout + "_foho_adjmode1.vtu", Thgs, adaptu(ubs), adaptu(ubsi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        defu(ubs) = defu(u2mg);
        savevtk(workdir + fohofileout + "_foho_dirmode2.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
        defu(ubs) = defu(u2mag);
        savevtk(workdir + fohofileout + "_foho_adjmode2.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
      }
      else {
        savevtk(workdir + fohofileout + "_foho_base.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
        ubg[] = u1mg[].re;
        tempu[] = u1mg[].im;
        savevtk(workdir + fohofileout + "_foho_dirmode1.vtu", Thg, adaptu(ubg), adaptu(tempu), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ubg[] = u1mag[].re;
        tempu[] = u1mag[].im;
        savevtk(workdir + fohofileout + "_foho_adjmode1.vtu", Thg, adaptu(ubg), adaptu(tempu), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ubg[] = u2mg[];
        savevtk(workdir + fohofileout + "_foho_dirmode2.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
        ubg[] = u2mag[];
        savevtk(workdir + fohofileout + "_foho_adjmode2.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro saveporb(porbfileout, statsfile, meshfile, sym, omega, Nh, saveflag, monitorflag){
  XMhg defu(tempu), defu(ubg);
  XMhg<complex> defu(cplxu);
  XMhg<complex>[int] defu(uhg)(Nh);
  tempu[](restu) = ub[].re;
  mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
  for(int harm = 0; harm < Nh; harm++){
    cplxu[](restu) = uh[harm][];
    mpiAllReduce(cplxu[], uhg[harm][], mpiCommWorld, mpiSUM);
  }
  if(monitorflag) getmonitors(ubg);
  if(mpirank == 0 && monitorflag){
    cout << "\tsym = " + sym + ", omega = " + omega + ", Nh = " + Nh;
    if(paramnames[0] != "" ) cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != ""){
    cout << "  Saving solution stats to '" + statsfile + ".porb.cont' in '" + workdir + "'." << endl;
    string dummy = porbfileout;
    {
      ofstream file(workdir + statsfile + ".porb.cont", append);
      file.precision(17);
      file << porbfileout + ((dummy.rfind(".") > 0) ? "" : ".porb") << "\t" << meshfile << "\t" << sym << "\t" << omega << "\t" << Nh;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && mpirank == 0 && porbfileout != ""){
    cout << "  Saving '" + porbfileout + ".porb' on '" + meshfile + "' in '" + workdir + "'." << endl;
    {
      ofstream file(workdir + porbfileout + ".porb", binary);
      file.precision(17);
      file << "mesh\t" << meshfile << endl;
      file << "sym\t" << sym << endl;
      file << "omega\t" << omega << endl;
      file << "Nh\t" << Nh << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
        }
      }
      file << ubg[] << endl;
      for(int harm = 0; harm < Nh; harm++) file << uhg[harm][] << endl;
    }
    if (paraviewflag > 0){
      cout << "  Saving '" + porbfileout + "_porb_[mean,harm0,harm1,...].vtu' in '" + workdir + "'." << endl;
      if (paraviewflag > 1){
        meshN Thgs = trunc(Thg, 1, split = paraviewflag);
        fespace XMhs(Thgs, Pk);
        XMhs defu(ubs) = defu(ubg), defu(ubsi);
        XMhs<complex> defu(ums);
        savevtk(workdir + porbfileout + "_porb_mean.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
        for(int harm = 0; harm < Nh; harm++){
          cplxu[] = uhg[harm][];
          defu(ums) = defu(cplxu);
          ubs[] = ums[].re;
          ubsi[] = ums[].im;
          savevtk(workdir + porbfileout + "_porb_harm" + harm + ".vtu", Thgs, adaptu(ubs), adaptu(ubsi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        }
      }
      else {
        savevtk(workdir + porbfileout + "_porb_mean.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
        for(int harm = 0; harm < Nh; harm++){
          ubg[] = uhg[harm][].re;
          tempu[] = uhg[harm][].im;
          savevtk(workdir + porbfileout + "_porb_harm" + harm + ".vtu", Thg, adaptu(ubg), adaptu(tempu), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        }
      }
    }
  }
}//EOM

func string readmeshname(string inputfilename) {
  string meshfilename;
  { ifstream file(inputfilename);
    file >> meshfilename >> meshfilename;
  }
  return meshfilename;
}

func string readbasename(string inputfilename) {
  string basefilename;
  { ifstream file(inputfilename);
    file >> basefilename >> basefilename >> basefilename >> basefilename;
  }
  return basefilename;
}
func complex readmodeeval(string inputfilename, int & sym) {
  complex eigenvalue;
  string dummy;
  { ifstream file(inputfilename);
    for (int k = 0; k < (paramnames.n+2); ++k){
      file >> dummy >> dummy;
    }
    file >> dummy >> sym;
    file >> dummy >> eigenvalue;
  }
  return eigenvalue;
}


func real[int] loadbase(string inputfilename, string meshfilename) {
      XMhg defu(ubg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".base' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string filemesh;
      ifstream file(workdir + inputfilename + ".base");
      file >> filemesh >> filemesh;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        if(paramnames[0] != "" || monitornames[0] != "") cout << "\t";
        if(paramnames[0] != "") cout << listparams(paramnames, params);
        if(paramnames[0] != "" && monitornames[0] != "") cout << ", ";
        if(monitornames[0] != "") cout << listparams(monitornames, monitors);
        if(paramnames[0] != "" || monitornames[0] != "") cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1);
        file >> ubg1[];
        defu(ubg) = defu(ubg1);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      return qlocal;
    }

func real[int] loadfold(string inputfilename, string meshfilename, real[int] & qmlocal, real[int] & qmalocal, real[string] & alpha, real & beta) {
      XMhg defu(ubg), defu(umg), defu(umag);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".fold' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string dummy, filemesh;
      ifstream file(workdir + inputfilename + ".fold");
      file >> filemesh >> filemesh;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> dummy >> alpha[paramnames[k]];
        }
      }
      file >> dummy >> beta;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\t";
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            cout << "alpha[" + paramnames[k] + "] = " + alpha[paramnames[k]] + ", ";
          }
        }
        cout << "beta = " + (beta);
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        file >> umg[];
        file >> umag[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1), defu(umg1), defu(umag1);
        file >> ubg1[];
        file >> umg1[];
        file >> umag1[];
        defu(ubg) = defu(ubg1);
        defu(umg) = defu(umg1);
        defu(umag) = defu(umag1);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      qmlocal = umg[](restu);
      qmalocal = umag[](restu);
      return qlocal;
    }

func real[int] loadhopf(string inputfilename, string meshfilename, complex[int] & qmlocal, complex[int] & qmalocal, int & sym, real & omega, complex[string] & alpha, complex & beta) {
      XMhg defu(ubg);
      XMhg<complex> defu(umg), defu(umag);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".hopf' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string dummy, filemesh;
      ifstream file(workdir + inputfilename + ".hopf");
      file >> dummy >> filemesh >> dummy >> sym >> dummy >> omega;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> dummy >> alpha[paramnames[k]];
        }
      }
      file >> dummy >> beta;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\tsym = " + sym + ", omega = " + omega;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            cout << ", alpha[" + paramnames[k] + "] = " + alpha[paramnames[k]];
          }
        }
        cout << ", beta = " + (beta);
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        file >> umg[];
        file >> umag[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1);
        XMhg1<complex> defu(umg1), defu(umag1);
        file >> ubg1[];
        file >> umg1[];
        file >> umag1[];
        defu(ubg) = defu(ubg1);
        defu(umg) = defu(umg1);
        defu(umag) = defu(umag1);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      qmlocal = umg[](restu);
      qmalocal = umag[](restu);
      return qlocal;
    }

func complex[int] loadmode(string inputfilename, string meshfilename, int & sym, complex & eigenvalue) {
      XMhg<complex> defu(umg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".mode' over '";
      string filemesh, basefilename, dummy;
      real[string] tempparams;
      ifstream file(workdir + inputfilename + ".mode");
      file >> filemesh >> filemesh >> basefilename >> basefilename >> dummy >> sym >> dummy >> eigenvalue;
      if (mpirank == 0) cout << basefilename + "' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> tempparams[paramnames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\tsym = " + sym + ", eval = " + eigenvalue;
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, tempparams);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> umg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1<complex> defu(umg1);
        file >> umg1[];
        defu(umg) = defu(umg1);
      }
      complex[int] qlocal = umg[](restu);
      return qlocal;
    }

func complex[int] loadrslv(string inputfilename, string meshfilename, complex[int] & fmlocal, int & sym, real & omega, real & gain) {
      Xhg<complex> deff(fmg);
      XMhg<complex> defu(umg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".rslv' over '";
      string filemesh, basefilename, dummy;
      real[string] tempparams;
      ifstream file(workdir + inputfilename + ".rslv");
      file >> filemesh >> filemesh >> basefilename >> basefilename >> dummy >> sym >> dummy >> omega >> dummy >> gain;
      if (mpirank == 0) cout << basefilename + "' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> tempparams[paramnames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\tsym = " + sym + ", omega = " + omega + ", gain = " + gain;
        if(paramnames[0] != "") cout << ", " + listparams(paramnames,tempparams);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> fmg[] >> umg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace Xhg1(Thg1, Pkf);
        Xhg1<complex> deff(fmg1);
        fespace XMhg1(Thg1, Pk);
        XMhg1<complex> defu(umg1);
        file >> fmg1[] >> umg1[];
        deff(fmg) = deff(fmg1);
        defu(umg) = defu(umg1);
      }
      fmlocal = fmg[](restf);
      complex[int] qlocal = umg[](restu);
      return qlocal;
    }

func real[int] loadtdns(string inputfilename, string meshfilename, real& time) {
      XMhg defu(ubg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".tdns' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string filemesh, ICfile, dummy;
      ifstream file(workdir + inputfilename + ".tdns");
      file >> filemesh >> filemesh >> ICfile >> ICfile >> dummy >> time;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\ttime = " << time;
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1);
        file >> ubg1[];
        defu(ubg) = defu(ubg1);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      return qlocal;
    }

func real[int] loadhoho(string inputfilename, string meshfilename, complex[int] & q1mlocal, complex[int] & q1malocal, complex[int] & q2mlocal, complex[int] & q2malocal,
                        int & sym1, int & sym2, real & omega1, real & omega2, complex[string] & alpha1, complex[string] & alpha2, complex & beta1, complex & beta2, complex & gamma1, complex & gamma2, complex & gamma12, complex & gamma13, complex & gamma22, complex & gamma23) {
      XMhg defu(ubg);
      XMhg<complex> defu(u1mg), defu(u1mag), defu(u2mg), defu(u2mag);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".hoho' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string dummy, filemesh;
      ifstream file(workdir + inputfilename + ".hoho");
      file >> dummy >> filemesh >> dummy >> sym1 >> sym2 >> dummy >> omega1 >> omega2;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> dummy >> alpha1[paramnames[k]] >> alpha2[paramnames[k]];
        }
      }
      file >> dummy >> beta1 >> beta2;
      file >> dummy >> gamma1 >> gamma2 >> gamma12 >> gamma13 >> gamma22 >> gamma23;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if(mpirank == 0) {
        cout << "\tsym = [" + sym1 + "; " + sym2 + "], omega = [" + omega1 + "; " + omega2;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            cout << "], alpha[" + paramnames[k] + "] = [" + alpha1[paramnames[k]] + "; " + alpha2[paramnames[k]];
          }
        }
        cout << "], beta = [" + beta1 + "; " + beta2 + "], gamma = [" + gamma1 + ", " + gamma12 + ", " + gamma13 + "; " + gamma2 + ", " + gamma22 + ", " + gamma23 + "]";
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        file >> u1mg[];
        file >> u1mag[];
        file >> u2mg[];
        file >> u2mag[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg0);
        XMhg1<complex> defu(umg1), defu(umag1), defu(umg2), defu(umag2);
        file >> ubg0[];
        file >> umg1[];
        file >> umag1[];
        file >> umg2[];
        file >> umag2[];
        defu(ubg) = defu(ubg0);
        defu(u1mg) = defu(umg1);
        defu(u1mag) = defu(umag1);
        defu(u2mg) = defu(umg2);
        defu(u2mag) = defu(umag2);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      q1mlocal = u1mg[](restu);
      q1malocal = u1mag[](restu);
      q2mlocal = u2mg[](restu);
      q2malocal = u2mag[](restu);
      return qlocal;
    }

func real[int] loadfoho(string inputfilename, string meshfilename, complex[int] & q1mlocal, complex[int] & q1malocal, real[int] & q2mlocal, real[int] & q2malocal,
                        int & sym, real & omega, complex[string] & alpha1, real[string] & alpha2, complex & beta1, real & beta22, real & beta23, complex & gamma12, complex & gamma13, real & gamma22, real & gamma23) {
      XMhg defu(ubg), defu(u2mg), defu(u2mag);
      XMhg<complex> defu(u1mg), defu(u1mag);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".foho' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string dummy, filemesh;
      ifstream file(workdir + inputfilename + ".foho");
      file >> dummy >> filemesh >> dummy >> sym >> dummy >> omega;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> dummy >> alpha1[paramnames[k]] >> alpha2[paramnames[k]];
        }
      }
      file >> dummy >> beta1 >> beta22 >> beta23;
      file >> dummy >> gamma12 >> gamma13 >> gamma22 >> gamma23;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if(mpirank == 0) {
        cout << "\tsym = " + sym + ", omega = " + omega;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            cout << ", alpha[" + paramnames[k] + "] = [" + alpha1[paramnames[k]] + "; " + alpha2[paramnames[k]] + "]";
          }
        }
        cout << ", beta = [" + beta1 + "; " + beta22 + ", " + beta23 + "], gamma = [" + gamma12 + ", " + gamma13 + "; " + gamma22 + ", " + gamma23 + "]";
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        file >> u1mg[];
        file >> u1mag[];
        file >> u2mg[];
        file >> u2mag[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg0), defu(umg2), defu(umag2);
        XMhg1<complex> defu(umg1), defu(umag1);
        file >> ubg0[];
        file >> umg1[];
        file >> umag1[];
        file >> umg2[];
        file >> umag2[];
        defu(ubg) = defu(ubg0);
        defu(u1mg) = defu(umg1);
        defu(u1mag) = defu(umag1);
        defu(u2mg) = defu(umg2);
        defu(u2mag) = defu(umag2);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      q1mlocal = u1mg[](restu);
      q1malocal = u1mag[](restu);
      q2mlocal = u2mg[](restu);
      q2malocal = u2mag[](restu);
      return qlocal;
    }

func real[int] loadporb(string inputfilename, string meshfilename, complex[int][int] & qhlocal, int & sym, real & omega, int & Nh) {
      XMhg defu(ubg);
      XMhg<complex> defu(umg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".porb' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string dummy, filemesh;
      ifstream file(workdir + inputfilename + ".porb");
      file >> dummy >> filemesh >> dummy >> sym >> dummy >> omega >> dummy >> Nh;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if(qhlocal.n == 0) qhlocal.resize(Nh);
      XMhg<complex>[int] defu(uhg)(Nh);
      if (mpirank == 0) {
        cout << "\tsym = " + sym + ", omega = " + omega + ", Nh = " + Nh;
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        for (int harm = 0; harm < Nh; harm++) file >> uhg[harm][];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1);
        file >> ubg1[];
        defu(ubg) = defu(ubg1);
        XMhg1<complex> defu(umg1);
        for (int harm = 0; harm < Nh; harm++) {
          file >> umg1[];
          defu(umg) = defu(umg1);
          uhg[harm][] = umg[];
        }
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      for (int harm = 0; harm < min(Nh, qhlocal.n); harm++) qhlocal[harm] = uhg[harm][](restu);
      return qlocal;
    }

// parameter functions
  func real getlambda(string& contparam){
    real lambda;
    for (int k = 0; k < paramnames.n; ++k){
    if (contparam == paramnames[k]) lambda = params[paramnames[k]];
      }
    return lambda;
  }

  func int updatelambda(string& contparam, real lambda){
    for (int k = 0; k < paramnames.n; ++k){
      if (contparam == paramnames[k]) params[paramnames[k]] = lambda;
    }
    return 0;
  }
