//
// macros_bifbox.idp
// Chris Douglas
// christopher.douglas@duke.edu
//
// NOTE: This file should not be changed unless you know what you're doing.
//

cout.precision(12);
string workdir = getARGV("-dir","./data/"); // set working directory
if (workdir(workdir.length-1:workdir.length-1) != "/") workdir = workdir + "/";
int paraviewflag = getARGV("-pv", 0); // indicate whether solution is saved for Paraview
// paraviewflag <= 0: don't save data in Paraview format (only in FF format)
// paraviewflag == 1: save in Paraview format on current mesh
// paraviewflag == 2, 3, ...: save in Paraview format on 2x, 3x, ... refined mesh using meshsplit
// If settings file does not define a paraview output format
IFMACRO(!paraviewu)
  macro paraviewu(u) adaptu(u) // EOM
ENDIFMACRO
IFMACRO(!paraviewf)
  macro paraviewf(f) adaptf(f) // EOM
ENDIFMACRO

// If settings file does not define a coordinate transform.
IFMACRO(!coordinatetransform)
  IFMACRO(dimension,2)
    macro coordinatetransform() x, y // EOM
  ENDIFMACRO 
  IFMACRO(dimension,3)
    macro coordinatetransform() x, y, z // EOM
  ENDIFMACRO
ENDIFMACRO
// Parse mesh or solution filename
func string parsefilename(string & filename, string & fileroot){
  string fileext;
  if(filename.rfind(".") > 0){ // filename includes extension
    fileext = filename(filename.rfind(".")+1:filename.length-1); // get file extension
    fileroot = filename(0:filename.rfind(".")-1); // get file root
  }
  else {
    fileroot = filename;
    fileext = "";
  }
  return fileext;
}

// parse complex number from string
func complex string2complex(string & s) {
    int sep = -1;
    for (int i = 1; i < s.length; ++i) {
        if ((s(i:i) == "+" || s(i:i) == "-") && (s(i-1:i-1) != "e" && s(i-1:i-1) != "E")) {
            sep = i;
            break;
        }
    }
    if (sep == -1) { // No separator found, treat as real only
        return atof(s);
    }
    real re = atof(s(0:sep));
    real im = atof(s(sep:s.length-1));
    return re + 1i*im;
}

// Parse symmetry string
func real[int] parsesymstr(string & symstr){
  int fidx = -1;
  string symmstr = symstr;
  real[int] symm(sym.n);
  for (int kk = 0; kk < sym.n; ++kk){
    if (sym.n > 0){
      symmstr = symmstr(fidx+1:symmstr.length);
      fidx = symmstr.find(",");
      if (fidx==-1) fidx = symmstr.length;
      symm(kk) = strtod(symmstr(0:fidx-1));
    }
  }
  return symm;
}
// Get symmetry values as string
func string listsym(real[int] & sym){
  string stringout;
  for (int k = 0; k < sym.n; ++k){
    if (k == 0) stringout = string(sym(0));
    else stringout = stringout + "," + string(sym(k));
  }
  return stringout;
}

// Define local/global mesh variables
meshN Th; // local mesh
meshN Thg; // global mesh
fespace Xh(Th, Pkf); // local FEspace
fespace Xhg(Thg, Pkf); // global FEspace
fespace XMh(Th, Pk); // local FEspace
fespace XMhg(Thg, Pk); // global FEspace

// Initialize parallel local/global numbering arrays
int[int] n2o, restu, restf;
macro ThN2O()n2o// EOM

// Initialize parameter/monitor arrays
real[string] params, monitors;

// Set parameter values
func int setparams(string[int] & paramnames, real[string] & params){
  for (int k = 0; k < paramnames.n; ++k){
    params[paramnames[k]] = getARGV("-" + paramnames[k], params[paramnames[k]]);
  }
  return 0;
}
// Get parameter values
func string listparams(string[int] & paramnames, real[string] & params){
  string stringout;
  for (int k = 0; k < paramnames.n; ++k){
    if (k == 0) stringout = paramnames[k] + " = " + params[paramnames[k]];
    else stringout = stringout + ", " + paramnames[k] + " = " + params[paramnames[k]];
  }
  return stringout;
}

macro createMatu(th,A,P){
    NewMacro def(u)defu(u) EndMacro
    NewMacro init(i)initu(i) EndMacro
    createMat(th,A,P)
} // EOM
macro createMatf(th,A,P){
    NewMacro def(u)deff(u) EndMacro
    NewMacro init(i)initf(i) EndMacro
    createMat(th,A,P)
} // EOM

macro adaptmeshoptions()
hmin = getARGV("-hmin", 1.0e-6),
hmax = getARGV("-hmax", 1.0e+2),
err = getARGV("-err", 1.0e-2),
errg = getARGV("-errg", 1.0e-2),
nbvx = int(getARGV("-nbvx", 1e+6)),
nbsmooth = int(getARGV("-nbsmooth", 5)),
ratio = getARGV("-ratio",1.8),
iso = bool(getARGV("-anisomax", 1.0) <= 1.0),
anisomax = getARGV("-anisomax", 1.0),
rescaling = bool(getARGV("-rescaling", 1)),
power = getARGV("-power", 1.0),
thetamax = getARGV("-thetamax", 10.0)
//EOM

macro ConvergenceCheck(printtxt)
  func int funcConvergence(int iter, real qnorm, real dqnorm, real fnorm, PetscScalar[int]& qa, PetscScalar[int]& dqa) {
    it = iter;
    ret = 0;
    if (it == 0){
      cosalpha = 0.0;
      kappa = 0.0;
      maxdelta = 0.0;
      delta = contorder ? abs(h0) : deltamax;
    }
    else {
      real ip1, ip1l = real(yqP0'*yqP), ip2, ip2l = real(yqP0'*yqP0), ip3, ip3l = real(yqP'*yqP);
      mpiAllReduce(ip1l, ip1, mpiCommWorld, mpiSUM);
      mpiAllReduce(ip2l, ip2, mpiCommWorld, mpiSUM);
      mpiAllReduce(ip3l, ip3, mpiCommWorld, mpiSUM);
      cosalpha = (ip1 + 1.0)/sqrt((ip2 + 1.0)*(ip3 + 1.0));
      kappa = max(dqnorm/delta, kappa);
      maxdelta = max(dqnorm, maxdelta);
      delta = dqnorm;
    }
    f = max(acos(abs(cosalpha))/anglemax*fmax, sqrt(maxdelta/deltamax)*fmax, sqrt(kappa/kappamax)*fmax, 1./fmax);
    if(mpirank == 0) cout << "  " + (adaptflag ? "A" + (count-1) : count) + "-" + it + ":\t||R|| = " + fnorm + (it == 0 ? (",\th0 = " + h0) : (",\t||dx|| = " + delta + ",\tangle = " + (sign(cosalpha)*acos(abs(cosalpha))*180./pi))) + ",\t" + printtxt << "." << endl;
    if (it > 0 && !adaptflag && (f > fmax || it-1 >= snesmaxit || monotone > res/fnorm)){
      ret = -12;
      if(mpirank==0){
        if(monotone > res/fnorm) cout << "\tResidual contraction factor exceeds " << monotone << "." << endl;
        if(kappa > kappamax) cout << "\tStep contraction factor exceeds " << kappamax << "." << endl;
        if(it > snesmaxit) cout << "\tFailed to converge within " + snesmaxit + " iterations." << endl;
        if(maxdelta > deltamax) cout << "\tStep norm exceeds " << deltamax << "." << endl;
        if(acos(abs(cosalpha)) > anglemax) cout << "\tTangent angle change exceeds " << (anglemax*180./pi) << " degrees." << endl;
      }
    }
    res = fnorm;
    return ret;
  }
// EOM

macro ResidualHB(RHB, J, ub, uh, sym0, omega) {
  sym = 0;
  real[int] Rtemp, R = vR(0, XMh, tgv = -1);
  complex[int] Rctemp(ub[].n), Rc(ub[].n);
  for (int j = 0; j < Nh; j++){
    um[] = uh(:, j);
    um2[] = conj(um[]);
    ik.im = (1+j)*(sym0);
    ik2 = conj(ik);
    iomega = 1i*(1+j)*(omega);
    iomega2 = -iomega;
    Rc = vH(0, XMh, tgv = -10);
    R += Rc.re;
    for (int k = 0; k < Nh-j-1; k++){
      um2[] = uh(:, k);
      um3[] = conj(uh(:, 1+j+k));
      ik2.im = (1+k)*(sym0);
      ik3.im = -(2+j+k)*(sym0);
      iomega2 = 1i*(1+k)*(omega);
      iomega3 = -1i*(2+j+k)*(omega);
      Rc = vT(0, XMh, tgv = -10);
      R += Rc.re;
    }
  }
  ChangeNumbering(J, R, Rtemp);
  RHB(0:J.n-1) = Rtemp;
  for (int nh = 0; nh < Nh; ++nh) {
    Rc = 0.0;
    sym = (1+nh)*(sym0);
    for (int j = 0; j < Nh; j++){
      um[] = uh(:, j);
      ik.im = (1+j)*(sym0);
      iomega = 1i*(1+j)*(omega);
      if (j == nh) Rctemp = vJ(0, XMh, tgv = -1);
      else {
        if (j < nh) um2[] = 0.5*uh(:, nh-j-1);
        else um2[] = conj(uh(:, j-nh-1));
        ik2.im = (nh-j)*(sym0);
        iomega2 = 1i*(nh-j)*(omega);
        Rctemp = vH(0, XMh, tgv = -10);
      }
      Rc += Rctemp;
      for (int k = 0; k < Nh; k++) {
        if (k != nh-j-1 && k < Nh+nh-j) {
          um2[] = 0.5*uh(:, k);
          if (k < nh-j-1) um3[] = uh(:, nh-j-k-2)/3.0;
          else um3[] = conj(uh(:, j+k-nh));
          ik2.im = (1+k)*(sym0);
          ik3.im = (nh-j-k-1)*(sym0);
          iomega2 = 1i*(1+k)*(omega);
          iomega3 = 1i*(nh-j-k-1)*(omega);
          Rctemp = vT(0, XMh, tgv = -10);
          Rc += Rctemp;
        }
        if (k < j-nh-1) {
          um2[] = conj(uh(:, k));
          um3[] = conj(uh(:, j-k-nh-2));
          um3[] *= 0.5;
          ik2.im = -(1+k)*(sym0);
          ik3.im = -(j-k-nh-1)*(sym0);
          iomega2 = -1i*(1+k)*(omega);
          iomega3 = -1i*(j-k-nh-1)*(omega);
          Rctemp = vT(0, XMh, tgv = -10);
          Rc += Rctemp;
        }
      }
    }
    ChangeNumbering([J, J], [Rc.re, Rc.im], Rtemp);
    RHB((1+2*nh)*J.n:(3+2*nh)*J.n-1) = Rtemp;
  }
}//EOM

macro domegaResidualHB(MqHB, J, ub, uh, sym0) {
  MqHB(0:J.n-1) = 0;
  for (int nh = 0; nh < Nh; ++nh) {
    real[int] Rtemp;
    complex[int] Rctemp(ub[].n), Rc(ub[].n);
    sym = (1+nh)*(sym0);
    for (int j = 0; j < Nh; j++){
      um[] = uh(:, j);
      ik.im = (1+j)*(sym0);
      if (j == nh) Rctemp = vM(0, XMh, tgv = -10);
      else {
        if (j < nh) um2[] = 0.5*uh(:, nh-j-1);
        else um2[] = conj(uh(:, j-nh-1));
        ik2.im = (nh-j)*(sym0);
        Rctemp = vdM(0, XMh, tgv = -10);
      }
      Rc += Rctemp;
      for (int k = 0; k < Nh; k++) {
        if (k != nh-j-1 && k < Nh+nh-j) {
          um2[] = 0.5*uh(:, k);
          if (k < nh-j-1) um3[] = uh(:, nh-j-k-2)/3.0;
          else um3[] = conj(uh(:, j+k-nh));
          ik2.im = (1+k)*(sym0);
          ik3.im = (nh-j-k-1)*(sym0);
          Rctemp = vddM(0, XMh, tgv = -10);
          Rc += Rctemp;
        }
        if (k < j-nh-1) {
          um2[] = conj(uh(:, k));
          um3[] = conj(uh(:, j-k-nh-2));
          um3[] *= 0.5;
          ik2.im = -(1+k)*(sym0);
          ik3.im = -(j-k-nh-1)*(sym0);
          Rctemp = vddM(0, XMh, tgv = -10);
          Rc += Rctemp;
        }
      }
    }
    Rc *= 1i*(1+nh);
    ChangeNumbering([J, J], [Rc.re, Rc.im], Rtemp);
    MqHB((1+2*nh)*J.n:(3+2*nh)*J.n-1) = Rtemp;
  }
}//EOM

macro JacobianHB(JHB, J, ub, uh, sym0, omega) {
    sym = 0;
    ik = 0;
    iomega = 0;
    Mat[int, int] JHBtemp(1+2*Nh, 1+2*Nh);
    matrix<complex> Cmat = vJ(XMh, XMh, tgv = -1);
    matrix An2r = Cmat.re, An3r, An2i, An3i;
    ik3 = 0;
    iomega3 = 0;
    for (int j = 0; j < Nh; j++){
      um[] = uh(:, j);
      um2[] = conj(um[]);
      ik.im = (1+j)*(sym0);
      ik2 = conj(ik);
      iomega = 1i*(1+j)*(omega);
      iomega2 = -iomega;
      Cmat = vT(XMh, XMh, tgv = -10);
      An2r += Cmat.re;
    }
    constructor(JHBtemp(0, 0), J, An2r);
    for (int j = 0; j < Nh; j++){
      um[] = 2.0*uh(:, j);
      ik.im = (1+j)*(sym0);
      ik2.im = -(1+j)*(sym0);
      iomega = 1i*(1+j)*(omega);
      iomega2 = -iomega;
      Cmat = vH(XMh, XMh, tgv = -10);
      An2r = Cmat.re;
      An2i = Cmat.im;
      ik3.im = -(1+j)*(sym0);
      iomega3 = -1i*(1+j)*(omega);
      for (int k = 0; k < Nh; k++){
        if (k < Nh-j-1) {
          um[] = 2.0*uh(:, 1+j+k);
          um2[] = conj(uh(:, k));
          ik.im = (2+j+k)*(sym0);
          ik2.im = -(1+k)*(sym0);
          iomega = 1i*(2+j+k)*(omega);
          iomega2 = -1i*(1+k)*(omega);
          Cmat = vT(XMh, XMh, tgv = -10);
          An2r += Cmat.re;
          An2i += Cmat.im;
        }
        if (k < j) {
          um[] = uh(:, j-k-1);
          um2[] = uh(:, k);
          ik.im = (j-k)*(sym0);
          ik2.im = (1+k)*(sym0);
          iomega = 1i*(j-k)*(omega);
          iomega2 = 1i*(1+k)*(omega);
          Cmat = vT(XMh, XMh, tgv = -10);
          An2r += Cmat.re;
          An2i += Cmat.im;
        }
      }
      constructor(JHBtemp(0, 1+2*j), J, An2r);
      constructor(JHBtemp(0, 2+2*j), J, An2i);
    }
    for (int nh = 0; nh < Nh; nh++){
      sym = (1+nh)*(sym0);
      um[] = uh(:, nh);
      ik.im = sym;
      ik2 = 0;
      iomega = 1i*(1+nh)*(omega);
      iomega2 = 0;
      Cmat = vH(XMh, XMh, tgv = -10);
      An2r = Cmat.re;
      An2i = Cmat.im;
      ik3 = 0;
      iomega3 = 0;
      for (int j = 0; j < Nh; j++) {
        if (j != nh) {
          um[] = uh(:, j);
          if (j < nh) um2[] = 0.5*uh(:, nh-j-1);
          else um2[] = conj(uh(:, j-nh-1));
          ik.im = (1+j)*(sym0);
          ik2.im = (nh-j)*(sym0);
          iomega = 1i*(1+j)*(omega);
          iomega2 = 1i*(nh-j)*(omega);
          Cmat = vT(XMh, XMh, tgv = -10);
          An2r += Cmat.re;
          An2i += Cmat.im;
        }
      }
      constructor(JHBtemp(1+2*nh, 0), J, An2r);
      constructor(JHBtemp(2+2*nh, 0), J, An2i);
      for (int j = 0; j < Nh; j++) {
        if (j == nh) {
          iomega = 1i*(1+nh)*(omega);
          ik.im = sym;
          Cmat = vJ(XMh, XMh, tgv = -1);
        }
        else {
          if (j < nh) um[] = uh(:, nh-j-1);
          else um[] = conj(uh(:, j-nh-1));
          ik.im = (nh-j)*(sym0);
          ik2.im = (1+j)*(sym0);
          iomega = 1i*(nh-j)*(omega);
          iomega2 = 1i*(1+j)*(omega);
          Cmat = vH(XMh, XMh, tgv = -10);
        }
        An2r = Cmat.re;
        An2i = Cmat.im;
        An3r = -An2i;
        An3i = Cmat.re;
        if (j < Nh-nh-1) {
          um[] = uh(:, 1+nh+j);
          ik.im = (2+nh+j)*(sym0);
          ik2.im = -(1+j)*(sym0);
          iomega = 1i*(2+nh+j)*(omega);
          iomega2 = -1i*(1+j)*(omega);
          Cmat = vH(XMh, XMh, tgv = -10);
          An2r += Cmat.re;
          An2i += Cmat.im;
          An3r += Cmat.im;
          An3i -= Cmat.re;
        }
        for (int k = 0; k < Nh; k++) {
          if (k != nh-j-1 && k < Nh+nh-j) {
            if (k < nh-j-1) um[] = 0.5*uh(:, nh-j-k-2);
            else um[] = conj(uh(:, j+k-nh));
            um2[] = uh(:, k);
            ik.im = (nh-j-k-1)*(sym0);
            ik2.im = (1+k)*(sym0);
            ik3.im = (1+j)*(sym0);
            iomega = 1i*(nh-j-k-1)*(omega);
            iomega2 = 1i*(1+k)*(omega);
            iomega3 = 1i*(1+j)*(omega);
            Cmat = vT(XMh, XMh, tgv = -10);
            An2r += Cmat.re;
            An2i += Cmat.im;
            An3r -= Cmat.im;
            An3i += Cmat.re;
          }
          if (k < 1+j+nh && k > j+nh-Nh) {
            um[] = 0.5*uh(:, nh+j-k);
            um2[] = uh(:, k);
            ik.im = (1+nh+j-k)*(sym0);
            ik2.im = (1+k)*(sym0);
            ik3.im = -(1+j)*(sym0);
            iomega = 1i*(1+nh+j-k)*(omega);
            iomega2 = 1i*(1+k)*(omega);
            iomega3 = -1i*(1+j)*(omega);
            Cmat = vT(XMh, XMh, tgv = -10);
            An2r += Cmat.re;
            An2i += Cmat.im;
            An3r += Cmat.im;
            An3i -= Cmat.re;
          }
          if (k < j-nh-1) {
            um[] = conj(uh(:, j-k-nh-2));
            um[] *= 0.5;
            um2[] = conj(uh(:, k));
            ik.im = -(j-k-nh-1)*(sym0);
            ik2.im = -(1+k)*(sym0);
            ik3.im = (1+j)*(sym0);
            iomega = -1i*(j-k-nh-1)*(omega);
            iomega2 = -1i*(1+k)*(omega);
            iomega3 = 1i*(1+j)*(omega);
            Cmat = vT(XMh, XMh, tgv = -10);
            An2r += Cmat.re;
            An2i += Cmat.im;
            An3r -= Cmat.im;
            An3i += Cmat.re;
          }
          if (k < Nh-nh-j-2) {
            um[] = uh(:, j+k+nh+2);
            um2[] = conj(uh(:, k));
            ik.im = (3+j+k+nh)*(sym0);
            ik2.im = -(1+k)*(sym0);
            ik3.im = -(1+j)*(sym0);
            iomega = 1i*(3+j+k+nh)*(omega);
            iomega2 = -1i*(1+k)*(omega);
            iomega3 = -1i*(1+j)*(omega);
            Cmat = vT(XMh, XMh, tgv = -10);
            An2r += Cmat.re;
            An2i += Cmat.im;
            An3r += Cmat.im;
            An3i -= Cmat.re;
          }
        }
        constructor(JHBtemp(1+2*nh, 1+2*j), J, An2r);
        constructor(JHBtemp(1+2*nh, 2+2*j), J, An3r);
        constructor(JHBtemp(2+2*nh, 1+2*j), J, An2i);
        constructor(JHBtemp(2+2*nh, 2+2*j), J, An3i);
      }
    }
    Mat temp, convert(JHBtemp);
    MatConvert(convert, temp);
    JHB = temp;
} // EOM

macro JacobianHBcplx(JHB, J, ub, uh, sym0, sym1, omega, shift) {
    sym = (sym1);
    ik.im = (sym1);
    iomega = (shift);
    Mat<complex>[int, int] JHBtemp(1+2*Nh, 1+2*Nh);
    matrix<complex> Cmat, An3i, An2r = vJ(XMh, XMh, tgv = -2);
    ik3.im = (sym1);
    iomega3 = (shift);
    for (int j = 0; j < Nh; j++){
      um[] = uh(:, j);
      um2[] = conj(um[]);
      ik.im = (1+j)*(sym0);
      ik2 = conj(ik);
      iomega = 1i*(1+j)*(omega);
      iomega2 = -iomega;
      Cmat = vT(XMh, XMh, tgv = -20);
      An2r += Cmat;
    }
    constructor(JHBtemp(0, 0), J, An2r);
    for (int j = 0; j < Nh; j++){
      um[] = uh(:, j);
      ik.im = (1+j)*(sym0);
      ik2.im = -(1+j)*(sym0) + (sym1);
      iomega = 1i*(1+j)*(omega);
      iomega2 = -iomega + (shift);
      An3i = vH(XMh, XMh, tgv = -20);
      um[] = conj(um[]);
      ik.im *= -1.0;
      ik2.im = (1+j)*(sym0) + (sym1);
      iomega *= -1.0;
      iomega2 = -iomega + (shift);
      An2r = vH(XMh, XMh, tgv = -20);
      for (int k = 0; k < Nh; k++){
        if (k < Nh-j-1) {
          um[] = uh(:, 1+j+k);
          um2[] = conj(uh(:, k));
          ik.im = (2+j+k)*(sym0);
          ik2.im = -(1+k)*(sym0);
          ik3.im = -(1+j)*(sym0) + (sym1);
          iomega = 1i*(2+j+k)*(omega);
          iomega2 = -1i*(1+k)*(omega);
          iomega3 = -1i*(1+j)*(omega) + (shift);
          Cmat = vT(XMh, XMh, tgv = -20);
          An3i += Cmat;
          um[] = conj(um[]);
          um2[] = conj(um2[]);
          ik.im *= -1.0;
          ik2.im *= -1.0;
          ik3.im = (1+j)*(sym0) + (sym1);
          iomega *= -1.0;
          iomega2 *= -1.0;
          iomega3 = 1i*(1+j)*(omega) + (shift);
          Cmat = vT(XMh, XMh, tgv = -20);
          An2r += Cmat;
        }
        if (k < j) {
          um[] = 0.5*uh(:, j-k-1);
          um2[] = uh(:, k);
          ik.im = (j-k)*(sym0);
          ik2.im = (1+k)*(sym0);
          ik3.im = -(1+j)*(sym0) + (sym1);
          iomega = 1i*(j-k)*(omega);
          iomega2 = 1i*(1+k)*(omega);
          iomega3 = -1i*(1+j)*(omega) + (shift);
          Cmat = vT(XMh, XMh, tgv = -20);
          An3i += Cmat;
          um[] = conj(um[]);
          um2[] = conj(um2[]);
          ik.im *= -1.0;
          ik2.im *= -1.0;
          ik3.im = (1+j)*(sym0) + (sym1);
          iomega *= -1.0;
          iomega2 *= -1.0;
          iomega3 = 1i*(1+j)*(omega) + (shift);
          Cmat = vT(XMh, XMh, tgv = -20);
          An2r += Cmat;
        }
      }
      constructor(JHBtemp(0, 1+2*j), J, An2r);
      constructor(JHBtemp(0, 2+2*j), J, An3i);
    }
    for (int nh = 0; nh < Nh; nh++){
      sym = (1+nh)*(sym0) + (sym1);
      um[] = uh(:, nh);
      ik.im = (1+nh)*(sym0);
      ik2.im = (sym1);
      iomega = 1i*(1+nh)*(omega);
      iomega2 = (shift);
      An2r = vH(XMh, XMh, tgv = -20);
      sym = -(1+nh)*(sym0) + (sym1);
      um[] = conj(um[]);
      ik.im *= -1.0;
      iomega *= -1.0;
      An3i = vH(XMh, XMh, tgv = -20);
      ik3.im = (sym1);
      iomega3 = (shift);
      for (int j = 0; j < Nh; j++) {
        if (j != nh) {
          sym = (1+nh)*(sym0) + (sym1);
          um[] = uh(:, j);
          if (j < nh) um2[] = 0.5*uh(:, nh-j-1);
          else um2[] = conj(uh(:, j-nh-1));
          ik.im = (1+j)*(sym0);
          ik2.im = (nh-j)*(sym0);
          iomega = 1i*(1+j)*(omega);
          iomega2 = 1i*(nh-j)*(omega);
          Cmat = vT(XMh, XMh, tgv = -20);
          An2r += Cmat;
          sym = -(1+nh)*(sym0) + (sym1);
          um[] = conj(um[]);
          um2[] = conj(um2[]);
          ik.im *= -1.0;
          ik2.im *= -1.0;
          iomega *= -1.0;
          iomega2 *= -1.0;
          Cmat = vT(XMh, XMh, tgv = -20);
          An3i += Cmat;
        }
      }
      constructor(JHBtemp(1+2*nh, 0), J, An2r);
      constructor(JHBtemp(2+2*nh, 0), J, An3i);
      for (int j = 0; j < Nh; j++) {
        matrix<complex> An3r(ub[].n,ub[].n), An2i(ub[].n,ub[].n);
        if (j == nh) {
          sym = (1+nh)*(sym0) + (sym1);
          ik.im = sym;
          iomega = 1i*(1+nh)*(omega) + (shift);
          An2r = vJ(XMh, XMh, tgv = -2);
          sym = -(1+nh)*(sym0) + (sym1);
          ik.im = sym;
          iomega = -1i*(1+nh)*(omega) + (shift);
          An3i = vJ(XMh, XMh, tgv = -2);
        }
        else if (j < nh) {
          sym = (1+nh)*(sym0) + (sym1);
          um[] = uh(:, nh-j-1);
          ik.im = (nh-j)*(sym0);
          ik2.im = (1+j)*(sym0) + (sym1);
          iomega = 1i*(nh-j)*(omega);
          iomega2 = 1i*(1+j)*(omega) + (shift);
          An2r = vH(XMh, XMh, tgv = -20);
          sym = -(1+nh)*(sym0) + (sym1);
          um[] = conj(um[]);
          ik.im *= -1.0;
          ik2.im = -(1+j)*(sym0) + (sym1);
          iomega *= -1.0;
          iomega2 = -1i*(1+j)*(omega) + (shift);
          An3i = vH(XMh, XMh, tgv = -20);
        }
        else {
          sym = (1+nh)*(sym0) + (sym1);
          um[] = conj(uh(:, j-nh-1));
          ik.im = (nh-j)*(sym0);
          ik2.im = (1+j)*(sym0) + (sym1);
          iomega = 1i*(nh-j)*(omega);
          iomega2 = 1i*(1+j)*(omega) + (shift);
          An2r = vH(XMh, XMh, tgv = -20);
          sym = -(1+nh)*(sym0) + (sym1);
          um[] = conj(um[]);
          ik.im *= -1.0;
          ik2.im = -(1+j)*(sym0) + (sym1);
          iomega *= -1.0;
          iomega2 = -1i*(1+j)*(omega) + (shift);
          An3i = vH(XMh, XMh, tgv = -20);
        }
        if (j < Nh-nh-1) {
          sym = (1+nh)*(sym0) + (sym1);
          um[] = uh(:, 1+nh+j);
          ik.im = (2+nh+j)*(sym0);
          ik2.im = -(1+j)*(sym0) + (sym1);
          iomega = 1i*(2+nh+j)*(omega);
          iomega2 = -1i*(1+j)*(omega) + (shift);
          An3r = vH(XMh, XMh, tgv = -20);
          sym = -(1+nh)*(sym0) + (sym1);
          um[] = conj(um[]);
          ik.im *= -1.0;
          ik2.im = (1+j)*(sym0) + (sym1);
          iomega *= -1.0;
          iomega2 = 1i*(1+j)*(omega) + (shift);
          An2i = vH(XMh, XMh, tgv = -20);
        }
        for (int k = 0; k < Nh; k++) {
          if (k != nh-j-1 && k < Nh+nh-j) {
            sym = (1+nh)*(sym0) + (sym1);
            if (k < nh-j-1) um[] = 0.5*uh(:, nh-j-k-2);
            else um[] = conj(uh(:, j+k-nh));
            um2[] = uh(:, k);
            ik.im = (nh-j-k-1)*(sym0);
            ik2.im = (1+k)*(sym0);
            ik3.im = (1+j)*(sym0) + (sym1);
            iomega = 1i*(nh-j-k-1)*(omega);
            iomega2 = 1i*(1+k)*(omega);
            iomega3 = 1i*(1+j)*(omega) + (shift);
            Cmat = vT(XMh, XMh, tgv = -20);
            An2r += Cmat;
            sym = -(1+nh)*(sym0) + (sym1);
            um[] = conj(um[]);
            um2[] = conj(um2[]);
            ik.im *= -1.0;
            ik2.im *= -1.0;
            ik3.im = -(1+j)*(sym0) + (sym1);
            iomega *= -1.0;
            iomega2 *= -1.0;
            iomega3 = -1i*(1+j)*(omega) + (shift);
            Cmat = vT(XMh, XMh, tgv = -20);
            An3i += Cmat;
          }
          if (k < 1+j+nh && k > j+nh-Nh) {
            sym = (1+nh)*(sym0) + (sym1);
            um[] = 0.5*uh(:, nh+j-k);
            um2[] = uh(:, k);
            ik.im = (1+nh+j-k)*(sym0);
            ik2.im = (1+k)*(sym0);
            ik3.im = -(1+j)*(sym0) + (sym1);
            iomega = 1i*(1+nh+j-k)*(omega);
            iomega2 = 1i*(1+k)*(omega);
            iomega3 = -1i*(1+j)*(omega) + (shift);
            Cmat = vT(XMh, XMh, tgv = -20);
            An3r += Cmat;
            sym = -(1+nh)*(sym0) + (sym1);
            um[] = conj(um[]);
            um2[] = conj(um2[]);
            ik.im *= -1.0;
            ik2.im *= -1.0;
            ik3.im = (1+j)*(sym0) + (sym1);
            iomega *= -1.0;
            iomega2 *= -1.0;
            iomega3 = 1i*(1+j)*(omega) + (shift);
            Cmat = vT(XMh, XMh, tgv = -20);
            An2i += Cmat;
          }
          if (k < j-nh-1) {
            sym = (1+nh)*(sym0) + (sym1);
            um[] = conj(uh(:, j-k-nh-2));
            um[] *= 0.5;
            um2[] = conj(uh(:, k));
            ik.im = -(j-k-nh-1)*(sym0);
            ik2.im = -(1+k)*(sym0);
            ik3.im = (1+j)*(sym0) + (sym1);
            iomega = -1i*(j-k-nh-1)*(omega);
            iomega2 = -1i*(1+k)*(omega);
            iomega3 = 1i*(1+j)*(omega) + (shift);
            Cmat = vT(XMh, XMh, tgv = -20);
            An2r += Cmat;
            sym = -(1+nh)*(sym0) + (sym1);
            um[] = conj(um[]);
            um2[] = conj(um2[]);
            ik.im *= -1.0;
            ik2.im *= -1.0;
            ik3.im = -(1+j)*(sym0) + (sym1);
            iomega *= -1.0;
            iomega2 *= -1.0;
            iomega3 = -1i*(1+j)*(omega) + (shift);
            Cmat = vT(XMh, XMh, tgv = -20);
            An3i += Cmat;
          }
          if (k < Nh-nh-j-2) {
            sym = (1+nh)*(sym0) + (sym1);
            um[] = uh(:, j+k+nh+2);
            um2[] = conj(uh(:, k));
            ik.im = (3+j+k+nh)*(sym0);
            ik2.im = -(1+k)*(sym0);
            ik3.im = -(1+j)*(sym0) + (sym1);
            iomega = 1i*(3+j+k+nh)*(omega);
            iomega2 = -1i*(1+k)*(omega);
            iomega3 = -1i*(1+j)*(omega) + (shift);
            Cmat = vT(XMh, XMh, tgv = -20);
            An3r += Cmat;
            sym = -(1+nh)*(sym0) + (sym1);
            um[] = conj(um[]);
            um2[] = conj(um2[]);
            ik.im *= -1.0;
            ik2.im *= -1.0;
            ik3.im = (1+j)*(sym0) + (sym1);
            iomega *= -1.0;
            iomega2 *= -1.0;
            iomega3 = 1i*(1+j)*(omega) + (shift);
            Cmat = vT(XMh, XMh, tgv = -20);
            An2i += Cmat;
          }
        }
        constructor(JHBtemp(1+2*nh, 1+2*j), J, An2r);
        constructor(JHBtemp(1+2*nh, 2+2*j), J, An3r);
        constructor(JHBtemp(2+2*nh, 1+2*j), J, An2i);
        constructor(JHBtemp(2+2*nh, 2+2*j), J, An3i);
      }
    }
    Mat<complex> temp, convert(JHBtemp);
    MatConvert(convert, temp);
    JHB = temp;
} // EOM

macro MassHBcplx(MHB, J, ub, uh, sym0, sym1) {
    sym = (sym1);
    ik.im = (sym1);
    Mat<complex>[int, int] MHBtemp(1+2*Nh, 1+2*Nh);
    matrix<complex> Cmat, An3i, An2r = vM(XMh, XMh, tgv = -20);
    ik3.im = (sym1);
    for (int j = 0; j < Nh; j++){
      um[] = uh(:, j);
      um2[] = conj(um[]);
      ik.im = (1+j)*(sym0);
      ik2 = conj(ik);
      Cmat = vddM(XMh, XMh, tgv = -20);
      An2r += Cmat;
    }
    constructor(MHBtemp(0, 0), J, An2r);
    for (int j = 0; j < Nh; j++){
      um[] = uh(:, j);
      ik.im = (1+j)*(sym0);
      ik2.im = -(1+j)*(sym0) + (sym1);
      An3i = vdM(XMh, XMh, tgv = -20);
      um[] = conj(um[]);
      ik.im *= -1.0;
      ik2.im = (1+j)*(sym0) + (sym1);
      An2r = vdM(XMh, XMh, tgv = -20);
      for (int k = 0; k < Nh; k++){
        if (k < Nh-j-1) {
          um[] = uh(:, 1+j+k);
          um2[] = conj(uh(:, k));
          ik.im = (2+j+k)*(sym0);
          ik2.im = -(1+k)*(sym0);
          ik3.im = -(1+j)*(sym0) + (sym1);
          Cmat = vddM(XMh, XMh, tgv = -20);
          An3i += Cmat;
          um[] = conj(um[]);
          um2[] = conj(um2[]);
          ik.im *= -1.0;
          ik2.im *= -1.0;
          ik3.im = (1+j)*(sym0) + (sym1);
          Cmat = vddM(XMh, XMh, tgv = -20);
          An2r += Cmat;
        }
        if (k < j) {
          um[] = 0.5*uh(:, j-k-1);
          um2[] = uh(:, k);
          ik.im = (j-k)*(sym0);
          ik2.im = (1+k)*(sym0);
          ik3.im = -(1+j)*(sym0) + (sym1);
          Cmat = vddM(XMh, XMh, tgv = -20);
          An3i += Cmat;
          um[] = conj(um[]);
          um2[] = conj(um2[]);
          ik.im *= -1.0;
          ik2.im *= -1.0;
          ik3.im = (1+j)*(sym0) + (sym1);
          Cmat = vddM(XMh, XMh, tgv = -20);
          An2r += Cmat;
        }
      }
      constructor(MHBtemp(0, 1+2*j), J, An2r);
      constructor(MHBtemp(0, 2+2*j), J, An3i);
    }
    for (int nh = 0; nh < Nh; nh++){
      sym = (1+nh)*(sym0) + (sym1);
      um[] = uh(:, nh);
      ik.im = (1+nh)*(sym0);
      ik2.im = (sym1);
      An2r = vdM(XMh, XMh, tgv = -20);
      sym = -(1+nh)*(sym0) + (sym1);
      um[] = conj(um[]);
      ik.im *= -1.0;
      ik2.im = (sym1);
      An3i = vdM(XMh, XMh, tgv = -20);
      ik3.im = (sym1);
      for (int j = 0; j < Nh; j++) {
        if (j != nh) {
          sym = (1+nh)*(sym0) + (sym1);
          um[] = uh(:, j);
          if (j < nh) um2[] = 0.5*uh(:, nh-j-1);
          else um2[] = conj(uh(:, j-nh-1));
          ik.im = (1+j)*(sym0);
          ik2.im = (nh-j)*(sym0);
          Cmat = vddM(XMh, XMh, tgv = -20);
          An2r += Cmat;
          sym = -(1+nh)*(sym0) + (sym1);
          um[] = conj(um[]);
          um2[] = conj(um2[]);
          ik.im *= -1.0;
          ik2.im *= -1.0;
          Cmat = vddM(XMh, XMh, tgv = -20);
          An3i += Cmat;
        }
      }
      constructor(MHBtemp(1+2*nh, 0), J, An2r);
      constructor(MHBtemp(2+2*nh, 0), J, An3i);
      for (int j = 0; j < Nh; j++) {
        matrix<complex> An3r(ub[].n,ub[].n), An2i(ub[].n,ub[].n);
        if (j == nh) {
          sym = (1+nh)*(sym0) + (sym1);
          ik.im = sym;
          An2r = vM(XMh, XMh, tgv = -20);
          sym = -(1+nh)*(sym0) + (sym1);
          ik.im = sym;
          An3i = vM(XMh, XMh, tgv = -20);
        }
        else if (j < nh) {
          sym = (1+nh)*(sym0) + (sym1);
          um[] = uh(:, nh-j-1);
          ik.im = (nh-j)*(sym0);
          ik2.im = (1+j)*(sym0) + (sym1);
          An2r = vdM(XMh, XMh, tgv = -20);
          sym = -(1+nh)*(sym0) + (sym1);
          um[] = conj(um[]);
          ik.im *= -1.0;
          ik2.im = -(1+j)*(sym0) + (sym1);
          An3i = vdM(XMh, XMh, tgv = -20);
        }
        else {
          sym = (1+nh)*(sym0) + (sym1);
          um[] = conj(uh(:, j-nh-1));
          ik.im = (nh-j)*(sym0);
          ik2.im = (1+j)*(sym0) + (sym1);
          An2r = vdM(XMh, XMh, tgv = -20);
          sym = -(1+nh)*(sym0) + (sym1);
          um[] = conj(um[]);
          ik.im *= -1.0;
          ik2.im = -(1+j)*(sym0) + (sym1);
          An3i = vdM(XMh, XMh, tgv = -20);
        }
        if (j < Nh-nh-1) {
          sym = (1+nh)*(sym0) + (sym1);
          um[] = uh(:, 1+nh+j);
          ik.im = (2+nh+j)*(sym0);
          ik2.im = -(1+j)*(sym0) + (sym1);
          An3r = vdM(XMh, XMh, tgv = -20);
          sym = -(1+nh)*(sym0) + (sym1);
          um[] = conj(um[]);
          ik.im *= -1.0;
          ik2.im = (1+j)*(sym0) + (sym1);
          An2i = vdM(XMh, XMh, tgv = -20);
        }
        for (int k = 0; k < Nh; k++) {
          if (k != nh-j-1 && k < Nh+nh-j) {
            sym = (1+nh)*(sym0) + (sym1);
            if (k < nh-j-1) um[] = 0.5*uh(:, nh-j-k-2);
            else um[] = conj(uh(:, j+k-nh));
            um2[] = uh(:, k);
            ik.im = (nh-j-k-1)*(sym0);
            ik2.im = (1+k)*(sym0);
            ik3.im = (1+j)*(sym0) + (sym1);
            Cmat = vddM(XMh, XMh, tgv = -20);
            An2r += Cmat;
            sym = -(1+nh)*(sym0) + (sym1);
            um[] = conj(um[]);
            um2[] = conj(um2[]);
            ik.im *= -1.0;
            ik2.im *= -1.0;
            ik3.im = -(1+j)*(sym0) + (sym1);
            Cmat = vddM(XMh, XMh, tgv = -20);
            An3i += Cmat;
          }
          if (k < 1+j+nh && k > j+nh-Nh) {
            sym = (1+nh)*(sym0) + (sym1);
            um[] = 0.5*uh(:, nh+j-k);
            um2[] = uh(:, k);
            ik.im = (1+nh+j-k)*(sym0);
            ik2.im = (1+k)*(sym0);
            ik3.im = -(1+j)*(sym0) + (sym1);
            Cmat = vddM(XMh, XMh, tgv = -20);
            An3r += Cmat;
            sym = -(1+nh)*(sym0) + (sym1);
            um[] = conj(um[]);
            um2[] = conj(um2[]);
            ik.im *= -1.0;
            ik2.im *= -1.0;
            ik3.im = (1+j)*(sym0) + (sym1);
            Cmat = vddM(XMh, XMh, tgv = -20);
            An2i += Cmat;
          }
          if (k < j-nh-1) {
            sym = (1+nh)*(sym0) + (sym1);
            um[] = conj(uh(:, j-k-nh-2));
            um[] *= 0.5;
            um2[] = conj(uh(:, k));
            ik.im = -(j-k-nh-1)*(sym0);
            ik2.im = -(1+k)*(sym0);
            ik3.im = (1+j)*(sym0) + (sym1);
            Cmat = vddM(XMh, XMh, tgv = -20);
            An2r += Cmat;
            sym = -(1+nh)*(sym0) + (sym1);
            um[] = conj(um[]);
            um2[] = conj(um2[]);
            ik.im *= -1.0;
            ik2.im *= -1.0;
            ik3.im = -(1+j)*(sym0) + (sym1);
            Cmat = vddM(XMh, XMh, tgv = -20);
            An3i += Cmat;
          }
          if (k < Nh-nh-j-2) {
            sym = (1+nh)*(sym0) + (sym1);
            um[] = uh(:, j+k+nh+2);
            um2[] = conj(uh(:, k));
            ik.im = (3+j+k+nh)*(sym0);
            ik2.im = -(1+k)*(sym0);
            ik3.im = -(1+j)*(sym0) + (sym1);
            Cmat = vddM(XMh, XMh, tgv = -20);
            An3r += Cmat;
            sym = -(1+nh)*(sym0) + (sym1);
            um[] = conj(um[]);
            um2[] = conj(um2[]);
            ik.im *= -1.0;
            ik2.im *= -1.0;
            ik3.im = (1+j)*(sym0) + (sym1);
            Cmat = vddM(XMh, XMh, tgv = -20);
            An2i += Cmat;
          }
        }
        constructor(MHBtemp(1+2*nh, 1+2*j), J, An2r);
        constructor(MHBtemp(1+2*nh, 2+2*j), J, An3r);
        constructor(MHBtemp(2+2*nh, 1+2*j), J, An2i);
        constructor(MHBtemp(2+2*nh, 2+2*j), J, An3i);
      }
    }
    Mat<complex> convert(MHBtemp);
    MatConvert(convert, MHB);
} // EOM

// FUNCTIONS -------------------------------------------------------------------
macro savebase(basefileout, statsfile, meshfile, saveflag, monitorflag){
  IFMACRO(getmonitors) 
    XMhg defu(tempu), defu(ubg), defu(umg), defu(umag);
    tempu[](restu) = ub[];
    mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    if(monitorflag) getmonitors;
  ENDIFMACRO
  if(mpirank == 0 && monitorflag) {
    if(paramnames[0] != "") cout << "\t" << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if (mpirank == 0 && statsfile != "") {
    cout << "  Saving solution stats to '" + statsfile + ".base.stat' in '" + workdir + "'." << endl;
    string dummy = basefileout;
    {
      ofstream file(workdir + statsfile + ".base.stat", append);
      file.precision(17);
      file << basefileout + ((dummy.rfind(".") > 0) ? "" : ".base") << "\t" << meshfile;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if (saveflag && basefileout != ""){
    IFMACRO(!getmonitors) 
      XMhg defu(tempu), defu(ubg), defu(umg), defu(umag);
      tempu[](restu) = ub[];
      mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    ENDIFMACRO
    if(mpirank == 0){
      cout << "  Saving '" + basefileout + ".base' on '" + meshfile + "' in '" + workdir + "'." << endl;
      {
        ofstream file(workdir + basefileout + ".base", binary);
        file.precision(17);
        file << "mesh\t" << meshfile << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
          }
        }
        file << ubg[] << endl;
      }
      if (paraviewflag > 0){
        cout << "  Saving '" + basefileout + "_base.vtu' in '" + workdir + "'." << endl;
        meshN Thgpv;
        real[int] qpv = ubg[];
        if (paraviewflag > 1){
          meshN Thgs = trunc(Thg, 1, split = paraviewflag);
          fespace XMhs(Thgs, Pk);
          XMhs defu(us) = defu(ubg);
          qpv.resize(us[].n);
          qpv = us[];
          Thgpv = movemesh(Thgs, [coordinatetransform]);
        }
        else Thgpv = movemesh(Thg, [coordinatetransform]);
        fespace XMhgpv(Thgpv, Pk);
        XMhgpv defu(ugr);
        ugr[] = qpv;
        savevtk(workdir + basefileout + "_base.vtu", Thgpv, paraviewu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro savemode(modefileout, statsfile, basefile, meshfile, evecs, evals, sym, saveflag){
  if(mpirank == 0){
    cout << "\teval(s) = [" + evals(0);
    for (int kk = 1; kk < evals.n; ++kk) cout << ", " + evals(kk);
    cout << "]";
    if(sym.n > 0) cout << ", sym = " + listsym(sym);
    if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != "") {
    cout << "  Saving " + evals.n + " eigenvalues to '" + statsfile + ".mode.stat' in '" + workdir + "'." << endl;
    for (int ii = 0; ii < evals.n; ++ii){
      ofstream file(workdir + statsfile + ".mode.stat", append);
      file.precision(17);
      file << basefile << "\t" << meshfile << "\t" << evals(ii);
      if(sym.n > 0) file << "\t" << listsym(sym);
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
      }
    }
  if(saveflag && modefileout != ""){
    XMhg<complex> defu(cplxu), defu(umg);
    for (int ii = 0; ii < evals.n; ++ii){
      um[] = evecs[ii][];
      cplxu[](restu) = um[];
      mpiAllReduce(cplxu[], umg[], mpiCommWorld, mpiSUM);
      string modefileout0 = modefileout + ((ii > 0) ? ("_" + ii) : "");
      if (mpirank == 0){
        cout << "  Saving '" + modefileout0 + ".mode' over '" + basefile + "' on '" + meshfile + "' in '" + workdir + "'." << endl;
        {
          ofstream file(workdir + modefileout0 + ".mode", binary);
          file.precision(17);
          file << "mesh\t" << meshfile << endl;
          file << "file\t" << basefile << endl;
          file << "eval\t" << evals(ii) << endl;
          if(sym.n > 0) file << "sym\t" << listsym(sym) << endl;
          if(paramnames[0] != ""){
            for (int k = 0; k < paramnames.n; ++k){
              file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
            }
          }
          if(monitornames[0] != ""){
            for (int k = 0; k < monitornames.n; ++k){
              file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
            }
          }
          file << umg[] << endl;
        }
        if (paraviewflag > 0){
          cout << "  Saving '" + modefileout0 + "_mode.vtu' in '" + workdir + "'." << endl;
          meshN Thgpv;
          complex[int] qpv = umg[];
          if (paraviewflag > 1){
            meshN Thgs = trunc(Thg, 1, split = paraviewflag);
            fespace XMhs(Thgs, Pk);
            XMhs<complex> defu(us) = defu(umg);
            qpv.resize(us[].n);
            qpv = us[];
            Thgpv = movemesh(Thgs, [coordinatetransform]);
          }
          else Thgpv = movemesh(Thg, [coordinatetransform]);
          fespace XMhgpv(Thgpv, Pk);
          XMhgpv defu(ugr), defu(ugi);
          ugr[] = qpv.re;
          ugi[] = qpv.im;
          savevtk(workdir + modefileout0 + "_mode.vtu", Thgpv, paraviewu(ugr), paraviewu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        }
      }
    }
  }
}//EOM

macro saveresp(respfileout, statsfile, basefile, meshfile, sym, omega, saveflag, monitorflag){
  IFMACRO(getmonitors)
    XMhg defu(tempu), defu(ubg);
    XMhg<complex> defu(cplxu), defu(umg), defu(umag);
    tempu[](restu) = ub[];
    mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    cplxu[](restu) = um[];
    mpiAllReduce(cplxu[], umg[], mpiCommWorld, mpiSUM);
    if(monitorflag) getmonitors;
  ENDIFMACRO
  if(mpirank == 0 && monitorflag){
    cout << "\tomega = " + omega;
    if(sym.n > 0) cout << ", sym = " + listsym(sym);
    if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != "") {
    cout << "  Saving solution stats to '" + statsfile + ".resp.stat' in '" + workdir + "'." << endl;
    {
      ofstream file(workdir + statsfile + ".resp.stat", append);
      file.precision(17);
      file << basefile << "\t" << meshfile << "\t" << omega;
      if(sym.n > 0) file << "\t" << listsym(sym);
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && respfileout != ""){
    IFMACRO(!getmonitors) 
      XMhg<complex> defu(cplxu), defu(umg), defu(umag);
      cplxu[](restu) = um[];
      mpiAllReduce(cplxu[], umg[], mpiCommWorld, mpiSUM);
    ENDIFMACRO
    if (mpirank == 0){
      cout << "  Saving '" + respfileout + ".resp' over '" + basefile + "' on '" + meshfile + "' in '" + workdir + "'." << endl;
      {
        ofstream file(workdir + respfileout + ".resp", binary);
        file.precision(17);
        file << "mesh\t" << meshfile << endl;
        file << "file\t" << basefile << endl;
        file << "omega\t" << omega << endl;
        if(sym.n > 0) file << "sym\t" << listsym(sym) << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
          }
        }
        file << umg[] << endl;
      }
      if (paraviewflag > 0){
        cout << "  Saving '" + respfileout + "_resp.vtu' in '" + workdir + "'." << endl;
        meshN Thgpv;
        complex[int] qpv = umg[];
        if (paraviewflag > 1){
          meshN Thgs = trunc(Thg, 1, split = paraviewflag);
          fespace XMhs(Thgs, Pk);
          XMhs<complex> defu(us) = defu(umg);
          qpv.resize(us[].n);
          qpv = us[];
          Thgpv = movemesh(Thgs, [coordinatetransform]);
        }
        else Thgpv = movemesh(Thg, [coordinatetransform]);
        fespace XMhgpv(Thgpv, Pk);
        XMhgpv defu(ugr), defu(ugi);
        ugr[] = qpv.re;
        ugi[] = qpv.im;
        savevtk(workdir + respfileout + "_resp.vtu", Thgpv, paraviewu(ugr), paraviewu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
      }
    }
  }
}//EOM

macro saverslv(rslvfileout, statsfile, basefile, meshfile, fvecs, uvecs, gains, sym, omega, saveflag){
  if(mpirank == 0){
    cout << "\tomega = " + omega + ", gain(s) = [" + gains(0);
    for (int kk = 1; kk < gains.n; ++kk) cout << ", " + gains(kk);
    cout << "]";
    if(sym.n > 0) cout << ", sym = " + listsym(sym);
    if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != "") {
    cout << "  Saving " + gains.n + " optimal gain(s) to '" + statsfile + ".rslv.stat' in '" + workdir + "'." << endl;
    for (int kk = 0; kk < gains.n; ++kk){
      ofstream file(workdir + statsfile + ".rslv.stat", append);
      file.precision(17);
      file << basefile << "\t" << meshfile << "\t" << omega << "\t" << gains(kk);
      if(sym.n > 0) file << "\t" << listsym(sym);
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file <<  "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && rslvfileout != ""){
    Xhg<complex> deff(tempf), deff(fmg);
    XMhg<complex> defu(tempu), defu(umg);
    for (int ii = 0; ii < gains.n; ++ii){
      fm[] = fvecs[ii][];
      um[] = uvecs[ii][];
      tempu[](restu) = um[];
      mpiAllReduce(tempu[], umg[], mpiCommWorld, mpiSUM);
      tempf[](restf) = fm[];
      mpiAllReduce(tempf[], fmg[], mpiCommWorld, mpiSUM);
      string fileout = rslvfileout + ((ii > 0) ? ("_" + ii) : "");
      if (mpirank == 0){
        cout << "  Saving '" + fileout + ".rslv' over '" + basefile + "' on '" + meshfile + "' in '" + workdir + "'." << endl;
        {
          ofstream file(workdir + fileout + ".rslv", binary);
          file.precision(17);
          file << "mesh\t" << meshfile << endl;
          file << "file\t" << basefile << endl;
          file << "omega\t" << omega << endl;
          file << "gain\t" << gains(ii) << endl;
          if(sym.n > 0) file << "sym\t" << listsym(sym) << endl;
          if(paramnames[0] != ""){
            for (int k = 0; k < paramnames.n; ++k){
              file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
            }
          }
          if(monitornames[0] != ""){
            for (int k = 0; k < monitornames.n; ++k){
              file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
            }
          }
          file << fmg[] << endl;
          file << umg[] << endl;
        }
        if (paraviewflag > 0){
          cout << "  Saving '" + fileout + "_rslv_[forcing,response].vtu' in '" + workdir + "'." << endl;
          meshN Thgpv;
          complex[int] fpv = fmg[], qpv = umg[];
          if (paraviewflag > 1){
            meshN Thgs = trunc(Thg, 1, split = paraviewflag);
            fespace Xhs(Thgs, Pkf);
            Xhs<complex> deff(fs) = deff(fmg);
            fpv.resize(fs[].n);
            fpv = fs[];
            fespace XMhs(Thgs, Pk);
            XMhs<complex> defu(us) = defu(umg);
            qpv.resize(us[].n);
            qpv = us[];
            Thgpv = movemesh(Thgs, [coordinatetransform]);
          }
          else Thgpv = movemesh(Thg, [coordinatetransform]);
          fespace Xhgpv(Thgpv, Pkf);
          Xhgpv deff(fgr), deff(fgi);
          fgr[] = fpv.re;
          fgi[] = fpv.im;
          savevtk(workdir + fileout + "_rslv_forcing.vtu", Thgpv, paraviewf(fgr), paraviewf(fgi), dataname = ParaviewDataNamefc, order = ParaviewOrderfc);
          fespace XMhgpv(Thgpv, Pk);
          XMhgpv defu(ugr), defu(ugi);
          ugi[] = qpv.im;
          ugr[] = qpv.re;
          savevtk(workdir + fileout + "_rslv_response.vtu", Thgpv, paraviewu(ugr), paraviewu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        }
      }
    }
  }
}//EOM

macro savefold(foldfileout, statsfile, meshfile, alpha, beta, saveflag, monitorflag){
  IFMACRO(getmonitors)
    XMhg defu(tempu), defu(ubg), defu(umg), defu(umag);
    tempu[](restu) = ub[];
    mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    tempu[](restu) = um[];
    mpiAllReduce(tempu[], umg[], mpiCommWorld, mpiSUM);
    tempu[](restu) = uma[];
    mpiAllReduce(tempu[], umag[], mpiCommWorld, mpiSUM);
    if(monitorflag) getmonitors;
  ENDIFMACRO
  if(mpirank == 0 && monitorflag){
    cout << "\t";
    if(paramnames[0] != ""){
      for (int k = 0; k < paramnames.n; ++k){
        cout << "alpha[" + paramnames[k] + "] = " + alpha[paramnames[k]] + ", ";
      }
    }
    cout << "beta = " + beta;
    if(paramnames[0] != "") cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if (mpirank == 0 && statsfile != "") {
    cout << "  Saving solution stats to '" + statsfile + ".fold.stat' in '" + workdir + "'." << endl;
    string dummy = foldfileout;
    {
      ofstream file(workdir + statsfile + ".fold.stat", append);
      file.precision(17);
      file << foldfileout + ((dummy.rfind(".") > 0) ? "" : ".fold") << "\t" << meshfile;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << alpha[paramnames[k]];
        }
      }
      file << "\t" << beta;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if (saveflag && foldfileout != ""){
    IFMACRO(!getmonitors)
      XMhg defu(tempu), defu(ubg), defu(umg), defu(umag);
      tempu[](restu) = ub[];
      mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
      tempu[](restu) = um[];
      mpiAllReduce(tempu[], umg[], mpiCommWorld, mpiSUM);
      tempu[](restu) = uma[];
      mpiAllReduce(tempu[], umag[], mpiCommWorld, mpiSUM);
    ENDIFMACRO
    if(mpirank == 0){
      cout << "  Saving '" + foldfileout + ".fold' on '" + meshfile + "' in '" + workdir + "'." << endl;
      {
        ofstream file(workdir + foldfileout + ".fold", binary);
        file.precision(17);
        file << "mesh\t" << meshfile << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << "alpha[" + paramnames[k] + "]\t" << alpha[paramnames[k]] << endl;
          }
        }
        file << "beta\t" << beta << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
          }
        }
        file << ubg[] << endl;
        file << umg[] << endl;
        file << umag[] << endl;
      }
      if (paraviewflag > 0){
        cout << "  Saving '" + foldfileout + "_fold_[base,dirmode,adjmode].vtu' in '" + workdir + "'." << endl;
        meshN Thgpv;
        real[int] qpv = ubg[], qmpv = umg[], qmapv = umag[];
        if (paraviewflag > 1){
          meshN Thgs = trunc(Thg, 1, split = paraviewflag);
          fespace XMhs(Thgs, Pk);
          XMhs defu(us) = defu(ubg);
          qpv.resize(us[].n);
          qmpv.resize(us[].n);
          qmapv.resize(us[].n);
          qpv = us[];
          defu(us) = defu(umg);
          qmpv = us[];
          defu(us) = defu(umag);
          qmapv = us[];
          Thgpv = movemesh(Thgs, [coordinatetransform]);
        }
        else Thgpv = movemesh(Thg, [coordinatetransform]);
        fespace XMhgpv(Thgpv, Pk);
        XMhgpv defu(ugr);
        ugr[] = qpv;
        savevtk(workdir + foldfileout + "_fold_base.vtu", Thgpv, paraviewu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
        ugr[] = qmpv;
        savevtk(workdir + foldfileout + "_fold_dirmode.vtu", Thgpv, paraviewu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
        ugr[] = qmapv;
        savevtk(workdir + foldfileout + "_fold_adjmode.vtu", Thgpv, paraviewu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro savehopf(hopffileout, statsfile, meshfile, sym, omega, alpha, beta, saveflag, monitorflag){
  IFMACRO(getmonitors) 
    XMhg defu(tempu), defu(ubg);
    tempu[](restu) = ub[].re;
    mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    XMhg<complex> defu(cplxu), defu(umg), defu(umag);
    cplxu[](restu) = um[];
    mpiAllReduce(cplxu[], umg[], mpiCommWorld, mpiSUM);
    cplxu[](restu) = uma[];
    mpiAllReduce(cplxu[], umag[], mpiCommWorld, mpiSUM);
    if(monitorflag) getmonitors;
  ENDIFMACRO
  if(mpirank == 0 && monitorflag){
    cout << "\tomega = " + omega;
    if(sym.n > 0) cout << ", sym = " + listsym(sym);
    if(paramnames[0] != ""){
      for (int k = 0; k < paramnames.n; ++k){
        cout << ", alpha[" + paramnames[k] + "] = " + alpha[paramnames[k]];
      }
    }
    cout << ", beta = " + beta;
    if(paramnames[0] != "" ) cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != ""){
    cout << "  Saving solution stats to '" + statsfile + ".hopf.stat' in '" + workdir + "'." << endl;
    string dummy = hopffileout;
    {
      ofstream file(workdir + statsfile + ".hopf.stat", append);
      file.precision(17);
      file << hopffileout + ((dummy.rfind(".") > 0) ? "" : ".hopf") << "\t" << meshfile << "\t" << omega;
      if(sym.n > 0) file << "\t" << listsym(sym);
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << alpha[paramnames[k]];
        }
      }
      file << "\t" << beta;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && hopffileout != ""){
    IFMACRO(!getmonitors)
      XMhg defu(tempu), defu(ubg);
      tempu[](restu) = ub[].re;
      mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
      XMhg<complex> defu(cplxu), defu(umg), defu(umag);
      cplxu[](restu) = um[];
      mpiAllReduce(cplxu[], umg[], mpiCommWorld, mpiSUM);
      cplxu[](restu) = uma[];
      mpiAllReduce(cplxu[], umag[], mpiCommWorld, mpiSUM);
    ENDIFMACRO
    if(mpirank == 0){
      cout << "  Saving '" + hopffileout + ".hopf' on '" + meshfile + "' in '" + workdir + "'." << endl;
      {
        ofstream file(workdir + hopffileout + ".hopf", binary);
        file.precision(17);
        file << "mesh\t" << meshfile << endl;
        file << "omega\t" << omega << endl;
        if(sym.n > 0) file << "sym\t" << listsym(sym) << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << "alpha[" + paramnames[k] + "]\t" << alpha[paramnames[k]] << endl;
          }
        }
        file << "beta\t" << beta << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
          }
        }
        file << ubg[] << endl;
        file << umg[] << endl;
        file << umag[] << endl;
      }
      if (paraviewflag > 0){
        cout << "  Saving '" + hopffileout + "_hopf_[base,dirmode,adjmode].vtu' in '" + workdir + "'." << endl;
        meshN Thgpv;
        real[int] qpv = ubg[];
        complex[int] qmpv = umg[], qmapv = umag[];
        if (paraviewflag > 1){
          meshN Thgs = trunc(Thg, 1, split = paraviewflag);
          fespace XMhs(Thgs, Pk);
          XMhs defu(us) = defu(ubg);
          XMhs<complex> defu(ums) = defu(umg);
          qpv.resize(us[].n);
          qmpv.resize(ums[].n);
          qmapv.resize(ums[].n);
          qpv = us[];
          qmpv = ums[];
          defu(ums) = defu(umag);
          qmapv = ums[];
          Thgpv = movemesh(Thgs, [coordinatetransform]);
        }
        else Thgpv = movemesh(Thg, [coordinatetransform]);
        fespace XMhgpv(Thgpv, Pk);
        XMhgpv defu(ugr), defu(ugi);
        ugr[] = qpv;
        savevtk(workdir + hopffileout + "_hopf_base.vtu", Thgpv, paraviewu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
        ugr[] = qmpv.re;
        ugi[] = qmpv.im;
        savevtk(workdir + hopffileout + "_hopf_dirmode.vtu", Thgpv, paraviewu(ugr), paraviewu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ugr[] = qmapv.re;
        ugi[] = qmapv.im;
        savevtk(workdir + hopffileout + "_hopf_adjmode.vtu", Thgpv, paraviewu(ugr), paraviewu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
      }
    }
  }
}//EOM

macro savetdls(tdlsfileout, statsfile, meshfile, basefile, ICfile, sym, time, saveflag){
  if(mpirank == 0){
    cout << "\ttime = " + time;
    if(sym.n > 0) cout << ", sym = " + listsym(sym);
    if(paramnames[0] != "") cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != "") {
    cout << "  Saving solution stats to '" + statsfile + ".tdls.stat' in '" + workdir + "'." << endl;
    string dummy = tdlsfileout;
    {
      ofstream file(workdir + statsfile + ".tdls.stat", append);
      file.precision(17);
      file << tdlsfileout + ((dummy.rfind(".") > 0) ? "" : ".tdls") << "\t" << meshfile << "\t" << basefile << "\t" << ICfile << "\t" << time;
      if(sym.n > 0) file << "\t" << listsym(sym);
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && tdlsfileout != ""){
    XMhg<PetscScalar> defu(tempu), defu(umg);
    tempu[](restu) = um[];
    mpiAllReduce(tempu[], umg[], mpiCommWorld, mpiSUM);
    if(mpirank == 0){
      cout << "  Saving '" + tdlsfileout + ".tdls' on '" + meshfile + "' in '" + workdir + "'." << endl;
      {
        ofstream file(workdir + tdlsfileout + ".tdls", binary);
        file.precision(17);
        file << "mesh\t" << meshfile << endl;
        file << "base\t" << basefile << endl;
        file << "init\t" << ICfile << endl;
        file << "time\t" << time << endl;
        if(sym.n > 0) file << "sym\t" << listsym(sym) << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
          }
        }
        file << umg[] << endl;
      }
      if (paraviewflag > 0){
        cout << "  Saving '" + tdlsfileout + "_tdls.vtu' in '" + workdir + "'." << endl;
        meshN Thgpv;
        complex[int] qpv = umg[];
        if (paraviewflag > 1){
          meshN Thgs = trunc(Thg, 1, split = paraviewflag);
          fespace XMhs(Thgs, Pk);
          XMhs<complex> defu(us) = defu(umg);
          qpv.resize(us[].n);
          qpv = us[];
          Thgpv = movemesh(Thgs, [coordinatetransform]);
        }
        else Thgpv = movemesh(Thg, [coordinatetransform]);
        fespace XMhgpv(Thgpv, Pk);
        XMhgpv defu(ugr), defu(ugi);
        ugr[] = qpv.re;
        ugi[] = qpv.im;
        savevtk(workdir + tdlsfileout + "_tdls.vtu", Thgpv, paraviewu(ugr), paraviewu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
      }
    }
  }
}//EOM

macro savetdns(tdnsfileout, statsfile, meshfile, ICfile, time, saveflag, monitorflag){
  IFMACRO(getmonitors)
    XMhg defu(tempu), defu(ubg), defu(umg), defu(umag);
    tempu[](restu) = ub[];
    mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    if(monitorflag) getmonitors;
  ENDIFMACRO
  if(mpirank == 0 && monitorflag){
    cout << "\ttime = " + time;
    if(paramnames[0] != "") cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != "") {
    cout << "  Saving solution stats to '" + statsfile + ".tdns.stat' in '" + workdir + "'." << endl;
    string dummy = tdnsfileout;
    {
      ofstream file(workdir + statsfile + ".tdns.stat", append);
      file.precision(17);
      file << tdnsfileout + ((dummy.rfind(".") > 0) ? "" : ".tdns") << "\t" << meshfile << "\t" << ICfile << "\t" << time;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && tdnsfileout != ""){
    IFMACRO(!getmonitors)
      XMhg defu(tempu), defu(ubg), defu(umg), defu(umag);
      tempu[](restu) = ub[];
      mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    ENDIFMACRO
    if(mpirank == 0){
      cout << "  Saving '" + tdnsfileout + ".tdns' on '" + meshfile + "' in '" + workdir + "'." << endl;
      {
        ofstream file(workdir + tdnsfileout + ".tdns", binary);
        file.precision(17);
        file << "mesh\t" << meshfile << endl;
        file << "init\t" << ICfile << endl;
        file << "time\t" << time << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
          }
        }
        file << ubg[] << endl;
      }
      if (paraviewflag > 0){
        cout << "  Saving '" + tdnsfileout + "_tdns.vtu' in '" + workdir + "'." << endl;
        meshN Thgpv;
        real[int] qpv = ubg[];
        if (paraviewflag > 1){
          meshN Thgs = trunc(Thg, 1, split = paraviewflag);
          fespace XMhs(Thgs, Pk);
          XMhs defu(us) = defu(ubg);
          qpv.resize(us[].n);
          qpv = us[];
          Thgpv = movemesh(Thgs, [coordinatetransform]);
        }
        else Thgpv = movemesh(Thg, [coordinatetransform]);
        fespace XMhgpv(Thgpv, Pk);
        XMhgpv defu(ugr);
        ugr[] = qpv;
        savevtk(workdir + tdnsfileout + "_tdns.vtu", Thgpv, paraviewu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro savehoho(hohofileout, statsfile, meshfile, sym1, sym2, omega1, omega2, alpha1, alpha2, beta1, beta2, gamma1, gamma2, gamma12, gamma13, gamma22, gamma23, saveflag, monitorflag){
  IFMACRO(getmonitors)
    XMhg defu(tempu), defu(ubg), defu(umg), defu(umag);
    tempu[](restu) = ub[].re;
    mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    XMhg<complex> defu(cplxu), defu(u1mg), defu(u1mag), defu(u2mg), defu(u2mag);
    cplxu[](restu) = um[];
    mpiAllReduce(cplxu[], u1mg[], mpiCommWorld, mpiSUM);
    cplxu[](restu) = uma[];
    mpiAllReduce(cplxu[], u1mag[], mpiCommWorld, mpiSUM);
    cplxu[](restu) = um2[];
    mpiAllReduce(cplxu[], u2mg[], mpiCommWorld, mpiSUM);
    cplxu[](restu) = um3[];
    mpiAllReduce(cplxu[], u2mag[], mpiCommWorld, mpiSUM);
    if(monitorflag) getmonitors;
  ENDIFMACRO
  if(mpirank == 0 && monitorflag){
    cout << "\tomega = [" + omega1 + "; " + omega2;
    if(sym.n > 0) cout << "], sym = [" + listsym(sym1) + "; " + listsym(sym2);
    if(paramnames[0] != ""){
      for (int k = 0; k < paramnames.n; ++k){
        cout << "], alpha[" + paramnames[k] + "] = [" + alpha1[paramnames[k]] + "; " + alpha2[paramnames[k]];
      }
    }
    cout << "], beta = [" + beta1 + "; " + beta2 << "], gamma = [" + gamma1 + "," + gamma12 + "," + gamma13 + "; " + gamma2 + "," + gamma22 + "," + gamma23 +  "]";
    if(paramnames[0] != "" ) cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != ""){
    cout << "  Saving solution stats to '" + statsfile + ".hoho.stat' in '" + workdir + "'." << endl;
    string dummy = hohofileout;
    {
      ofstream file(workdir + statsfile + ".hoho.stat", append);
      file.precision(17);
      file << hohofileout + ((dummy.rfind(".") > 0) ? "" : ".hoho") << "\t" << meshfile << "\t" << omega1 << "\t" << omega2;
      if(sym.n > 0) file << listsym(sym1) << "\t" << listsym(sym2) << "\t";
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << alpha1[paramnames[k]] << "\t" << alpha2[paramnames[k]];
        }
      }
      file << "\t" << beta1 << "\t" << beta2 << "\t" << gamma1 << "\t" << gamma2 << "\t" << gamma12 << "\t" << gamma13 << "\t" << gamma22 << "\t" << gamma23;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && hohofileout != ""){
    IFMACRO(!getmonitors)
      XMhg defu(tempu), defu(ubg), defu(umg), defu(umag);
      tempu[](restu) = ub[].re;
      mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
      XMhg<complex> defu(cplxu), defu(u1mg), defu(u1mag), defu(u2mg), defu(u2mag);
      cplxu[](restu) = um[];
      mpiAllReduce(cplxu[], u1mg[], mpiCommWorld, mpiSUM);
      cplxu[](restu) = uma[];
      mpiAllReduce(cplxu[], u1mag[], mpiCommWorld, mpiSUM);
      cplxu[](restu) = um2[];
      mpiAllReduce(cplxu[], u2mg[], mpiCommWorld, mpiSUM);
      cplxu[](restu) = um3[];
      mpiAllReduce(cplxu[], u2mag[], mpiCommWorld, mpiSUM);
    ENDIFMACRO
    if(mpirank == 0){
      cout << "  Saving '" + hohofileout + ".hoho' on '" + meshfile + "' in '" + workdir + "'." << endl;
      {
        ofstream file(workdir + hohofileout + ".hoho", binary);
        file.precision(17);
        file << "mesh\t" << meshfile << endl;
        file << "omega\t" << omega1 << "\t" << omega2 << endl;
        if(sym.n > 0) file << "sym\t" << listsym(sym1) << "\t" << listsym(sym2) << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << "alpha[" + paramnames[k] + "]\t" << alpha1[paramnames[k]] << "\t" << alpha2[paramnames[k]] << endl;
          }
        }
        file << "beta\t" << beta1 << "\t" << beta2 << endl;
        file << "gamma\t" << gamma1 << "\t" << gamma12 << "\t" << gamma13 << "\t" << gamma2 << "\t" << gamma22 << "\t" << gamma23 << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
          }
        }
        file << ubg[] << endl;
        file << u1mg[] << endl;
        file << u1mag[] << endl;
        file << u2mg[] << endl;
        file << u2mag[] << endl;
      }
      if (paraviewflag > 0){
        cout << "  Saving '" + hohofileout + "_hoho_[base,dirmode1,adjmode1,dirmode2,adjmode2].vtu' in '" + workdir + "'." << endl;
        meshN Thgpv;
        real[int] qpv = ubg[];
        complex[int] q1mpv = u1mg[], q1mapv = u1mag[], q2mpv = u2mg[], q2mapv = u2mag[];
        if (paraviewflag > 1){
          meshN Thgs = trunc(Thg, 1, split = paraviewflag);
          fespace XMhs(Thgs, Pk);
          XMhs defu(us) = defu(ubg);
          XMhs<complex> defu(ums) = defu(u1mg);
          qpv.resize(us[].n);
          q1mpv.resize(ums[].n);
          q1mapv.resize(ums[].n);
          q2mpv.resize(ums[].n);
          q2mapv.resize(ums[].n);
          qpv = us[];
          q1mpv = ums[];
          defu(ums) = defu(u1mag);
          q1mapv = ums[];
          defu(ums) = defu(u2mg);
          q2mpv = ums[];
          defu(ums) = defu(u2mag);
          q2mapv = ums[];
          Thgpv = movemesh(Thgs, [coordinatetransform]);
        }
        else Thgpv = movemesh(Thg, [coordinatetransform]);
        fespace XMhgpv(Thgpv, Pk);
        XMhgpv defu(ugr), defu(ugi);
        ugr[] = qpv;
        savevtk(workdir + hohofileout + "_hoho_base.vtu", Thgpv, paraviewu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
        ugr[] = q1mpv.re;
        ugi[] = q1mpv.im;
        savevtk(workdir + hohofileout + "_hoho_dirmode1.vtu", Thgpv, paraviewu(ugr), paraviewu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ugr[] = q1mapv.re;
        ugi[] = q1mapv.im;
        savevtk(workdir + hohofileout + "_hoho_adjmode1.vtu", Thgpv, paraviewu(ugr), paraviewu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ugr[] = q2mpv.re;
        ugi[] = q2mpv.im;
        savevtk(workdir + hohofileout + "_hoho_dirmode2.vtu", Thgpv, paraviewu(ugr), paraviewu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ugr[] = q2mapv.re;
        ugi[] = q2mapv.im;
        savevtk(workdir + hohofileout + "_hoho_adjmode2.vtu", Thgpv, paraviewu(ugr), paraviewu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
      }
    }
  }
}//EOM

macro savefoho(fohofileout, statsfile, meshfile, sym, omega, alpha1, alpha2, beta1, beta22, beta23, gamma12, gamma13, gamma22, gamma23, saveflag, monitorflag){
  IFMACRO(getmonitors)
    XMhg defu(tempu), defu(ubg), defu(umg), defu(umag), defu(u2mg), defu(u2mag);
    tempu[](restu) = ub[].re;
    mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    XMhg<complex> defu(cplxu), defu(u1mg), defu(u1mag);
    cplxu[](restu) = um[];
    mpiAllReduce(cplxu[], u1mg[], mpiCommWorld, mpiSUM);
    cplxu[](restu) = uma[];
    mpiAllReduce(cplxu[], u1mag[], mpiCommWorld, mpiSUM);
    tempu[](restu) = um2[].re;
    mpiAllReduce(tempu[], u2mg[], mpiCommWorld, mpiSUM);
    tempu[](restu) = um3[].re;
    mpiAllReduce(tempu[], u2mag[], mpiCommWorld, mpiSUM);
    if(monitorflag) getmonitors;
  ENDIFMACRO
  if(mpirank == 0 && monitorflag){
    cout << "\tomega = " + omega;
    if(sym.n > 0) cout << ", sym = " + listsym(sym);
    if(paramnames[0] != ""){
      for (int k = 0; k < paramnames.n; ++k){
        cout << ", alpha[" + paramnames[k] + "] = [" + alpha1[paramnames[k]] + "; " + alpha2[paramnames[k]] + "]";
      }
    }
    cout << ", beta = [" + beta1 + "; " + beta22 + ", " + beta23 << "], gamma = [" + gamma12 + ", " + gamma13 + "; " + gamma22 + ", " + gamma23 + "]";
    if(paramnames[0] != "" ) cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != ""){
    cout << "  Saving solution stats to '" + statsfile + ".foho.stat' in '" + workdir + "'." << endl;
    string dummy = fohofileout;
    {
      ofstream file(workdir + statsfile + ".foho.stat", append);
      file.precision(17);
      file << fohofileout + ((dummy.rfind(".") > 0) ? "" : ".hoho") << "\t" << meshfile << "\t" << omega;
      if(sym.n > 0) file << "\t" << listsym(sym);
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << alpha1[paramnames[k]] << "\t" << alpha2[paramnames[k]];
        }
      }
      file << "\t" << beta1 << "\t" << beta22 << "\t" << beta23 << "\t" << gamma12 << "\t" << gamma13 << "\t" << gamma22 << "\t" << gamma23;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && fohofileout != ""){
    IFMACRO(!getmonitors)
      XMhg defu(tempu), defu(ubg), defu(umg), defu(umag), defu(u2mg), defu(u2mag);
      tempu[](restu) = ub[].re;
      mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
      XMhg<complex> defu(cplxu), defu(u1mg), defu(u1mag);
      cplxu[](restu) = um[];
      mpiAllReduce(cplxu[], u1mg[], mpiCommWorld, mpiSUM);
      cplxu[](restu) = uma[];
      mpiAllReduce(cplxu[], u1mag[], mpiCommWorld, mpiSUM);
      tempu[](restu) = um2[].re;
      mpiAllReduce(tempu[], u2mg[], mpiCommWorld, mpiSUM);
      tempu[](restu) = um3[].re;
      mpiAllReduce(tempu[], u2mag[], mpiCommWorld, mpiSUM);
    ENDIFMACRO
    if(mpirank == 0){
      cout << "  Saving '" + fohofileout + ".foho' on '" + meshfile + "' in '" + workdir + "'." << endl;
      {
        ofstream file(workdir + fohofileout + ".foho", binary);
        file.precision(17);
        file << "mesh\t" << meshfile << endl;
        file << "omega\t" << omega << endl;
        if(sym.n > 0) file << "sym\t" << listsym(sym) << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << "alpha[" + paramnames[k] + "]\t" << alpha1[paramnames[k]] << "\t" << alpha2[paramnames[k]] << endl;
          }
        }
        file << "beta\t" << beta1 << "\t" << beta22 << "\t" << beta23 << endl;
        file << "gamma\t" << gamma12 << "\t" << gamma13 << "\t" << gamma22 << "\t" << gamma23 << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
          }
        }
        file << ubg[] << endl;
        file << u1mg[] << endl;
        file << u1mag[] << endl;
        file << u2mg[] << endl;
        file << u2mag[] << endl;
      }
      if (paraviewflag > 0){
        cout << "  Saving '" + fohofileout + "_foho_[base,dirmode1,adjmode1,dirmode2,adjmode2].vtu' in '" + workdir + "'." << endl;
        meshN Thgpv;
        real[int] qpv = ubg[], q2mpv = u2mg[], q2mapv = u2mag[];
        complex[int] q1mpv = u1mg[], q1mapv = u1mag[];
        if (paraviewflag > 1){
          meshN Thgs = trunc(Thg, 1, split = paraviewflag);
          fespace XMhs(Thgs, Pk);
          XMhs defu(us) = defu(ubg);
          XMhs<complex> defu(ums) = defu(u1mg);
          qpv.resize(us[].n);
          q1mpv.resize(ums[].n);
          q1mapv.resize(ums[].n);
          q2mpv.resize(us[].n);
          q2mapv.resize(us[].n);
          qpv = us[];
          q1mpv = ums[];
          defu(ums) = defu(u1mag);
          q1mapv = ums[];
          defu(us) = defu(u2mg);
          q2mpv = us[];
          defu(us) = defu(u2mag);
          q2mapv = us[];
          Thgpv = movemesh(Thgs, [coordinatetransform]);
        }
        else Thgpv = movemesh(Thg, [coordinatetransform]);
        fespace XMhgpv(Thgpv, Pk);
        XMhgpv defu(ugr), defu(ugi);
        ugr[] = qpv;
        savevtk(workdir + fohofileout + "_foho_base.vtu", Thgpv, paraviewu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
        ugr[] = q1mpv.re;
        ugi[] = q1mpv.im;
        savevtk(workdir + fohofileout + "_foho_dirmode1.vtu", Thgpv, paraviewu(ugr), paraviewu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ugr[] = q1mapv.re;
        ugi[] = q1mapv.im;
        savevtk(workdir + fohofileout + "_foho_adjmode1.vtu", Thgpv, paraviewu(ugr), paraviewu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ugr[] = q2mpv;
        savevtk(workdir + fohofileout + "_foho_dirmode2.vtu", Thgpv, paraviewu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
        ugr[] = q2mapv;
        savevtk(workdir + fohofileout + "_foho_adjmode2.vtu", Thgpv, paraviewu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro saveporb(porbfileout, statsfile, meshfile, sym, omega, Nh, saveflag, monitorflag){
  IFMACRO(getmonitors)
    XMhg defu(tempu), defu(ubg);
    tempu[](restu) = ub[];
    mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    XMhg<complex> defu(cplxu), defu(umg), defu(umag);
    complex[int, int] uhg(ubg[].n, Nh);
    for(int nh = 0; nh < Nh; nh++){
      cplxu[](restu) = uh(:, nh);
      mpiAllReduce(cplxu[], uhg(:, nh), mpiCommWorld, mpiSUM);
      umg[] += uhg(:, nh);
    }
    if(monitorflag) getmonitors;
  ENDIFMACRO
  if(mpirank == 0 && monitorflag){
    cout << "\tomega = " + omega + ", Nh = " + Nh;
    if(sym.n > 0) cout << ", sym = " + listsym(sym);
    if(paramnames[0] != "" ) cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != ""){
    cout << "  Saving solution stats to '" + statsfile + ".porb.stat' in '" + workdir + "'." << endl;
    string dummy = porbfileout;
    {
      ofstream file(workdir + statsfile + ".porb.stat", append);
      file.precision(17);
      file << porbfileout + ((dummy.rfind(".") > 0) ? "" : ".porb") << "\t" << meshfile << "\t" << omega << "\t" << Nh;
      if(sym.n > 0) file << "\t" << listsym(sym);
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && porbfileout != ""){
    IFMACRO(!getmonitors)
      XMhg defu(tempu), defu(ubg);
      tempu[](restu) = ub[];
      mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
      XMhg<complex> defu(cplxu);
      complex[int, int] uhg(ubg[].n, Nh);
      for(int nh = 0; nh < Nh; nh++){
        cplxu[](restu) = uh(:, nh);
        mpiAllReduce(cplxu[], uhg(:, nh), mpiCommWorld, mpiSUM);
      }
    ENDIFMACRO
    if(mpirank == 0){
      cout << "  Saving '" + porbfileout + ".porb' on '" + meshfile + "' in '" + workdir + "'." << endl;
      {
        ofstream file(workdir + porbfileout + ".porb", binary);
        file.precision(17);
        file << "mesh\t" << meshfile << endl;
        file << "omega\t" << omega << endl;
        file << "Nh\t" << Nh << endl;
        if(sym.n > 0) file << "sym\t" << listsym(sym) << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
          }
        }
        file << ubg[] << endl;
        for(int nh = 0; nh < Nh; nh++) file << uhg(:, nh) << endl;
      }
      if (paraviewflag > 0){
        cout << "  Saving '" + porbfileout + "_porb_[mean,harm0,harm1,...].vtu' in '" + workdir + "'." << endl;
        meshN Thgpv;
        real[int] qpv = ubg[];
        complex[int, int] qmpv = uhg;
        if (paraviewflag > 1){
          meshN Thgs = trunc(Thg, 1, split = paraviewflag);
          fespace XMhs(Thgs, Pk);
          XMhs defu(us) = defu(ubg);
          XMhs<complex> defu(ums);
          qpv.resize(us[].n);
          qmpv.resize(ums[].n, uhg.m);
          for(int nh = 0; nh < Nh; nh++){
            cplxu[] = uhg(:, nh);
            defu(ums) = defu(cplxu);
            qmpv(:, nh) = ums[];
          }
          Thgpv = movemesh(Thgs, [coordinatetransform]);
        }
        else Thgpv = movemesh(Thg, [coordinatetransform]);
        fespace XMhgpv(Thgpv, Pk);
        XMhgpv defu(ugr), defu(ugi);
        XMhgpv<complex> defu(ugc);
        ugr[] = qpv;
        savevtk(workdir + porbfileout + "_porb_mean.vtu", Thgpv, paraviewu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
        for(int nh = 0; nh < Nh; nh++){
          ugc[] = qmpv(:, nh);
          ugr[] = ugc[].re;
          ugi[] = ugc[].im;
          savevtk(workdir + porbfileout + "_porb_harm" + nh + ".vtu", Thgpv, paraviewu(ugr), paraviewu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        }
      }
    }
  }
}//EOM

macro savefloq(floqfileout, statsfile, basefile, meshfile, evecs, evals, omega, Nh, sym0, sym1, saveflag){
  if(mpirank == 0){
    cout << "\teval(s) = [" + evals(0);
    for (int kk = 1; kk < evals.n; ++kk) cout << ", " + evals(kk);
    if(sym1.n > 0) cout << ", sym1 = " + listsym(sym1);
    cout << ", omega = " + omega + ", Nh = " + Nh;
    if(sym0.n > 0) cout << ", sym0 = " + listsym(sym0);
    if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != "") {
    cout << "  Saving " + evals.n + " Floquet eigenvalues to '" + statsfile + ".floq.stat' in '" + workdir + "'." << endl;
    for (int ii = 0; ii < evals.n; ++ii){
      ofstream file(workdir + statsfile + ".floq.stat", append);
      file.precision(17);
      file << basefile << "\t" << meshfile << "\t" << evals(ii);
      if(sym1.n > 0) file << "\t" << listsym(sym1);
      file << "\t" << omega << "\t" << Nh;
      if(sym0.n > 0) file << "\t" << listsym(sym0);
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
      }
    }
  if(saveflag && floqfileout != ""){
    XMhg<complex> defu(umg);
    complex[int, int] uhmg(umg[].n, 1+2*Nh);
    for (int ii = 0; ii < evals.n; ++ii){
      for (int jj = 0; jj < (1+2*Nh); ++jj) {
        um[] = evecs(jj*um[].n:(1+jj)*um[].n-1, ii);
        umg[](restu) = um[];
        mpiAllReduce(umg[], uhmg(:, jj), mpiCommWorld, mpiSUM);
      }
      string floqfileout0 = floqfileout + ((ii > 0) ? ("_" + ii) : "");
      if (mpirank == 0){
        cout << "  Saving '" + floqfileout0 + ".floq' over '" + basefile + "' on '" + meshfile + "' in '" + workdir + "'." << endl;
        {
          ofstream file(workdir + floqfileout0 + ".floq", binary);
          file.precision(17);
          file << "mesh\t" << meshfile << endl;
          file << "file\t" << basefile << endl;
          file << "eval\t" << evals(ii) << endl;
          if(sym1.n > 0) file << "sym1\t" << listsym(sym1) << endl;
          file << "omega\t" << omega << endl;
          file << "Nh\t" << Nh << endl;
          if(sym0.n > 0) file << "sym0\t" << listsym(sym0) << endl;
          if(paramnames[0] != ""){
            for (int k = 0; k < paramnames.n; ++k){
              file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
            }
          }
          if(monitornames[0] != ""){
            for (int k = 0; k < monitornames.n; ++k){
              file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
            }
          }
          for(int jj = 0; jj < (1+2*Nh); jj++) file << uhmg(:, jj) << endl;
        }
        if (paraviewflag > 0){
          cout << "  Saving '" + floqfileout0 + "_floq_[comp0,comp1,comp2,...].vtu' in '" + workdir + "'." << endl;
          meshN Thgpv;
          complex[int, int] qmpv = uhmg;
          if (paraviewflag > 1){
            meshN Thgs = trunc(Thg, 1, split = paraviewflag);
            fespace XMhs(Thgs, Pk);
            XMhs<complex> defu(ums);
            qmpv.resize(ums[].n, uhmg.m);
            for(int jj = 0; jj < (1+2*Nh); jj++){
              umg[] = uhmg(:, jj);
              defu(ums) = defu(umg);
              qmpv(:, jj) = ums[];
            }
            Thgpv = movemesh(Thgs, [coordinatetransform]);
          }
          else Thgpv = movemesh(Thg, [coordinatetransform]);
          fespace XMhgpv(Thgpv, Pk);
          XMhgpv defu(ugr), defu(ugi);
          XMhgpv<complex> defu(ugc);
          for(int jj = 0; jj < (1+2*Nh); jj++){
            ugc[] = qmpv(:, jj);
            ugr[] = ugc[].re;
            ugi[] = ugc[].im;
            savevtk(workdir + floqfileout0 + "_floq_comp" + jj + ".vtu", Thgpv, paraviewu(ugr), paraviewu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
          }
        }
      }
    }
  }
}//EOM

func string readmeshname(string inputfilename) {
  string meshfilename;
  { ifstream file(inputfilename);
    file >> meshfilename >> meshfilename;
  }
  return meshfilename;
}

func string readbasename(string inputfilename) {
  string basefilename;
  { ifstream file(inputfilename);
    file >> basefilename >> basefilename >> basefilename >> basefilename;
  }
  return basefilename;
}
func complex readmodeeval(string inputfilename, real[int] & sym) {
  complex eigenvalue;
  string dummy, symstr;
  { ifstream file(inputfilename);
    for (int k = 0; k < (paramnames.n+2); ++k){
      file >> dummy >> dummy;
    }
    file >> dummy >> eigenvalue;
    if (sym.n > 0) {
      file >> dummy >> symstr;
      sym = parsesymstr(symstr);
    }
  }
  return eigenvalue;
}


func real[int] loadbase(string inputfilename, string meshfilename) {
      XMhg defu(ubg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".base' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string filemesh;
      ifstream file(workdir + inputfilename + ".base");
      file >> filemesh >> filemesh;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        if(paramnames[0] != "" || monitornames[0] != "") cout << "\t";
        if(paramnames[0] != "") cout << listparams(paramnames, params);
        if(paramnames[0] != "" && monitornames[0] != "") cout << ", ";
        if(monitornames[0] != "") cout << listparams(monitornames, monitors);
        if(paramnames[0] != "" || monitornames[0] != "") cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1);
        file >> ubg1[];
        defu(ubg) = defu(ubg1);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      return qlocal;
    }

func real[int] loadfold(string inputfilename, string meshfilename, real[int] & qmlocal, real[int] & qmalocal, real[string] & alpha, real & beta) {
      XMhg defu(ubg), defu(umg), defu(umag);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".fold' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string dummy, filemesh;
      ifstream file(workdir + inputfilename + ".fold");
      file >> filemesh >> filemesh;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> dummy >> alpha[paramnames[k]];
        }
      }
      file >> dummy >> beta;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\t";
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            cout << "alpha[" + paramnames[k] + "] = " + alpha[paramnames[k]] + ", ";
          }
        }
        cout << "beta = " + (beta);
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        file >> umg[];
        file >> umag[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1), defu(umg1), defu(umag1);
        file >> ubg1[];
        file >> umg1[];
        file >> umag1[];
        defu(ubg) = defu(ubg1);
        defu(umg) = defu(umg1);
        defu(umag) = defu(umag1);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      qmlocal = umg[](restu);
      qmalocal = umag[](restu);
      return qlocal;
    }

func real[int] loadhopf(string inputfilename, string meshfilename, complex[int] & qmlocal, complex[int] & qmalocal, real[int] & sym, real & omega, complex[string] & alpha, complex & beta) {
      XMhg defu(ubg);
      XMhg<complex> defu(umg), defu(umag);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".hopf' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string dummy, filemesh, symstr;
      ifstream file(workdir + inputfilename + ".hopf");
      file >> dummy >> filemesh >> dummy >> omega;
      if (sym.n > 0) {
        file >> dummy >> symstr;
        sym = parsesymstr(symstr);
      }
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> dummy >> alpha[paramnames[k]];
        }
      }
      file >> dummy >> beta;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\tomega = " + omega;
        if(sym.n > 0) cout << ", sym = " + listsym(sym);
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            cout << ", alpha[" + paramnames[k] + "] = " + alpha[paramnames[k]];
          }
        }
        cout << ", beta = " + (beta);
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        file >> umg[];
        file >> umag[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1);
        XMhg1<complex> defu(umg1), defu(umag1);
        file >> ubg1[];
        file >> umg1[];
        file >> umag1[];
        defu(ubg) = defu(ubg1);
        defu(umg) = defu(umg1);
        defu(umag) = defu(umag1);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      qmlocal = umg[](restu);
      qmalocal = umag[](restu);
      return qlocal;
    }

func complex[int] loadmode(string inputfilename, string meshfilename, real[int] & sym, complex & eigenvalue) {
      XMhg<complex> defu(umg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".mode' over '";
      string filemesh, basefilename, dummy, symstr;
      ifstream file(workdir + inputfilename + ".mode");
      file >> dummy >> filemesh >> dummy >> basefilename >> dummy >> eigenvalue;
      if (sym.n > 0) {
        file >> dummy >> symstr;
        sym = parsesymstr(symstr);
      }
      if (mpirank == 0) cout << basefilename + "' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\teval = " + eigenvalue;
        if(sym.n > 0) cout << ", sym = " + listsym(sym);
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> umg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1<complex> defu(umg1);
        file >> umg1[];
        defu(umg) = defu(umg1);
      }
      setparams(paramnames, params);
      complex[int] qlocal = umg[](restu);
      return qlocal;
    }

func complex[int] loadresp(string inputfilename, string meshfilename, real[int] & sym, real & omega) {
      XMhg<complex> defu(umg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".resp' over '";
      string filemesh, basefilename, dummy, symstr;
      ifstream file(workdir + inputfilename + ".resp");
      file >> filemesh >> filemesh >> basefilename >> basefilename >> dummy >> omega;
      if (mpirank == 0) cout << basefilename + "' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      if (sym.n > 0) {
        file >> dummy >> symstr;
        sym = parsesymstr(symstr);
      }
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\tomega = " + omega;
        if(sym.n > 0) cout << ", sym = " + listsym(sym);
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> umg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1<complex> defu(umg1);
        file >> umg1[];
        defu(umg) = defu(umg1);
      }
      setparams(paramnames, params);
      complex[int] qlocal = umg[](restu);
      return qlocal;
    }

func complex[int] loadrslv(string inputfilename, string meshfilename, complex[int] & fmlocal, real[int] & sym, real & omega, real & gain) {
      Xhg<complex> deff(fmg);
      XMhg<complex> defu(umg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".rslv' over '";
      string filemesh, basefilename, dummy, symstr;
      ifstream file(workdir + inputfilename + ".rslv");
      file >> filemesh >> filemesh >> basefilename >> basefilename >> dummy >> omega >> dummy >> gain;
      if (sym.n > 0) {
        file >> dummy >> symstr;
        sym = parsesymstr(symstr);
      }
      if (mpirank == 0) cout << basefilename + "' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\tomega = " + omega + ", gain = " + gain;
        if(sym.n > 0) cout << ", sym = " + listsym(sym);
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> fmg[] >> umg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace Xhg1(Thg1, Pkf);
        Xhg1<complex> deff(fmg1);
        fespace XMhg1(Thg1, Pk);
        XMhg1<complex> defu(umg1);
        file >> fmg1[] >> umg1[];
        deff(fmg) = deff(fmg1);
        defu(umg) = defu(umg1);
      }
      setparams(paramnames, params);
      fmlocal = fmg[](restf);
      complex[int] qlocal = umg[](restu);
      return qlocal;
    }

func real[int] loadtdns(string inputfilename, string meshfilename, real& time) {
      XMhg defu(ubg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".tdns' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string filemesh, ICfile, dummy;
      ifstream file(workdir + inputfilename + ".tdns");
      file >> filemesh >> filemesh >> ICfile >> ICfile >> dummy >> time;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\ttime = " << time;
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1);
        file >> ubg1[];
        defu(ubg) = defu(ubg1);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      return qlocal;
    }

func complex[int] loadtdls(string inputfilename, string meshfilename, real[int] & sym, real& time) {
      XMhg<complex> defu(umg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".tdls' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string filemesh, basefile, ICfile, dummy, symstr;
      ifstream file(workdir + inputfilename + ".tdls");
      file >> filemesh >> filemesh >> basefile >> basefile >> ICfile >> ICfile >> dummy >> time;
      if (sym.n > 0) {
        file >> dummy >> symstr;
        sym = parsesymstr(symstr);
      }
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\ttime = " << time;
        if(sym.n > 0) cout << ", sym = " + listsym(sym);
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> umg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1<complex> defu(umg1);
        file >> umg1[];
        defu(umg) = defu(umg1);
      }
      setparams(paramnames, params);
      complex[int] qlocal = umg[](restu);
      return qlocal;
    }

func real[int] loadhoho(string inputfilename, string meshfilename, complex[int] & q1mlocal, complex[int] & q1malocal, complex[int] & q2mlocal, complex[int] & q2malocal,
                        real[int] & sym1, real[int] & sym2, real & omega1, real & omega2, complex[string] & alpha1, complex[string] & alpha2, complex & beta1, complex & beta2, complex & gamma1, complex & gamma2, complex & gamma12, complex & gamma13, complex & gamma22, complex & gamma23) {
      XMhg defu(ubg);
      XMhg<complex> defu(u1mg), defu(u1mag), defu(u2mg), defu(u2mag);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".hoho' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string dummy, filemesh, symstr1, symstr2;
      ifstream file(workdir + inputfilename + ".hoho");
      file >> dummy >> filemesh >> dummy >> omega1 >> omega2;
      if(sym.n > 0) file >> dummy >> symstr1 >> symstr2;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> dummy >> alpha1[paramnames[k]] >> alpha2[paramnames[k]];
        }
      }
      file >> dummy >> beta1 >> beta2;
      file >> dummy >> gamma1 >> gamma12 >> gamma13 >> gamma2 >> gamma22 >> gamma23;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      sym1 = parsesymstr(symstr1);
      sym2 = parsesymstr(symstr2);
      if(mpirank == 0) {
        cout << "\tomega = [" + omega1 + "; " + omega2;
        if(sym.n > 0) cout << "], sym = [" + listsym(sym1) + "; " + listsym(sym2);
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            cout << "], alpha[" + paramnames[k] + "] = [" + alpha1[paramnames[k]] + "; " + alpha2[paramnames[k]];
          }
        }
        cout << "], beta = [" + beta1 + "; " + beta2 + "], gamma = [" + gamma1 + ", " + gamma12 + ", " + gamma13 + "; " + gamma2 + ", " + gamma22 + ", " + gamma23 + "]";
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        file >> u1mg[];
        file >> u1mag[];
        file >> u2mg[];
        file >> u2mag[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg0);
        XMhg1<complex> defu(umg1), defu(umag1), defu(umg2), defu(umag2);
        file >> ubg0[];
        file >> umg1[];
        file >> umag1[];
        file >> umg2[];
        file >> umag2[];
        defu(ubg) = defu(ubg0);
        defu(u1mg) = defu(umg1);
        defu(u1mag) = defu(umag1);
        defu(u2mg) = defu(umg2);
        defu(u2mag) = defu(umag2);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      q1mlocal = u1mg[](restu);
      q1malocal = u1mag[](restu);
      q2mlocal = u2mg[](restu);
      q2malocal = u2mag[](restu);
      return qlocal;
    }

func real[int] loadfoho(string inputfilename, string meshfilename, complex[int] & q1mlocal, complex[int] & q1malocal, real[int] & q2mlocal, real[int] & q2malocal,
                        real[int] & sym, real & omega, complex[string] & alpha1, real[string] & alpha2, complex & beta1, real & beta22, real & beta23, complex & gamma12, complex & gamma13, real & gamma22, real & gamma23) {
      XMhg defu(ubg), defu(u2mg), defu(u2mag);
      XMhg<complex> defu(u1mg), defu(u1mag);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".foho' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string dummy, filemesh, symstr;
      ifstream file(workdir + inputfilename + ".foho");
      file >> dummy >> filemesh >> dummy >> omega;
      if (sym.n > 0) file >> dummy >> symstr;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> dummy >> alpha1[paramnames[k]] >> alpha2[paramnames[k]];
        }
      }
      file >> dummy >> beta1 >> beta22 >> beta23;
      file >> dummy >> gamma12 >> gamma13 >> gamma22 >> gamma23;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      sym = parsesymstr(symstr);
      if(mpirank == 0) {
        cout << "\tomega = " + omega;
        if(sym.n > 0) cout << ", sym = " + listsym(sym);
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            cout << ", alpha[" + paramnames[k] + "] = [" + alpha1[paramnames[k]] + "; " + alpha2[paramnames[k]] + "]";
          }
        }
        cout << ", beta = [" + beta1 + "; " + beta22 + ", " + beta23 + "], gamma = [" + gamma12 + ", " + gamma13 + "; " + gamma22 + ", " + gamma23 + "]";
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        file >> u1mg[];
        file >> u1mag[];
        file >> u2mg[];
        file >> u2mag[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg0), defu(umg2), defu(umag2);
        XMhg1<complex> defu(umg1), defu(umag1);
        file >> ubg0[];
        file >> umg1[];
        file >> umag1[];
        file >> umg2[];
        file >> umag2[];
        defu(ubg) = defu(ubg0);
        defu(u1mg) = defu(umg1);
        defu(u1mag) = defu(umag1);
        defu(u2mg) = defu(umg2);
        defu(u2mag) = defu(umag2);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      q1mlocal = u1mg[](restu);
      q1malocal = u1mag[](restu);
      q2mlocal = u2mg[](restu);
      q2malocal = u2mag[](restu);
      return qlocal;
    }

func real[int] loadporb(string inputfilename, string meshfilename, complex[int,int] & qhlocal, real[int] & sym, real & omega, int & Nh) {
      XMhg defu(ubg);
      XMhg<complex> defu(umg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".porb' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string dummy, filemesh, symstr;
      int Nhfile;
      ifstream file(workdir + inputfilename + ".porb");
      file >> dummy >> filemesh >> dummy >> omega >> dummy >> Nhfile;
      if (sym.n > 0) {
        file >> dummy >> symstr;
        sym = parsesymstr(symstr);
      }
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if(Nh == 0) {
        Nh = Nhfile;
        qhlocal.resize(qhlocal.n, Nh);
      }
      complex[int,int] uhg(ubg[].n, Nhfile);
      if (mpirank == 0) {
        cout << "\tomega = " + omega + ", Nh = " + Nhfile;
        if(sym.n > 0) cout << ", sym = " + listsym(sym);
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        for (int nh = 0; nh < Nhfile; nh++) {
          file >> umg[];
          uhg(:, nh) = umg[];
        }
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1);
        XMhg1<complex> defu(umg1);
        file >> ubg1[];
        defu(ubg) = defu(ubg1);
        for (int nh = 0; nh < Nhfile; nh++) {
          file >> umg1[];
          defu(umg) = defu(umg1);
          uhg(:, nh) = umg[];
        }
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      for (int nh = 0; nh < min(Nh, Nhfile); nh++) {
        umg[] = uhg(:, nh);
        qhlocal(:, nh) = umg[](restu);
      }
      return qlocal;
    }

func complex[int] loadfloq(string inputfilename, string meshfilename, complex[int,int] & qhlocal, real[int] & sym1, complex & eigenvalue, real[int] & sym0, real & omega, int & Nh) {
      XMhg<complex> defu(ubg), defu(umg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".floq' over '";
      string filemesh, basefilename, dummy, symstr;
      int Nhfile;
      ifstream file(workdir + inputfilename + ".floq");
      file >> dummy >> filemesh >> dummy >> basefilename >> dummy >> eigenvalue;
      if (sym1.n > 0) {
        file >> dummy >> symstr;
        sym1 = parsesymstr(symstr);
      }
      file >> dummy >> omega >> dummy >> Nhfile;
      if (sym0.n > 0) {
        file >> dummy >> symstr;
        sym0 = parsesymstr(symstr);
      }
      if (mpirank == 0) cout << basefilename + "' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if(Nh == 0) {
        Nh = Nhfile;
        qhlocal.resize(qhlocal.n, 2*Nh);
      }
      complex[int,int] uhg(ubg[].n, 2*Nhfile);
      if (mpirank == 0) {
        cout << "\teval = " + eigenvalue;
        if(sym1.n > 0) cout << ", sym1 = " + listsym(sym1);
        cout << "\tomega = " + omega + ", Nh = " + Nhfile;
        if(sym0.n > 0) cout << ", sym0 = " + listsym(sym0);
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        for (int nh = 0; nh < 2*Nhfile; nh++) {
          file >> umg[];
          uhg(:, nh) = umg[];
        }
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1<complex> defu(ubg1), defu(umg1);
        file >> ubg1[];
        defu(ubg) = defu(ubg1);
        for (int nh = 0; nh < 2*Nhfile; nh++) {
          file >> umg1[];
          defu(umg) = defu(umg1);
          uhg(:, nh) = umg[];
        }
      }
      setparams(paramnames, params);
      complex[int] qlocal = ubg[](restu);
      for (int nh = 0; nh < 2*min(Nh, Nhfile); nh++) {
        umg[] = uhg(:, nh);
        qhlocal(:, nh) = umg[](restu);
      }
      return qlocal;
    }

// parameter functions
  func real getlambda(string& contparam){
    real lambda;
    for (int k = 0; k < paramnames.n; ++k){
    if (contparam == paramnames[k]) lambda = params[paramnames[k]];
      }
    return lambda;
  }

  func int updatelambda(string& contparam, real lambda){
    for (int k = 0; k < paramnames.n; ++k){
      if (contparam == paramnames[k]) params[paramnames[k]] = lambda;
    }
    return 0;
  }