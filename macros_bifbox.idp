//
// macros_bifbox.idp
// Chris Douglas
// cdoug@mit.edu
//
// NOTE: This file should not be changed unless you know what you're doing.
//

cout.precision(12);
string workdir = getARGV("-dir","./data/"); // set working directory
if (workdir(workdir.length-1:workdir.length-1) != "/") workdir = workdir + "/";
int paraviewflag = getARGV("-pv", 0); // indicate whether solution is saved for Paraview
// paraviewflag <= 0: don't save data in Paraview format (only in FF format)
// paraviewflag == 1: save in Paraview format on current mesh
// paraviewflag >= 2: save in Paraview format on 2x, 3x, ... refined mesh using meshsplit

// If settings file does not define a coordinate transform.
IFMACRO(!coordinatetransform)
  IFMACRO(dimension,2)
    macro coordinatetransform() x, y // EOM
  ENDIFMACRO 
  IFMACRO(dimension,3)
    macro coordinatetransform() x, y, z // EOM
  ENDIFMACRO
ENDIFMACRO
// Parse mesh or solution filename
func string parsefilename(string & filename, string & fileroot){
  string fileext;
  if(filename.rfind(".") > 0){ // filename includes extension
    fileext = filename(filename.rfind(".")+1:filename.length-1); // get file extension
    fileroot = filename(0:filename.rfind(".")-1); // get file root
  }
  else {
    fileroot = filename;
    fileext = "";
  }
  return fileext;
}

// Parse symmetry string
func real[int] parsesymstr(string & symstr){
  int fidx = -1;
  string symmstr = symstr;
  real[int] symm(sym.n);
  for (int kk = 0; kk < sym.n; ++kk){
    if (sym.n > 0){
      symmstr = symmstr(fidx+1:symmstr.length);
      fidx = symmstr.find(",");
      if (fidx==-1) fidx = symmstr.length;
      symm(kk) = strtod(symmstr(0:fidx-1));
    }
  }
  return symm;
}
// Get symmetry values as string
func string listsym(real[int] & sym){
  string stringout;
  for (int k = 0; k < sym.n; ++k){
    if (k == 0) stringout = string(sym(0));
    else stringout = stringout + "," + string(sym(k));
  }
  return stringout;
}

// Define local/global mesh variables
meshN Th; // local mesh
meshN Thg; // global mesh
fespace Xh(Th, Pkf); // local FEspace
fespace Xhg(Thg, Pkf); // global FEspace
fespace XMh(Th, Pk); // local FEspace
fespace XMhg(Thg, Pk); // global FEspace

// Initialize parallel local/global numbering arrays
int[int] n2o, restu, restf;
macro ThN2O()n2o// EOM

// Initialize parameter/monitor arrays
real[string] params, monitors;

// Set parameter values
func int setparams(string[int] & paramnames, real[string] & params){
  for (int k = 0; k < paramnames.n; ++k){
    params[paramnames[k]] = getARGV("-" + paramnames[k], params[paramnames[k]]);
  }
  return 0;
}
// Get parameter values
func string listparams(string[int] & paramnames, real[string] & params){
  string stringout;
  for (int k = 0; k < paramnames.n; ++k){
    if (k == 0) stringout = paramnames[k] + " = " + params[paramnames[k]];
    else stringout = stringout + ", " + paramnames[k] + " = " + params[paramnames[k]];
  }
  return stringout;
}

macro createMatu(th,A,P){
    NewMacro def(u)defu(u) EndMacro
    NewMacro init(i)initu(i) EndMacro
    createMat(th,A,P)
} // EOM
macro createMatf(th,A,P){
    NewMacro def(u)deff(u) EndMacro
    NewMacro init(i)initf(i) EndMacro
    createMat(th,A,P)
} // EOM

macro adaptmeshoptions()
hmin = getARGV("-hmin",1.0e-6),
hmax = getARGV("-hmax",1.0e+2),
err = getARGV("-err", 1.0e-2),
errg = getARGV("-errg", 1.0e-2),
nbvx = int(getARGV("-nbvx",1e+6)),
nbsmooth = int(getARGV("-nbsmooth",5)),
ratio = getARGV("-ratio",1.8),
iso = bool(getARGV("-anisomax",1.0) <= 1.0),
anisomax = getARGV("-anisomax",1.0),
rescaling = bool(getARGV("-rescaling", 1)),
power = getARGV("-power", 1.0),
thetamax = getARGV("-thetamax", 10)
//EOM

macro StepAdaptMonitors(Rvec, qa, qap, yqP, yqP0)
  real ipl = real(Rvec'*Rvec);
  mpiAllReduce(ipl, res, mpiCommWorld, mpiSUM);
  res = sqrt(res);
  string text1;
  if (!adaptflag) text1 = count + "-" + it;
  else text1 = "A" + (count-1) + "-" + it;
  if(internalit > 0) text1 = text1 + ">" + internalit;
  if (it == 0){
    kappa = 0.0;
    maxdelta = 0.0;
    cosalpha = 0.0;
    delta = abs(h0);
  }
  else {
    PetscScalar[int] qdiff = qa - qap;
    ipl = real(qdiff'*qdiff);
    mpiAllReduce(ipl, delta, mpiCommWorld, mpiSUM);
    delta = sqrt(delta);
    real ip1, ip1l = real(yqP0'*yqP), ip2, ip2l = real(yqP0'*yqP0), ip3, ip3l = real(yqP'*yqP);
    mpiAllReduce(ip1l, ip1, mpiCommWorld, mpiSUM);
    mpiAllReduce(ip2l, ip2, mpiCommWorld, mpiSUM);
    mpiAllReduce(ip3l, ip3, mpiCommWorld, mpiSUM);
    cosalpha = (ip1 + 1.0)/sqrt((ip2 + 1.0)*(ip3 + 1.0));
    kappa = max(delta/deltap, kappa);
    maxdelta = max(delta, maxdelta);
  }
  f = max(acos(abs(cosalpha))/anglemax*fmax, sqrt(maxdelta/deltamax)*fmax, sqrt(kappa/kappamax)*fmax, 1./fmax);
  if (it > 0 && !adaptflag && (f > fmax || it-1 >= snesmaxit || res*(monotone!=0) > resp)) Rvec(0) = NaN();
  ++internalit;
//EOM

macro ResidualHB(RHB, J, ub, uh, sym1, omega) {
  sym = 0;
  real[int] Rtemp, R = vR(0, XMh, tgv = -1);
  for (int nh = 0; nh < Nh; nh++){
    um[] = uh(:, nh);
    um2[] = conj(um[]);
    ik.im = (1+nh)*sym1;
    ik2 = conj(ik);
    complex[int] Rc = vH(0, XMh, tgv = -10);
    R += Rc.re;
  }
  ChangeNumbering(J, R, Rtemp);
  RHB(0:J.n-1) = Rtemp;
  for (int nh = 0; nh < Nh; ++nh) {
    complex[int] Rc(ub[].n);
    sym = (1+nh)*sym1;
    iomega = 1i*(1+nh)*omega;
    for (int harm = 0; harm < Nh; harm++){
      um[] = uh(:, harm);
      ik.im = (1+harm)*sym1;
      if (harm < nh){
        um2[] = 0.5*uh(:, nh-harm-1);
        ik2.im = (nh-harm)*sym1;
        Rc += vH(0, XMh, tgv = -10);
      } 
      else if (harm == nh) Rc += vJ(0, XMh, tgv = -1);
      else { /* if (harm > nh) */
        um2[] = conj(uh(:, harm-nh-1));
        ik2.im = -(harm-nh)*sym1;
        Rc += vH(0, XMh, tgv = -10);
      }
    }
    ChangeNumbering([J, J], [Rc.re, Rc.im], Rtemp);
    RHB((1+2*nh)*J.n:(3+2*nh)*J.n-1) = Rtemp;
  }
}//EOM

macro JacobianHB(JHB, J, ub, uh, sym1, omega) {
    sym = 0;
    ik = 0;
    iomega = 0;
    matrix<complex> Cmat = vJ(XMh, XMh, tgv = -1);
    matrix An1r = Cmat.re, An2r, An3r, An1i, An2i, An3i;
    Mat row1(J), row2, row3, A1(J), A2(J), temp;
    row1 = An1r;
    for (int n = 0; n < Nh; n++){
      um[] = 2.0*uh(:, n);
      ik.im = (1+n)*sym1;
      ik2.im = -(1+n)*sym1;
      Cmat = vH(XMh, XMh, tgv = -10);
      An1r = Cmat.re;
      ChangeOperator(A1, An1r);
      An2r = Cmat.im;
      ChangeOperator(A2, An2r);
      temp = [[row1, A1, A2]];
      MatConvert(temp, row1);
    }
    for (int n = 0; n < Nh; n++){
      sym = (1+n)*sym1;
      um[] = uh(:, n);
      ik.im = (1+n)*sym1;
      ik2 = 0;
      Cmat = vH(XMh, XMh, tgv = -10);
      An1r = Cmat.re;
      ChangeOperator(A1, An1r);
      MatConvert(A1, row2);
      An1i = Cmat.im;
      ChangeOperator(A2, An1i);
      MatConvert(A2, row3);
      for (int j = 0; j < Nh; j++){
        if (j < n){ /*subharmonics*/
          um[] = uh(:, n-j-1);
          ik.im = (n-j)*sym1;
          ik2.im = (1+j)*sym1;
          Cmat = vH(XMh, XMh, tgv = -10);
        } else if (j == n) { /*diagonal*/
          iomega = 1i*(1+n)*omega;
          ik.im = (1+n)*sym1;
          Cmat = vJ(XMh, XMh, tgv = -1);
        } else { /*if (j > n) superharmonics*/
          um[] = conj(uh(:, j-n-1));
          ik.im = -(j-n)*sym1;
          ik2.im = (1+j)*sym1;
          Cmat = vH(XMh, XMh, tgv = -10);
        }
        An2r = Cmat.re;
        An2i = Cmat.im;
        An3r = -An2i;
        An3i = Cmat.re;
        if (1+j+n < Nh) {
          um[] = uh(:, 1+n+j);
          ik.im = (2+n+j)*sym1;
          ik2.im = -(1+j)*sym1;
          Cmat = vH(XMh, XMh, tgv = -10);
          An2r += Cmat.re;
          An2i += Cmat.im;
          An3r += Cmat.im;
          An3i -= Cmat.re;
        }
        ChangeOperator(A1, An2r);
        ChangeOperator(A2, An3r);
        temp = [[row2, A1, A2]];
        MatConvert(temp, row2);
        ChangeOperator(A1, An2i);
        ChangeOperator(A2, An3i);
        temp = [[row3, A1, A2]];
        MatConvert(temp, row3);
      }
      temp = [[row1], [row2], [row3]];
      MatConvert(temp, row1);
    }
    JHB = row1;
} // EOM

// FUNCTIONS -------------------------------------------------------------------
macro savebase(basefileout, statsfile, meshfile, saveflag, monitorflag){
  IFMACRO(getmonitors) 
    XMhg defu(tempu), defu(ubg), def(umg), def(umag);
    tempu[](restu) = ub[];
    mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    if(monitorflag) getmonitors;
  ENDIFMACRO
  if(mpirank == 0 && monitorflag) {
    if(paramnames[0] != "") cout << "\t" << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if (mpirank == 0 && statsfile != "") {
    cout << "  Saving solution stats to '" + statsfile + ".base.cont' in '" + workdir + "'." << endl;
    string dummy = basefileout;
    {
      ofstream file(workdir + statsfile + ".base.cont", append);
      file.precision(17);
      file << basefileout + ((dummy.rfind(".") > 0) ? "" : ".base") << "\t" << meshfile;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if (saveflag && basefileout != ""){
    IFMACRO(!getmonitors) 
      XMhg defu(tempu), defu(ubg), def(umg), def(umag);
      tempu[](restu) = ub[];
      mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    ENDIFMACRO
    if(mpirank == 0){
      cout << "  Saving '" + basefileout + ".base' on '" + meshfile + "' in '" + workdir + "'." << endl;
      {
        ofstream file(workdir + basefileout + ".base", binary);
        file.precision(17);
        file << "mesh\t" << meshfile << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
          }
        }
        file << ubg[] << endl;
      }
      if (paraviewflag > 0){
        cout << "  Saving '" + basefileout + "_base.vtu' in '" + workdir + "'." << endl;
        meshN Thgpv;
        real[int] qpv = ubg[];
        if (paraviewflag > 1){
          meshN Thgs = trunc(Thg, 1, split = paraviewflag);
          fespace XMhs(Thgs, Pk);
          XMhs defu(us) = defu(ubg);
          qpv.resize(us[].n);
          qpv = us[];
          Thgpv = movemesh(Thgs, [coordinatetransform]);
        }
        else Thgpv = movemesh(Thg, [coordinatetransform]);
        fespace XMhgpv(Thgpv, Pk);
        XMhgpv defu(ugr);
        ugr[] = qpv;
        savevtk(workdir + basefileout + "_base.vtu", Thgpv, adaptu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro savemode(modefileout, evalsfile, basefile, meshfile, evecs, evals, sym, saveflag){
  if(mpirank == 0){
    cout << "\t";
    if(sym.n > 0) cout << "sym = " + listsym(sym) + ", ";
    cout << "eval(s) = [" + evals(0);
    for (int kk = 1; kk < evals.n; ++kk) cout << ", " + evals(kk);
    cout << "]";
    if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && evalsfile != "") {
        cout << "  Saving " + evals.n + " eigenvalues to '" + evalsfile + ".eval' in '" + workdir + "'." << endl;
        for (int kk = 0; kk < evals.n; ++kk){
          ofstream file(workdir + evalsfile + ".eval", append);
          file.precision(17);
          file << basefile << "\t" << meshfile << "\t";
          if(sym.n > 0) file << listsym(sym) << "\t";
          file << evals(kk);
          if(paramnames[0] != ""){
            for (int k = 0; k < paramnames.n; ++k){
              file << "\t" << params[paramnames[k]];
            }
          }
          if(monitornames[0] != ""){
            for (int k = 0; k < monitornames.n; ++k){
              file << "\t" << monitors[monitornames[k]];
            }
          }
          file << endl;
        }
      }
  if(saveflag && modefileout != ""){
    XMhg<complex> defu(tempu), defu(umg);
    for (int ii = 0; ii < evals.n; ++ii){
      um[] = evecs[ii][];
      tempu[](restu) = um[];
      mpiAllReduce(tempu[], umg[], mpiCommWorld, mpiSUM);
      string modefileout0 = modefileout + ((ii > 0) ? ("_" + ii) : "");
      if (mpirank == 0){
        cout << "  Saving '" + modefileout0 + ".mode' over '" + basefile + "' on '" + meshfile + "' in '" + workdir + "'." << endl;
        {
          ofstream file(workdir + modefileout0 + ".mode", binary);
          file.precision(17);
          file << "mesh\t" << meshfile << endl;
          file << "file\t" << basefile << endl;
          if(sym.n > 0) file << "sym\t" << listsym(sym) << endl;
          file << "eval\t" << evals(ii) << endl;
          if(paramnames[0] != ""){
            for (int k = 0; k < paramnames.n; ++k){
              file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
            }
          }
          if(monitornames[0] != ""){
            for (int k = 0; k < monitornames.n; ++k){
              file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
            }
          }
          file << umg[] << endl;
        }
        if (paraviewflag > 0){
          cout << "  Saving '" + modefileout0 + "_mode.vtu' in '" + workdir + "'." << endl;
          meshN Thgpv;
          complex[int] qpv = umg[];
          if (paraviewflag > 1){
            meshN Thgs = trunc(Thg, 1, split = paraviewflag);
            fespace XMhs(Thgs, Pk);
            XMhs<complex> defu(us) = defu(umg);
            qpv.resize(us[].n);
            qpv = us[];
            Thgpv = movemesh(Thgs, [coordinatetransform]);
          }
          else Thgpv = movemesh(Thg, [coordinatetransform]);
          fespace XMhgpv(Thgpv, Pk);
          XMhgpv defu(ugr), defu(ugi);
          ugr[] = qpv.re;
          ugi[] = qpv.im;
          savevtk(workdir + modefileout0 + "_mode.vtu", Thgpv, adaptu(ugr), adaptu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        }
      }
    }
  }
}//EOM

macro saverslv(rslvfileout, gainsfile, basefile, meshfile, fvecs, uvecs, gains, sym, omega, saveflag){
  if(mpirank == 0){
    cout << "\t";
    if(sym.n > 0) cout << "sym = " + listsym(sym) + ", ";
    cout << "omega = " + omega + ", gain(s) = [" + gains(0);
    for (int kk = 1; kk < gains.n; ++kk) cout << ", " + gains(kk);
    cout << "]";
    if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && gainsfile != "") {
    cout << "  Saving " + gains.n + " optimal gain(s) to '" + gainsfile + ".gain' in '" + workdir + "'." << endl;
    for (int kk = 0; kk < gains.n; ++kk){
      ofstream file(workdir + gainsfile + ".gain", append);
      file.precision(17);
      file << basefile << "\t" << meshfile << "\t";
      if(sym.n > 0) file << listsym(sym) << "\t";
      file << omega << "\t" << gains(kk);
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file <<  "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && rslvfileout != ""){
    Xhg<complex> deff(tempf), deff(fmg);
    XMhg<complex> defu(tempu), defu(umg);
    for (int ii = 0; ii < gains.n; ++ii){
      fm[] = fvecs[ii][];
      um[] = uvecs[ii][];
      tempu[](restu) = um[];
      mpiAllReduce(tempu[], umg[], mpiCommWorld, mpiSUM);
      tempf[](restf) = fm[];
      mpiAllReduce(tempf[], fmg[], mpiCommWorld, mpiSUM);
      string fileout = rslvfileout + ((ii > 0) ? ("_" + ii) : "");
      if (mpirank == 0){
        cout << "  Saving '" + fileout + ".rslv' over '" + basefile + "' on '" + meshfile + "' in '" + workdir + "'." << endl;
        {
          ofstream file(workdir + fileout + ".rslv", binary);
          file.precision(17);
          file << "mesh\t" << meshfile << endl;
          file << "file\t" << basefile << endl;
          if(sym.n > 0) file << "sym\t" << listsym(sym) << endl;
          file << "omega\t" << omega << endl;
          file << "gain\t" << gains(ii) << endl;
          if(paramnames[0] != ""){
            for (int k = 0; k < paramnames.n; ++k){
              file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
            }
          }
          if(monitorames[0] != ""){
            for (int k = 0; k < monitornames.n; ++k){
              file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
            }
          }
          file << fmg[] << endl;
          file << umg[] << endl;
        }
        if (paraviewflag > 0){
          cout << "  Saving '" + fileout + "_rslv_[forcing,response].vtu' in '" + workdir + "'." << endl;
          meshN Thgpv;
          complex[int] fpv = fmg[], qpv = umg[];
          if (paraviewflag > 1){
            meshN Thgs = trunc(Thg, 1, split = paraviewflag);
            fespace Xhs(Thgs, Pkf);
            Xhs<complex> deff(fs) = deff(fmg);
            fpv.resize(fs[].n);
            fpv = fs[];
            fespace XMhs(Thgs, Pk);
            XMhs<complex> defu(us) = defu(umg);
            qpv.resize(us[].n);
            qpv = us[];
            Thgpv = movemesh(Thgs, [coordinatetransform]);
          }
          else Thgpv = movemesh(Thg, [coordinatetransform]);
          fespace Xhgpv(Thgpv, Pkf);
          Xhgpv deff(fgr), deff(fgi);
          fgr[] = fpv.re;
          fgi[] = fpv.im;
          savevtk(workdir + fileout + "_rslv_forcing.vtu", Thgpv, adaptf(fgr), adaptf(fgi), dataname = ParaviewDataNamefc, order = ParaviewOrderfc);
          fespace XMhgpv(Thgpv, Pk);
          XMhgpv defu(ugr), defu(ugi);
          ugi[] = qpv.im;
          ugr[] = qpv.re;
          savevtk(workdir + fileout + "_rslv_response.vtu", Thgpv, adaptu(ugr), adaptu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        }
      }
    }
  }
}//EOM

macro savefold(foldfileout, statsfile, meshfile, alpha, beta, saveflag, monitorflag){
  IFMACRO(getmonitors)
    XMhg defu(tempu), defu(ubg), defu(umg), defu(umag);
    tempu[](restu) = ub[];
    mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    tempu[](restu) = um[];
    mpiAllReduce(tempu[], umg[], mpiCommWorld, mpiSUM);
    tempu[](restu) = uma[];
    mpiAllReduce(tempu[], umag[], mpiCommWorld, mpiSUM);
    if(monitorflag) getmonitors;
  ENDIFMACRO
  if(mpirank == 0 && monitorflag){
    cout << "\t";
    if(paramnames[0] != ""){
      for (int k = 0; k < paramnames.n; ++k){
        cout << "alpha[" + paramnames[k] + "] = " + alpha[paramnames[k]] + ", ";
      }
    }
    cout << "beta = " + beta;
    if(paramnames[0] != "") cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if (mpirank == 0 && statsfile != "") {
    cout << "  Saving solution stats to '" + statsfile + ".fold.cont' in '" + workdir + "'." << endl;
    string dummy = foldfileout;
    {
      ofstream file(workdir + statsfile + ".fold.cont", append);
      file.precision(17);
      file << foldfileout + ((dummy.rfind(".") > 0) ? "" : ".fold") << "\t" << meshfile;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << alpha[paramnames[k]];
        }
      }
      file << "\t" << beta;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if (saveflag && foldfileout != ""){
    IFMACRO(!getmonitors)
      XMhg defu(tempu), defu(ubg), defu(umg), defu(umag);
      tempu[](restu) = ub[];
      mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
      tempu[](restu) = um[];
      mpiAllReduce(tempu[], umg[], mpiCommWorld, mpiSUM);
      tempu[](restu) = uma[];
      mpiAllReduce(tempu[], umag[], mpiCommWorld, mpiSUM);
    ENDIFMACRO
    if(mpirank == 0){
      cout << "  Saving '" + foldfileout + ".fold' on '" + meshfile + "' in '" + workdir + "'." << endl;
      {
        ofstream file(workdir + foldfileout + ".fold", binary);
        file.precision(17);
        file << "mesh\t" << meshfile << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << "alpha[" + paramnames[k] + "]\t" << alpha[paramnames[k]] << endl;
          }
        }
        file << "beta\t" << beta << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
          }
        }
        file << ubg[] << endl;
        file << umg[] << endl;
        file << umag[] << endl;
      }
      if (paraviewflag > 0){
        cout << "  Saving '" + foldfileout + "_fold_[base,dirmode,adjmode].vtu' in '" + workdir + "'." << endl;
        meshN Thgpv;
        real[int] qpv = ubg[], qmpv = umg[], qmapv = umag[];
        if (paraviewflag > 1){
          meshN Thgs = trunc(Thg, 1, split = paraviewflag);
          fespace XMhs(Thgs, Pk);
          XMhs defu(us) = defu(ubg);
          qpv.resize(us[].n);
          qmpv.resize(us[].n);
          qmapv.resize(us[].n);
          qpv = us[];
          defu(us) = defu(umg);
          qmpv = us[];
          defu(us) = defu(umag);
          qmapv = us[];
          Thgpv = movemesh(Thgs, [coordinatetransform]);
        }
        else Thgpv = movemesh(Thg, [coordinatetransform]);
        fespace XMhgpv(Thgpv, Pk);
        XMhgpv defu(ugr);
        ugr[] = qpv;
        savevtk(workdir + foldfileout + "_fold_base.vtu", Thgpv, adaptu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
        ugr[] = qmpv;
        savevtk(workdir + foldfileout + "_fold_dirmode.vtu", Thgpv, adaptu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
        ugr[] = qmapv;
        savevtk(workdir + foldfileout + "_fold_adjmode.vtu", Thgpv, adaptu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro savehopf(hopffileout, statsfile, meshfile, sym, omega, alpha, beta, saveflag, monitorflag){
  IFMACRO(getmonitors) 
    XMhg defu(tempu), defu(ubg);
    tempu[](restu) = ub[].re;
    mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    XMhg<complex> defu(cplxu), defu(umg), defu(umag);
    cplxu[](restu) = um[];
    mpiAllReduce(cplxu[], umg[], mpiCommWorld, mpiSUM);
    cplxu[](restu) = uma[];
    mpiAllReduce(cplxu[], umag[], mpiCommWorld, mpiSUM);
    if(monitorflag) getmonitors;
  ENDIFMACRO
  if(mpirank == 0 && monitorflag){
    cout << "\t";
    if(sym.n > 0) cout << "sym = " + listsym(sym) + ", ";
    cout << "omega = " + omega + ", ";
    if(paramnames[0] != ""){
      for (int k = 0; k < paramnames.n; ++k){
        cout << "alpha[" + paramnames[k] + "] = " + alpha[paramnames[k]] + ", ";
      }
    }
    cout << "beta = " + beta;
    if(paramnames[0] != "" ) cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != ""){
    cout << "  Saving solution stats to '" + statsfile + ".hopf.cont' in '" + workdir + "'." << endl;
    string dummy = hopffileout;
    {
      ofstream file(workdir + statsfile + ".hopf.cont", append);
      file.precision(17);
      file << hopffileout + ((dummy.rfind(".") > 0) ? "" : ".hopf") << "\t" << meshfile << "\t";
      if(sym.n > 0) file << listsym(sym) << "\t";
      file << omega;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << alpha[paramnames[k]];
        }
      }
      file << "\t" << beta;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && hopffileout != ""){
    IFMACRO(!getmonitors)
      XMhg defu(tempu), defu(ubg);
      tempu[](restu) = ub[].re;
      mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
      XMhg<complex> defu(cplxu), defu(umg), defu(umag);
      cplxu[](restu) = um[];
      mpiAllReduce(cplxu[], umg[], mpiCommWorld, mpiSUM);
      cplxu[](restu) = uma[];
      mpiAllReduce(cplxu[], umag[], mpiCommWorld, mpiSUM);
    ENDIFMACRO
    if(mpirank == 0){
      cout << "  Saving '" + hopffileout + ".hopf' on '" + meshfile + "' in '" + workdir + "'." << endl;
      {
        ofstream file(workdir + hopffileout + ".hopf", binary);
        file.precision(17);
        file << "mesh\t" << meshfile << endl;
        if(sym.n > 0) file << "sym\t" << listsym(sym) << endl;
        file << "omega\t" << omega << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << "alpha[" + paramnames[k] + "]\t" << alpha[paramnames[k]] << endl;
          }
        }
        file << "beta\t" << beta << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
          }
        }
        file << ubg[] << endl;
        file << umg[] << endl;
        file << umag[] << endl;
      }
      if (paraviewflag > 0){
        cout << "  Saving '" + hopffileout + "_hopf_[base,dirmode,adjmode].vtu' in '" + workdir + "'." << endl;
        meshN Thgpv;
        real[int] qpv = ubg[];
        complex[int] qmpv = umg[], qmapv = umag[];
        if (paraviewflag > 1){
          meshN Thgs = trunc(Thg, 1, split = paraviewflag);
          fespace XMhs(Thgs, Pk);
          XMhs defu(us) = defu(ubg);
          XMhs<complex> defu(ums) = defu(umg);
          qpv.resize(us[].n);
          qmpv.resize(ums[].n);
          qmapv.resize(ums[].n);
          qpv = us[];
          qmpv = ums[];
          defu(ums) = defu(umag);
          qmapv = ums[];
          Thgpv = movemesh(Thgs, [coordinatetransform]);
        }
        else Thgpv = movemesh(Thg, [coordinatetransform]);
        fespace XMhgpv(Thgpv, Pk);
        XMhgpv defu(ugr), defu(ugi);
        ugr[] = qpv;
        savevtk(workdir + hopffileout + "_hopf_base.vtu", Thgpv, adaptu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
        ugr[] = qmpv.re;
        ugi[] = qmpv.im;
        savevtk(workdir + hopffileout + "_hopf_dirmode.vtu", Thgpv, adaptu(ugr), adaptu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ugr[] = qmapv.re;
        ugi[] = qmapv.im;
        savevtk(workdir + hopffileout + "_hopf_adjmode.vtu", Thgpv, adaptu(ugr), adaptu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
      }
    }
  }
}//EOM

macro savetdls(tdlsfileout, statsfile, meshfile, basefile, ICfile, sym, time, saveflag){
  if(mpirank == 0){
    cout << "\t";
    if(sym.n > 0) cout << "sym = " + listsym(sym) + ", ";
    cout << "time = " + time;
    if(paramnames[0] != "") cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != "") {
    cout << "  Saving solution stats to '" + statsfile + ".tdls.cont' in '" + workdir + "'." << endl;
    string dummy = tdlsfileout;
    {
      ofstream file(workdir + statsfile + ".tdls.cont", append);
      file.precision(17);
      file << tdlsfileout + ((dummy.rfind(".") > 0) ? "" : ".tdls") << "\t" << meshfile << "\t" << basefile << "\t" << ICfile << "\t";
      if(sym.n > 0) file << listsym(sym) << "\t";
      file << time;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && tdlsfileout != ""){
    XMhg<PetscScalar> defu(tempu), defu(umg);
    tempu[](restu) = um[];
    mpiAllReduce(tempu[], umg[], mpiCommWorld, mpiSUM);
    if(mpirank == 0){
      cout << "  Saving '" + tdlsfileout + ".tdls' on '" + meshfile + "' in '" + workdir + "'." << endl;
      {
        ofstream file(workdir + tdlsfileout + ".tdls", binary);
        file.precision(17);
        file << "mesh\t" << meshfile << endl;
        file << "base\t" << basefile << endl;
        file << "init\t" << ICfile << endl;
        if(sym.n > 0) file << "sym\t" << listsym(sym) << endl;
        file << "time\t" << time << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
          }
        }
        file << umg[] << endl;
      }
      if (paraviewflag > 0){
        cout << "  Saving '" + tdlsfileout + "_tdls.vtu' in '" + workdir + "'." << endl;
        meshN Thgpv;
        complex[int] qpv = umg[];
        if (paraviewflag > 1){
          meshN Thgs = trunc(Thg, 1, split = paraviewflag);
          fespace XMhs(Thgs, Pk);
          XMhs<complex> defu(us) = defu(umg);
          qpv.resize(us[].n);
          qpv = us[];
          Thgpv = movemesh(Thgs, [coordinatetransform]);
        }
        else Thgpv = movemesh(Thg, [coordinatetransform]);
        fespace XMhgpv(Thgpv, Pk);
        XMhgpv defu(ugr), defu(ugi);
        ugr[] = qpv.re;
        ugi[] = qpv.im;
        savevtk(workdir + tdlsfileout + "_tdls.vtu", Thgpv, adaptu(ugr), adaptu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
      }
    }
  }
}//EOM

macro savetdns(tdnsfileout, statsfile, meshfile, ICfile, time, saveflag, monitorflag){
  IFMACRO(getmonitors)
    XMhg defu(tempu), defu(ubg), def(umg), def(umag);
    tempu[](restu) = ub[];
    mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    if(monitorflag) getmonitors;
  ENDIFMACRO
  if(mpirank == 0 && monitorflag){
    cout << "\ttime = " + time;
    if(paramnames[0] != "") cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != "") {
    cout << "  Saving solution stats to '" + statsfile + ".tdns.cont' in '" + workdir + "'." << endl;
    string dummy = tdnsfileout;
    {
      ofstream file(workdir + statsfile + ".tdns.cont", append);
      file.precision(17);
      file << tdnsfileout + ((dummy.rfind(".") > 0) ? "" : ".tdns") << "\t" << meshfile << "\t" << ICfile << "\t" << time;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && tdnsfileout != ""){
    IFMACRO(!getmonitors)
      XMhg defu(tempu), defu(ubg), def(umg), def(umag);
      tempu[](restu) = ub[];
      mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    ENDIFMACRO
    if(mpirank == 0){
      cout << "  Saving '" + tdnsfileout + ".tdns' on '" + meshfile + "' in '" + workdir + "'." << endl;
      {
        ofstream file(workdir + tdnsfileout + ".tdns", binary);
        file.precision(17);
        file << "mesh\t" << meshfile << endl;
        file << "init\t" << ICfile << endl;
        file << "time\t" << time << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
          }
        }
        file << ubg[] << endl;
      }
      if (paraviewflag > 0){
        cout << "  Saving '" + tdnsfileout + "_tdns.vtu' in '" + workdir + "'." << endl;
        meshN Thgpv;
        real[int] qpv = ubg[];
        if (paraviewflag > 1){
          meshN Thgs = trunc(Thg, 1, split = paraviewflag);
          fespace XMhs(Thgs, Pk);
          XMhs defu(us) = defu(ubg);
          qpv.resize(us[].n);
          qpv = us[];
          Thgpv = movemesh(Thgs, [coordinatetransform]);
        }
        else Thgpv = movemesh(Thg, [coordinatetransform]);
        fespace XMhgpv(Thgpv, Pk);
        XMhgpv defu(ugr);
        ugr[] = qpv;
        savevtk(workdir + tdnsfileout + "_tdns.vtu", Thgpv, adaptu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro savehoho(hohofileout, statsfile, meshfile, sym1, sym2, omega1, omega2, alpha1, alpha2, beta1, beta2, gamma1, gamma2, gamma12, gamma13, gamma22, gamma23, saveflag, monitorflag){
  IFMACRO(getmonitors)
    XMhg defu(tempu), defu(ubg), defu(umg), defu(umag);
    tempu[](restu) = ub[].re;
    mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    XMhg<complex> defu(cplxu), defu(u1mg), defu(u1mag), defu(u2mg), defu(u2mag);
    cplxu[](restu) = um[];
    mpiAllReduce(cplxu[], u1mg[], mpiCommWorld, mpiSUM);
    cplxu[](restu) = uma[];
    mpiAllReduce(cplxu[], u1mag[], mpiCommWorld, mpiSUM);
    cplxu[](restu) = um2[];
    mpiAllReduce(cplxu[], u2mg[], mpiCommWorld, mpiSUM);
    cplxu[](restu) = um3[];
    mpiAllReduce(cplxu[], u2mag[], mpiCommWorld, mpiSUM);
    if(monitorflag) getmonitors;
  ENDIFMACRO
  if(mpirank == 0 && monitorflag){
    cout << "\t";
    if(sym.n > 0) cout << "sym = [" + listsym(sym1) + "; " + listsym(sym2) + "], ";
    cout << "omega = [" + omega1 + "; " + omega2;
    if(paramnames[0] != ""){
      for (int k = 0; k < paramnames.n; ++k){
        cout << "], alpha[" + paramnames[k] + "] = [" + alpha1[paramnames[k]] + "; " + alpha2[paramnames[k]];
      }
    }
    cout << "], beta = [" + beta1 + "; " + beta2 << "], gamma = [" + gamma1 + "," + gamma12 + "," + gamma13 + "; " + gamma2 + "," + gamma22 + "," + gamma23 +  "]";
    if(paramnames[0] != "" ) cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != ""){
    cout << "  Saving solution stats to '" + statsfile + ".hoho.cont' in '" + workdir + "'." << endl;
    string dummy = hohofileout;
    {
      ofstream file(workdir + statsfile + ".hoho.cont", append);
      file.precision(17);
      file << hohofileout + ((dummy.rfind(".") > 0) ? "" : ".hoho") << "\t" << meshfile << "\t";
      if(sym.n > 0) file << listsym(sym1) << "\t" << listsym(sym2) << "\t";
      file << omega1 << "\t" << omega2;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << alpha1[paramnames[k]] << "\t" << alpha2[paramnames[k]];
        }
      }
      file << "\t" << beta1 << "\t" << beta2 << "\t" << gamma1 << "\t" << gamma2 << "\t" << gamma12 << "\t" << gamma13 << "\t" << gamma22 << "\t" << gamma23;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && hohofileout != ""){
    IFMACRO(!getmonitors)
      XMhg defu(tempu), defu(ubg), defu(umg), defu(umag);
      tempu[](restu) = ub[].re;
      mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
      XMhg<complex> defu(cplxu), defu(u1mg), defu(u1mag), defu(u2mg), defu(u2mag);
      cplxu[](restu) = um[];
      mpiAllReduce(cplxu[], u1mg[], mpiCommWorld, mpiSUM);
      cplxu[](restu) = uma[];
      mpiAllReduce(cplxu[], u1mag[], mpiCommWorld, mpiSUM);
      cplxu[](restu) = um2[];
      mpiAllReduce(cplxu[], u2mg[], mpiCommWorld, mpiSUM);
      cplxu[](restu) = um3[];
      mpiAllReduce(cplxu[], u2mag[], mpiCommWorld, mpiSUM);
    ENDIFMACRO
    if(mpirank == 0){
      cout << "  Saving '" + hohofileout + ".hoho' on '" + meshfile + "' in '" + workdir + "'." << endl;
      {
        ofstream file(workdir + hohofileout + ".hoho", binary);
        file.precision(17);
        file << "mesh\t" << meshfile << endl;
        if(sym.n > 0) file << "sym\t" << listsym(sym1) << "\t" << listsym(sym2) << endl;
        file << "omega\t" << omega1 << "\t" << omega2 << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << "alpha[" + paramnames[k] + "]\t" << alpha1[paramnames[k]] << "\t" << alpha2[paramnames[k]] << endl;
          }
        }
        file << "beta\t" << beta1 << "\t" << beta2 << endl;
        file << "gamma\t" << gamma1 << "\t" << gamma2 << "\t" << gamma12 << "\t" << gamma13 << "\t" << gamma22 << "\t" << gamma23 << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
          }
        }
        file << ubg[] << endl;
        file << u1mg[] << endl;
        file << u1mag[] << endl;
        file << u2mg[] << endl;
        file << u2mag[] << endl;
      }
      if (paraviewflag > 0){
        cout << "  Saving '" + hohofileout + "_hoho_[base,dirmode1,adjmode1,dirmode2,adjmode2].vtu' in '" + workdir + "'." << endl;
        meshN Thgpv;
        real[int] qpv = ubg[];
        complex[int] q1mpv = u1mg[], q1mapv = u1mag[], q2mpv = u2mg[], q2mapv = u2mag[];
        if (paraviewflag > 1){
          meshN Thgs = trunc(Thg, 1, split = paraviewflag);
          fespace XMhs(Thgs, Pk);
          XMhs defu(us) = defu(ubg);
          XMhs<complex> defu(ums) = defu(u1mg);
          qpv.resize(us[].n);
          q1mpv.resize(ums[].n);
          q1mapv.resize(ums[].n);
          q2mpv.resize(ums[].n);
          q2mapv.resize(ums[].n);
          qpv = us[];
          q1mpv = ums[];
          defu(ums) = defu(u1mag);
          q1mapv = ums[];
          defu(ums) = defu(u2mg);
          q2mpv = ums[];
          defu(ums) = defu(u2mag);
          q2mapv = ums[];
          Thgpv = movemesh(Thgs, [coordinatetransform]);
        }
        else Thgpv = movemesh(Thg, [coordinatetransform]);
        fespace XMhgpv(Thgpv, Pk);
        XMhgpv defu(ugr), defu(ugi);
        ugr[] = qpv;
        savevtk(workdir + hohofileout + "_hoho_base.vtu", Thgpv, adaptu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
        ugr[] = q1mpv.re;
        ugi[] = q1mpv.im;
        savevtk(workdir + hohofileout + "_hoho_dirmode1.vtu", Thgpv, adaptu(ugr), adaptu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ugr[] = q1mapv.re;
        ugi[] = q1mapv.im;
        savevtk(workdir + hohofileout + "_hoho_adjmode1.vtu", Thgpv, adaptu(ugr), adaptu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ugr[] = q2mpv.re;
        ugi[] = q2mpv.im;
        savevtk(workdir + hohofileout + "_hoho_dirmode2.vtu", Thgpv, adaptu(ugr), adaptu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ugr[] = q2mapv.re;
        ugi[] = q2mapv.im;
        savevtk(workdir + hohofileout + "_hoho_adjmode2.vtu", Thgpv, adaptu(ugr), adaptu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
      }
    }
  }
}//EOM

macro savefoho(fohofileout, statsfile, meshfile, sym, omega, alpha1, alpha2, beta1, beta22, beta23, gamma12, gamma13, gamma22, gamma23, saveflag, monitorflag){
  IFMACRO(getmonitors)
    XMhg defu(tempu), defu(ubg), defu(umg), defu(umag), defu(u2mg), defu(u2mag);
    tempu[](restu) = ub[].re;
    mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    XMhg<complex> defu(cplxu), defu(u1mg), defu(u1mag);
    cplxu[](restu) = um[];
    mpiAllReduce(cplxu[], u1mg[], mpiCommWorld, mpiSUM);
    cplxu[](restu) = uma[];
    mpiAllReduce(cplxu[], u1mag[], mpiCommWorld, mpiSUM);
    tempu[](restu) = um2[];
    mpiAllReduce(tempu[], u2mg[], mpiCommWorld, mpiSUM);
    tempu[](restu) = um3[];
    mpiAllReduce(tempu[], u2mag[], mpiCommWorld, mpiSUM);
    if(monitorflag) getmonitors;
  ENDIFMACRO
  if(mpirank == 0 && monitorflag){
    cout << "\t";
    if(sym.n > 0) cout << "sym = " + listsym(sym) + ", ";
    cout << "omega = " + omega;
    if(paramnames[0] != ""){
      for (int k = 0; k < paramnames.n; ++k){
        cout << ", alpha[" + paramnames[k] + "] = [" + alpha1[paramnames[k]] + "; " + alpha2[paramnames[k]] + "]";
      }
    }
    cout << ", beta = [" + beta1 + "; " + beta22 + ", " + beta23 << "], gamma = [" + gamma12 + ", " + gamma13 + "; " + gamma22 + ", " + gamma23 + "]";
    if(paramnames[0] != "" ) cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != ""){
    cout << "  Saving solution stats to '" + statsfile + ".foho.cont' in '" + workdir + "'." << endl;
    string dummy = fohofileout;
    {
      ofstream file(workdir + statsfile + ".foho.cont", append);
      file.precision(17);
      file << fohofileout + ((dummy.rfind(".") > 0) ? "" : ".hoho") << "\t" << meshfile << "\t";      
      if(sym.n > 0) file << listsym(sym) << "\t";
      file << omega;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << alpha1[paramnames[k]] << "\t" << alpha2[paramnames[k]];
        }
      }
      file << "\t" << beta1 << "\t" << beta22 << "\t" << beta23 << "\t" << gamma12 << "\t" << gamma13 << "\t" << gamma22 << "\t" << gamma23;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && fohofileout != ""){
    IFMACRO(!getmonitors)
      XMhg defu(tempu), defu(ubg), defu(umg), defu(umag), defu(u2mg), defu(u2mag);
      tempu[](restu) = ub[].re;
      mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
      XMhg<complex> defu(cplxu), defu(u1mg), defu(u1mag);
      cplxu[](restu) = um[];
      mpiAllReduce(cplxu[], u1mg[], mpiCommWorld, mpiSUM);
      cplxu[](restu) = uma[];
      mpiAllReduce(cplxu[], u1mag[], mpiCommWorld, mpiSUM);
      tempu[](restu) = um2[];
      mpiAllReduce(tempu[], u2mg[], mpiCommWorld, mpiSUM);
      tempu[](restu) = um3[];
      mpiAllReduce(tempu[], u2mag[], mpiCommWorld, mpiSUM);
    ENDIFMACRO
    if(mpirank == 0){
      cout << "  Saving '" + fohofileout + ".foho' on '" + meshfile + "' in '" + workdir + "'." << endl;
      {
        ofstream file(workdir + fohofileout + ".foho", binary);
        file.precision(17);
        file << "mesh\t" << meshfile << endl;
        if(sym.n > 0) file << "sym\t" << listsym(sym) << endl;
        file << "omega\t" << omega << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << "alpha[" + paramnames[k] + "]\t" << alpha1[paramnames[k]] << "\t" << alpha2[paramnames[k]] << endl;
          }
        }
        file << "beta\t" << beta1 << "\t" << beta22 << "\t" << beta23 << endl;
        file << "gamma\t" << gamma12 << "\t" << gamma13 << "\t" << gamma22 << "\t" << gamma23 << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
          }
        }
        file << ubg[] << endl;
        file << u1mg[] << endl;
        file << u1mag[] << endl;
        file << u2mg[] << endl;
        file << u2mag[] << endl;
      }
      if (paraviewflag > 0){
        cout << "  Saving '" + fohofileout + "_foho_[base,dirmode1,adjmode1,dirmode2,adjmode2].vtu' in '" + workdir + "'." << endl;
        real[int] qpv = ubg[], q2mpv = u2mg[], q2mapv = u2mag[];
        complex[int] q1mpv = u1mg[], q1mapv = u1mag[];
        if (paraviewflag > 1){
          meshN Thgs = trunc(Thg, 1, split = paraviewflag);
          fespace XMhs(Thgs, Pk);
          XMhs defu(us) = defu(ubg);
          XMhs<complex> defu(ums) = defu(u1mg);
          qpv.resize(us[].n);
          q1mpv.resize(ums[].n);
          q1mapv.resize(ums[].n);
          q2mpv.resize(us[].n);
          q2mapv.resize(us[].n);
          qpv = us[];
          q1mpv = ums[];
          defu(ums) = defu(u1mag);
          q1mapv = ums[];
          defu(us) = defu(u2mg);
          q2mpv = us[];
          defu(us) = defu(u2mag);
          q2mapv = us[];
          Thgpv = movemesh(Thgs, [coordinatetransform]);
        }
        else Thgpv = movemesh(Thg, [coordinatetransform]);
        fespace XMhgpv(Thgpv, Pk);
        XMhgpv defu(ugr), defu(ugi);
        ugr[] = qpv;
        savevtk(workdir + fohofileout + "_foho_base.vtu", Thgpv, adaptu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
        ugr[] = q1mpv.re;
        ugi[] = q1mpv.im;
        savevtk(workdir + fohofileout + "_foho_dirmode1.vtu", Thgpv, adaptu(ugr), adaptu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ugr[] = q1mapv.re;
        ugi[] = q1mapv.im;
        savevtk(workdir + fohofileout + "_foho_adjmode1.vtu", Thgpv, adaptu(ugr), adaptu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ugr[] = q2mpv;
        savevtk(workdir + fohofileout + "_foho_dirmode2.vtu", Thgpv, adaptu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
        ugr[] = q2mapv;
        savevtk(workdir + fohofileout + "_foho_adjmode2.vtu", Thgpv, adaptu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro saveporb(porbfileout, statsfile, meshfile, sym, omega, Nh, saveflag, monitorflag){
  IFMACRO(getmonitors)
    XMhg defu(tempu), defu(ubg);
    tempu[](restu) = ub[];
    mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
    XMhg<complex> defu(cplxu), defu(umg), defu(umag);
    complex[int, int] uhg(ubg[].n, Nh);
    for(int harm = 0; harm < Nh; harm++){
      cplxu[](restu) = uh(:, harm);
      mpiAllReduce(cplxu[], uhg(:, harm), mpiCommWorld, mpiSUM);
      umg[] += uhg(:, harm);
    }
    if(monitorflag) getmonitors;
  ENDIFMACRO
  if(mpirank == 0 && monitorflag){
    cout << "\t";
    if(sym.n > 0) cout << "sym = " + listsym(sym) + ", ";
    cout << "omega = " + omega + ", Nh = " + Nh;
    if(paramnames[0] != "" ) cout << ", " << listparams(paramnames, params);
    if(monitornames[0] != "") cout << ", " << listparams(monitornames, monitors);
    cout << "." << endl;
  }
  if(mpirank == 0 && statsfile != ""){
    cout << "  Saving solution stats to '" + statsfile + ".porb.cont' in '" + workdir + "'." << endl;
    string dummy = porbfileout;
    {
      ofstream file(workdir + statsfile + ".porb.cont", append);
      file.precision(17);
      file << porbfileout + ((dummy.rfind(".") > 0) ? "" : ".porb") << "\t" << meshfile << "\t";
      if(sym.n > 0) file << listsym(sym) << "\t";
      file << omega << "\t" << Nh;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << "\t" << params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << "\t" << monitors[monitornames[k]];
        }
      }
      file << endl;
    }
  }
  if(saveflag && porbfileout != ""){
    IFMACRO(!getmonitors)
      XMhg defu(tempu), defu(ubg);
      tempu[](restu) = ub[];
      mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
      XMhg<complex> defu(cplxu);
      complex[int, int] uhg(ubg[].n, Nh);
      for(int harm = 0; harm < Nh; harm++){
        cplxu[](restu) = uh(:, harm);
        mpiAllReduce(cplxu[], uhg(:, harm), mpiCommWorld, mpiSUM);
      }
    ENDIFMACRO
    if(mpirank == 0){
      cout << "  Saving '" + porbfileout + ".porb' on '" + meshfile + "' in '" + workdir + "'." << endl;
      {
        ofstream file(workdir + porbfileout + ".porb", binary);
        file.precision(17);
        file << "mesh\t" << meshfile << endl;
        if(sym.n > 0) file << "sym\t" << listsym(sym) << endl;
        file << "omega\t" << omega << endl;
        file << "Nh\t" << Nh << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
          }
        }
        file << ubg[] << endl;
        for(int harm = 0; harm < Nh; harm++) file << uhg(:, harm) << endl;
      }
      if (paraviewflag > 0){
        cout << "  Saving '" + porbfileout + "_porb_[mean,harm0,harm1,...].vtu' in '" + workdir + "'." << endl;
        meshN Thgpv;
        real[int] qpv = ubg[];
        complex[int, int] qmpv = uhg;
        if (paraviewflag > 1){
          meshN Thgs = trunc(Thg, 1, split = paraviewflag);
          fespace XMhs(Thgs, Pk);
          XMhs defu(us) = defu(ubg);
          XMhs<complex> defu(ums);
          qpv.resize(us[].n);
          qmpv.resize(ums[].n, uhg.m);
          for(int harm = 0; harm < Nh; harm++){
            cplxu[] = uhg(:, harm);
            defu(ums) = defu(cplxu);
            qmpv(:, harm) = ums[];
          }
        }
        else Thgpv = movemesh(Thg, [coordinatetransform]);
        fespace XMhgpv(Thgpv, Pk);
        XMhgpv defu(ugr), defu(ugi);
        XMhgpv<complex> defu(ugc);
        ugr[] = qpv;
        savevtk(workdir + porbfileout + "_porb_mean.vtu", Thgpv, adaptu(ugr), dataname = ParaviewDataName, order = ParaviewOrder);
        for(int harm = 0; harm < Nh; harm++){
          ugc[] = qmpv(:, harm);
          ugr[] = ugc[].re;
          ugi[] = ugc[].im;
          savevtk(workdir + porbfileout + "_porb_harm" + harm + ".vtu", Thgpv, adaptu(ugr), adaptu(ugi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        }
      }
    }
  }
}//EOM

func string readmeshname(string inputfilename) {
  string meshfilename;
  { ifstream file(inputfilename);
    file >> meshfilename >> meshfilename;
  }
  return meshfilename;
}

func string readbasename(string inputfilename) {
  string basefilename;
  { ifstream file(inputfilename);
    file >> basefilename >> basefilename >> basefilename >> basefilename;
  }
  return basefilename;
}
func complex readmodeeval(string inputfilename, real[int] & sym) {
  complex eigenvalue;
  string dummy, symstr;
  { ifstream file(inputfilename);
    for (int k = 0; k < (paramnames.n+2); ++k){
      file >> dummy >> dummy;
    }
    if (sym.n > 0) {
      file >> dummy >> symstr;
      sym = parsesymstr(symstr);
    }
    file >> dummy >> eigenvalue;
  }
  return eigenvalue;
}


func real[int] loadbase(string inputfilename, string meshfilename) {
      XMhg defu(ubg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".base' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string filemesh;
      ifstream file(workdir + inputfilename + ".base");
      file >> filemesh >> filemesh;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        if(paramnames[0] != "" || monitornames[0] != "") cout << "\t";
        if(paramnames[0] != "") cout << listparams(paramnames, params);
        if(paramnames[0] != "" && monitornames[0] != "") cout << ", ";
        if(monitornames[0] != "") cout << listparams(monitornames, monitors);
        if(paramnames[0] != "" || monitornames[0] != "") cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1);
        file >> ubg1[];
        defu(ubg) = defu(ubg1);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      return qlocal;
    }

func real[int] loadfold(string inputfilename, string meshfilename, real[int] & qmlocal, real[int] & qmalocal, real[string] & alpha, real & beta) {
      XMhg defu(ubg), defu(umg), defu(umag);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".fold' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string dummy, filemesh;
      ifstream file(workdir + inputfilename + ".fold");
      file >> filemesh >> filemesh;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> dummy >> alpha[paramnames[k]];
        }
      }
      file >> dummy >> beta;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\t";
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            cout << "alpha[" + paramnames[k] + "] = " + alpha[paramnames[k]] + ", ";
          }
        }
        cout << "beta = " + (beta);
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        file >> umg[];
        file >> umag[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1), defu(umg1), defu(umag1);
        file >> ubg1[];
        file >> umg1[];
        file >> umag1[];
        defu(ubg) = defu(ubg1);
        defu(umg) = defu(umg1);
        defu(umag) = defu(umag1);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      qmlocal = umg[](restu);
      qmalocal = umag[](restu);
      return qlocal;
    }

func real[int] loadhopf(string inputfilename, string meshfilename, complex[int] & qmlocal, complex[int] & qmalocal, real[int] & sym, real & omega, complex[string] & alpha, complex & beta) {
      XMhg defu(ubg);
      XMhg<complex> defu(umg), defu(umag);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".hopf' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string dummy, filemesh, symstr;
      ifstream file(workdir + inputfilename + ".hopf");
      file >> dummy >> filemesh;
      if (sym.n > 0) {
        file >> dummy >> symstr;
        sym = parsesymstr(symstr);
      }
      file >> dummy >> omega;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> dummy >> alpha[paramnames[k]];
        }
      }
      file >> dummy >> beta;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\t";
        if(sym.n > 0) cout << "sym = " + listsym(sym) + ", ";
        cout << "omega = " + omega;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            cout << ", alpha[" + paramnames[k] + "] = " + alpha[paramnames[k]];
          }
        }
        cout << ", beta = " + (beta);
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        file >> umg[];
        file >> umag[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1);
        XMhg1<complex> defu(umg1), defu(umag1);
        file >> ubg1[];
        file >> umg1[];
        file >> umag1[];
        defu(ubg) = defu(ubg1);
        defu(umg) = defu(umg1);
        defu(umag) = defu(umag1);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      qmlocal = umg[](restu);
      qmalocal = umag[](restu);
      return qlocal;
    }

func complex[int] loadmode(string inputfilename, string meshfilename, real[int] & sym, complex & eigenvalue) {
      XMhg<complex> defu(umg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".mode' over '";
      string filemesh, basefilename, dummy, symstr;
      real[string] tempparams;
      ifstream file(workdir + inputfilename + ".mode");
      file >> dummy >> filemesh >> dummy >> basefilename;
      if (sym.n > 0) {
        file >> dummy >> symstr;
        sym = parsesymstr(symstr);
      }
      file >> dummy >> eigenvalue;
      if (mpirank == 0) cout << basefilename + "' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> tempparams[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\t";
        if(sym.n > 0) cout << "sym = " + listsym(sym) + ", ";
        cout << "eval = " + eigenvalue;
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, tempparams);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> umg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1<complex> defu(umg1);
        file >> umg1[];
        defu(umg) = defu(umg1);
      }
      complex[int] qlocal = umg[](restu);
      return qlocal;
    }

func complex[int] loadrslv(string inputfilename, string meshfilename, complex[int] & fmlocal, real[int] & sym, real & omega, real & gain) {
      Xhg<complex> deff(fmg);
      XMhg<complex> defu(umg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".rslv' over '";
      string filemesh, basefilename, dummy, symstr;
      real[string] tempparams;
      ifstream file(workdir + inputfilename + ".rslv");
      file >> filemesh >> filemesh >> basefilename >> basefilename;
      if (sym.n > 0) {
        file >> dummy >> symstr;
        sym = parsesymstr(symstr);
      }
      file >> dummy >> omega >> dummy >> gain;
      if (mpirank == 0) cout << basefilename + "' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> tempparams[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\t";
        if(sym.n > 0) cout << "sym = " + listsym(sym) + ", ";
        cout << "omega = " + omega + ", gain = " + gain;
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, tempparams);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> fmg[] >> umg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace Xhg1(Thg1, Pkf);
        Xhg1<complex> deff(fmg1);
        fespace XMhg1(Thg1, Pk);
        XMhg1<complex> defu(umg1);
        file >> fmg1[] >> umg1[];
        deff(fmg) = deff(fmg1);
        defu(umg) = defu(umg1);
      }
      fmlocal = fmg[](restf);
      complex[int] qlocal = umg[](restu);
      return qlocal;
    }

func real[int] loadtdns(string inputfilename, string meshfilename, real& time) {
      XMhg defu(ubg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".tdns' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string filemesh, ICfile, dummy;
      ifstream file(workdir + inputfilename + ".tdns");
      file >> filemesh >> filemesh >> ICfile >> ICfile >> dummy >> time;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\ttime = " << time;
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1);
        file >> ubg1[];
        defu(ubg) = defu(ubg1);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      return qlocal;
    }

func complex[int] loadtdls(string inputfilename, string meshfilename, real[int] & sym, real& time) {
      XMhg<complex> defu(umg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".tdls' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string filemesh, basefile, ICfile, dummy, symstr;
      ifstream file(workdir + inputfilename + ".tdls");
      file >> filemesh >> filemesh >> basefile >> basefile >> ICfile >> ICfile;
      if (sym.n > 0) {
        file >> dummy >> symstr;
        sym = parsesymstr(symstr);
      }
      file >> dummy >> time;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\t";
        if(sym.n > 0) cout << "sym = " + listsym(sym) + ", ";
        cout << "time = " << time;
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> umg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1<complex> defu(umg1);
        file >> umg1[];
        defu(umg) = defu(umg1);
      }
      setparams(paramnames, params);
      complex[int] qlocal = umg[](restu);
      return qlocal;
    }

func real[int] loadhoho(string inputfilename, string meshfilename, complex[int] & q1mlocal, complex[int] & q1malocal, complex[int] & q2mlocal, complex[int] & q2malocal,
                        real[int] & sym1, real[int] & sym2, real & omega1, real & omega2, complex[string] & alpha1, complex[string] & alpha2, complex & beta1, complex & beta2, complex & gamma1, complex & gamma2, complex & gamma12, complex & gamma13, complex & gamma22, complex & gamma23) {
      XMhg defu(ubg);
      XMhg<complex> defu(u1mg), defu(u1mag), defu(u2mg), defu(u2mag);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".hoho' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string dummy, filemesh, symstr1, symstr2;
      ifstream file(workdir + inputfilename + ".hoho");
      file >> dummy >> filemesh;
      if(sym.n > 0) file >> dummy >> symstr1 >> symstr2;
      file >> dummy >> omega1 >> omega2;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> dummy >> alpha1[paramnames[k]] >> alpha2[paramnames[k]];
        }
      }
      file >> dummy >> beta1 >> beta2;
      file >> dummy >> gamma1 >> gamma2 >> gamma12 >> gamma13 >> gamma22 >> gamma23;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      sym1 = parsesymstr(symstr1);
      sym2 = parsesymstr(symstr2);
      if(mpirank == 0) {
        cout << "\t";
        if(sym.n > 0) cout << "sym = [" + listsym(sym1) + "; " + listsym(sym2) + "], ";
        cout << "omega = [" + omega1 + "; " + omega2;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            cout << "], alpha[" + paramnames[k] + "] = [" + alpha1[paramnames[k]] + "; " + alpha2[paramnames[k]];
          }
        }
        cout << "], beta = [" + beta1 + "; " + beta2 + "], gamma = [" + gamma1 + ", " + gamma12 + ", " + gamma13 + "; " + gamma2 + ", " + gamma22 + ", " + gamma23 + "]";
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        file >> u1mg[];
        file >> u1mag[];
        file >> u2mg[];
        file >> u2mag[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg0);
        XMhg1<complex> defu(umg1), defu(umag1), defu(umg2), defu(umag2);
        file >> ubg0[];
        file >> umg1[];
        file >> umag1[];
        file >> umg2[];
        file >> umag2[];
        defu(ubg) = defu(ubg0);
        defu(u1mg) = defu(umg1);
        defu(u1mag) = defu(umag1);
        defu(u2mg) = defu(umg2);
        defu(u2mag) = defu(umag2);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      q1mlocal = u1mg[](restu);
      q1malocal = u1mag[](restu);
      q2mlocal = u2mg[](restu);
      q2malocal = u2mag[](restu);
      return qlocal;
    }

func real[int] loadfoho(string inputfilename, string meshfilename, complex[int] & q1mlocal, complex[int] & q1malocal, real[int] & q2mlocal, real[int] & q2malocal,
                        real[int] & sym, real & omega, complex[string] & alpha1, real[string] & alpha2, complex & beta1, real & beta22, real & beta23, complex & gamma12, complex & gamma13, real & gamma22, real & gamma23) {
      XMhg defu(ubg), defu(u2mg), defu(u2mag);
      XMhg<complex> defu(u1mg), defu(u1mag);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".foho' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string dummy, filemesh, symstr;
      ifstream file(workdir + inputfilename + ".foho");
      file >> dummy >> filemesh;
      if (sym.n > 0) file >> dummy >> symstr;
      file >> dummy >> omega;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> dummy >> alpha1[paramnames[k]] >> alpha2[paramnames[k]];
        }
      }
      file >> dummy >> beta1 >> beta22 >> beta23;
      file >> dummy >> gamma12 >> gamma13 >> gamma22 >> gamma23;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      sym = parsesymstr(symstr);
      if(mpirank == 0) {
        cout << "\t";
        if(sym.n > 0) cout << "sym = " + listsym(sym) + ", ";
        cout << "omega = " + omega;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            cout << ", alpha[" + paramnames[k] + "] = [" + alpha1[paramnames[k]] + "; " + alpha2[paramnames[k]] + "]";
          }
        }
        cout << ", beta = [" + beta1 + "; " + beta22 + ", " + beta23 + "], gamma = [" + gamma12 + ", " + gamma13 + "; " + gamma22 + ", " + gamma23 + "]";
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        file >> u1mg[];
        file >> u1mag[];
        file >> u2mg[];
        file >> u2mag[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg0), defu(umg2), defu(umag2);
        XMhg1<complex> defu(umg1), defu(umag1);
        file >> ubg0[];
        file >> umg1[];
        file >> umag1[];
        file >> umg2[];
        file >> umag2[];
        defu(ubg) = defu(ubg0);
        defu(u1mg) = defu(umg1);
        defu(u1mag) = defu(umag1);
        defu(u2mg) = defu(umg2);
        defu(u2mag) = defu(umag2);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      q1mlocal = u1mg[](restu);
      q1malocal = u1mag[](restu);
      q2mlocal = u2mg[](restu);
      q2malocal = u2mag[](restu);
      return qlocal;
    }

func real[int] loadporb(string inputfilename, string meshfilename, complex[int,int] & qhlocal, real[int] & sym, real & omega, int & Nh) {
      XMhg defu(ubg);
      XMhg<complex> defu(umg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".porb' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string dummy, filemesh, symstr;
      int Nhfile;
      ifstream file(workdir + inputfilename + ".porb");
      file >> dummy >> filemesh;
      if (sym.n > 0) {
        file >> dummy >> symstr;
        sym = parsesymstr(symstr);
      }
      file >> dummy >> omega >> dummy >> Nhfile;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if(Nh == 0) {
        Nh = Nhfile;
        qhlocal.resize(qhlocal.n, Nh);
      }
      complex[int,int] uhg(ubg[].n, Nhfile);
      if (mpirank == 0) {
        cout << "\t";
        if(sym.n > 0) cout << "sym = " + listsym(sym) + ", ";
        cout << "omega = " + omega + ", Nh = " + Nhfile;
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        for (int harm = 0; harm < Nhfile; harm++) {
          file >> umg[];
          uhg(:, harm) = umg[];
        }
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1);
        XMhg1<complex> defu(umg1);
        file >> ubg1[];
        defu(ubg) = defu(ubg1);
        for (int harm = 0; harm < Nhfile; harm++) {
          file >> umg1[];
          defu(umg) = defu(umg1);
          uhg(:, harm) = umg[];
        }
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      for (int harm = 0; harm < min(Nh, Nhfile); harm++) {
        umg[] = uhg(:, harm);
        qhlocal(:, harm) = umg[](restu);
      }
      return qlocal;
    }

// parameter functions
  func real getlambda(string& contparam){
    real lambda;
    for (int k = 0; k < paramnames.n; ++k){
    if (contparam == paramnames[k]) lambda = params[paramnames[k]];
      }
    return lambda;
  }

  func int updatelambda(string& contparam, real lambda){
    for (int k = 0; k < paramnames.n; ++k){
      if (contparam == paramnames[k]) params[paramnames[k]] = lambda;
    }
    return 0;
  }
