//
// macros_bifbox.idp
// Chris Douglas
// chris.douglas@ladhyx.polytechnique.fr
//
// NOTE: This file should not be changed unless you know what you're doing.
//

cout.precision(12);
string workdir = getARGV("-dir","./data/"); // set working directory
if (workdir(workdir.length-1:workdir.length-1) != "/") workdir = workdir + "/";
int paraviewflag = getARGV("-pv", 0); // indicate whether solution is saved for Paraview
// paraviewflag <= 0: don't save data in Paraview format (only in FF format)
// paraviewflag == 1: save in Paraview format on current mesh
// paraviewflag >= 2: save in Paraview format on 2x, 3x, ... refined mesh using meshsplit

func string parsefilename(string & filename, string & fileroot){
  string fileext;
  if(filename.rfind(".") > 0){ // filename includes extension
    fileext = filename(filename.rfind(".")+1:filename.length-1); // get file extension
    fileroot = filename(0:filename.rfind(".")-1); // get file root
  }
  else {
    fileroot = filename;
    fileext = "";
  }
  return fileext;
}

// Define local/global mesh variables
meshN Th; // local mesh
meshN Thg; // global mesh
fespace Xh(Th, Pkf); // local FEspace
fespace Xhg(Thg, Pkf); // global FEspace
fespace XMh(Th, Pk); // local FEspace
fespace XMhg(Thg, Pk); // global FEspace

// Initialize parallel local/global numbering arrays
int[int] n2o, restu, restf;
macro ThN2O()n2o// EOM

// Initialize parameter/monitor arrays
real[string] params, monitors;

// Set parameter values
func int setparams(string[int] & paramnames, real[string] & params){
  for (int k = 0; k < paramnames.n; ++k){
    params[paramnames[k]] = getARGV("-" + paramnames[k], params[paramnames[k]]);
  }
  return 0;
}
// Get parameter values
func string listparams(string[int] & paramnames, real[string] & params){
  string stringout;
  for (int k = 0; k < paramnames.n; ++k){
    if (k == 0) stringout = paramnames[k] + " = " + params[paramnames[k]];
    else stringout = stringout + ", " + paramnames[k] + " = " + params[paramnames[k]];
  }
  return stringout;
}
// EOM
macro createMatu(th,A,P){
    NewMacro def(u)defu(u) EndMacro
    NewMacro init(i)initu(i) EndMacro
    createMat(th,A,P)
} // EOM
macro createMatf(th,A,P){
    NewMacro def(u)deff(u) EndMacro
    NewMacro init(i)initf(i) EndMacro
    createMat(th,A,P)
} // EOM

macro adaptmeshoptions()
hmin = getARGV("-hmin",1.0e-6),
hmax = getARGV("-hmax",1.0e+2),
err = getARGV("-err", 1.0e-2),
errg = getARGV("-errg", 1.0e-2),
nbvx = int(getARGV("-nbvx",1e+6)),
nbsmooth = int(getARGV("-nbsmooth",5)),
ratio = getARGV("-ratio",1.8),
anisomax = getARGV("-anisomax",1.0),
rescaling = bool(getARGV("-rescaling", 1)),
power = getARGV("-power", 1.0),
thetamax = getARGV("-thetamax", 10.0)
//EOM

// FUNCTIONS -------------------------------------------------------------------
macro savebase(basefileout, statsfile, meshfile, saveflag, monitorflag){
  XMhg defu(tempu), defu(ubg);
  for[i, v : restu] tempu[][v] = ub[][i];
  mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
  if (monitorflag) getmonitors(ubg);
  if (mpirank == 0 && statsfile != "") printstats(statsfile, basefileout + ".base", meshfile, 0, 0, 0);
  if (saveflag && mpirank == 0 && basefileout != ""){
    cout << "  Saving '" + basefileout + ".base' on '" + meshfile + "' in '" + workdir + "'." << endl;
    if (statsfile == "") {
      if(paramnames[0] != "" || monitornames[0] != "") cout << "\t";
      if(paramnames[0] != "") cout << listparams(paramnames, params);
      if(paramnames[0] != "" && monitornames[0] != "") cout << ", ";
      if(monitornames[0] != "") cout << listparams(monitornames, monitors);
      if(paramnames[0] != "" || monitornames[0] != "") cout << "." << endl;
    }
    {
      ofstream file(workdir + basefileout + ".base", binary);
      file.precision(17);
      file << "mesh\t" << meshfile << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
        }
      }
      file << ubg[] << endl;
    }
    if (paraviewflag > 0){
      cout << "  Saving '" + basefileout + "_base.vtu' in '" + workdir + "'." << endl;
      if (paraviewflag > 1){
        meshN Thgs = trunc(Thg, 1, split = paraviewflag);
        fespace XMhs(Thgs, Pk);
        XMhs defu(us) = defu(ubg);
        savevtk(workdir + basefileout + "_base.vtu", Thgs, adaptu(us), dataname = ParaviewDataName, order = ParaviewOrder);
      }
      else {
        savevtk(workdir + basefileout + "_base.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro savemode(modefileout, evalsfile, basefile, meshfile, evecs, evals, sym, saveflag){
  if (mpirank == 0 && evalsfile != "") printevals(evalsfile, basefile, meshfile, sym, evals);
  if (saveflag){
    XMhg<complex> defu(tempu), defu(umg);
    for (int ii = 0; ii < evals.n; ++ii){
      um[] = evecs[ii][];
      for[i, v : restu] tempu[][v] = um[][i];
      mpiAllReduce(tempu[], umg[], mpiCommWorld, mpiSUM);
      string fileout = modefileout + "_" + ii;
      if (mpirank == 0 && modefileout != ""){
        cout << "  Saving '" + fileout + ".mode' over '" + basefile + "' on '" + meshfile + "' in '" + workdir + "'." << endl;
        cout << "\tsym = " + sym + ", eval = " + evals(ii);
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        cout << "." << endl;
        {
          ofstream file(workdir + fileout + ".mode", binary);
          file.precision(17);
          file << "mesh\t" << meshfile << endl;
          file << "file\t" << basefile << endl;
          file << "sym\t" << sym << endl;
          file << "eval\t" << evals(ii) << endl;
          if(paramnames[0] != ""){
            for (int k = 0; k < paramnames.n; ++k){
              file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
            }
          }
          file << umg[] << endl;
        }
        if (paraviewflag > 0){
          cout << "  Saving '" + modefileout + "_mode.vtu' in '" + workdir + "'." << endl;
          if (paraviewflag > 1){
            meshN Thgs = trunc(Thg, 1, split = paraviewflag);
            fespace XMhs(Thgs, Pk);
            XMhs<complex> defu(uso) = defu(umg);
            XMhs defu(usr), defu(usi);
            usr[] = uso[].re;
            usi[] = uso[].im;
            savevtk(workdir + modefileout + "_mode.vtu", Thgs, adaptu(usr), adaptu(usi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
          }
          else {
            XMhg defu(usr), defu(usi);
            usr[] = umg[].re;
            usi[] = umg[].im;
            savevtk(workdir + modefileout + "_mode.vtu", Thg, adaptu(usr), adaptu(usi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
          }
        }
      }
    }
  }
}//EOM

macro saveresolvent(resolventfileout, gainsfile, basefile, meshfile, fvecs, uvecs, gains, sym, omega, saveflag){
  if (mpirank == 0 && gainsfile != "") printgains(gainsfile, basefile, meshfile, sym, omega, gains);
  if (saveflag){
    Xhg<complex> deff(tempf), deff(fmg);
    XMhg<complex> defu(tempu), defu(umg);
    for (int ii = 0; ii < gains.n; ++ii){
      fm[] = fvecs[ii][];
      um[] = uvecs[ii][];
      for[i, v : restu] tempu[][v] = um[][i];
      mpiAllReduce(tempu[], umg[], mpiCommWorld, mpiSUM);
      for[i, v : restf] tempf[][v] = fm[][i];
      mpiAllReduce(tempf[], fmg[], mpiCommWorld, mpiSUM);
      string fileout = resolventfileout + "_" + ii;
      if (mpirank == 0 && resolventfileout != ""){
        cout << "  Saving '" + fileout + ".rslv' over '" + basefile + "' on '" + meshfile + "' in '" + workdir + "'." << endl;
        cout << "\tsym = " + sym + ", omega = " + omega + ", gain = " + gains(ii);
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        cout << "." << endl;
        {
          ofstream file(workdir + fileout + ".rslv", binary);
          file.precision(17);
          file << "mesh\t" << meshfile << endl;
          file << "file\t" << basefile << endl;
          file << "sym\t" << sym << endl;
          file << "omega\t" << omega << endl;
          file << "gain\t" << gains(ii) << endl;
          if(paramnames[0] != ""){
            for (int k = 0; k < paramnames.n; ++k){
              file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
            }
          }
          file << fmg[] << endl;
          file << umg[] << endl;
        }
        if (paraviewflag > 0){
          cout << "  Saving '" + fileout + "_rslv_[forcing,response].vtu' in '" + workdir + "'." << endl;
          if (paraviewflag > 1){
            meshN Thgs = trunc(Thg, 1, split = paraviewflag);
            fespace XMhs(Thgs, Pk);
            XMhs<complex> defu(uso) = defu(umg);
            fespace Xhs(Thgs, Pkf);
            Xhs<complex> deff(fso) = deff(fmg);
            Xhs deff(fsr), deff(fsi);
            fsr[] = fso[].re;
            fsi[] = fso[].im;
            savevtk(workdir + fileout + "_mode_forcing.vtu", Thg, adaptf(fsr), adaptf(fsi), dataname = ParaviewDataNamefc, order = ParaviewOrderfc);
            XMhs defu(usr), defu(usi);
            usr[] = uso[].re;
            usi[] = uso[].im;
            savevtk(workdir + fileout + "_rslv_response.vtu", Thgs, adaptu(usr), adaptu(usi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
          }
          else {
            Xhg deff(fsr), deff(fsi);
            fsr[] = fmg[].re;
            fsi[] = fmg[].im;
            savevtk(workdir + fileout + "_mode_forcing.vtu", Thg, adaptf(fsr), adaptf(fsi), dataname = ParaviewDataNamefc, order = ParaviewOrderfc);
            XMhg defu(usr), defu(usi);
            usr[] = umg[].re;
            usi[] = umg[].im;
            savevtk(workdir + fileout + "_mode_response.vtu", Thg, adaptu(usr), adaptu(usi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
          }
        }
      }
    }
  }
}//EOM

macro savefold(foldfileout, statsfile, meshfile, saveflag, monitorflag){
  XMhg defu(tempu), defu(ubg), defu(umg), defu(umag);
  for[i, v : restu] tempu[][v] = ub[][i];
  mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
  for[i, v : restu] tempu[][v] = um[][i];
  mpiAllReduce(tempu[], umg[], mpiCommWorld, mpiSUM);
  for[i, v : restu] tempu[][v] = uma[][i];
  mpiAllReduce(tempu[], umag[], mpiCommWorld, mpiSUM);
  if (monitorflag) getmonitors(ubg);
  if (mpirank == 0 && statsfile != "") printstats(statsfile, foldfileout + ".fold", meshfile, 0, 0, 0);
  if (saveflag && mpirank == 0 && foldfileout != ""){
    cout << "  Saving '" + foldfileout + ".fold' on '" + meshfile + "' in '" + workdir + "'." << endl;
    if (statsfile == "") {
      if(paramnames[0] != "" || monitornames[0] != "") cout << "\t";
      if(paramnames[0] != "") cout << listparams(paramnames, params);
      if(paramnames[0] != "" && monitornames[0] != "") cout << ", ";
      if(monitornames[0] != "") cout << listparams(monitornames, monitors);
      if(paramnames[0] != "" || monitornames[0] != "") cout << "." << endl;
    }
    {
      ofstream file(workdir + foldfileout + ".fold", binary);
      file.precision(17);
      file << "mesh\t" << meshfile << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
        }
      }
      file << ubg[] << endl;
      file << umg[] << endl;
      file << umag[] << endl;
    }
    if (paraviewflag > 0){
      cout << "  Saving '" + foldfileout + "_fold_[base,dirmode,adjmode].vtu' in '" + workdir + "'." << endl;
      if (paraviewflag > 1){
        meshN Thgs = trunc(Thg, 1, split = paraviewflag);
        fespace XMhs(Thgs, Pk);
        XMhs defu(ubs) = defu(ubg);
        savevtk(workdir + foldfileout + "_fold_base.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
        defu(ubs) = defu(umg);
        savevtk(workdir + foldfileout + "_fold_dirmode.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
        defu(ubs) = defu(umag);
        savevtk(workdir + foldfileout + "_fold_adjmode.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
      }
      else {
        savevtk(workdir + foldfileout + "_fold_base.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
        savevtk(workdir + foldfileout + "_fold_dirmode.vtu", Thg, adaptu(umg), dataname = ParaviewDataName, order = ParaviewOrder);
        savevtk(workdir + foldfileout + "_fold_adjmode.vtu", Thg, adaptu(umag), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro savehopf(hopffileout, statsfile, meshfile, sym, omega, saveflag, monitorflag){
  XMhg defu(tempu), defu(ubg);
  XMhg<complex> defu(cplxu), defu(umg), defu(umag);
  for[i, v : restu] tempu[][v] = real(ub[][i]);
  mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
  for[i, v : restu] cplxu[][v] = um[][i];
  mpiAllReduce(cplxu[], umg[], mpiCommWorld, mpiSUM);
  for[i, v : restu] cplxu[][v] = uma[][i];
  mpiAllReduce(cplxu[], umag[], mpiCommWorld, mpiSUM);
  if (monitorflag) getmonitors(ubg);
  if (mpirank == 0 && statsfile != "") printstats(statsfile, hopffileout + ".hopf", meshfile, sym, omega, 0);
  if (saveflag && mpirank == 0 && hopffileout != ""){
    cout << "  Saving '" + hopffileout + ".hopf' on '" + meshfile + "' in '" + workdir + "'." << endl;
    if (statsfile == "") {
      cout << "\tsym = " + sym + ", omega = " + omega;
      if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
      if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
      cout << "." << endl;
    }
    {
      ofstream file(workdir + hopffileout + ".hopf", binary);
      file.precision(17);
      file << "mesh\t" << meshfile << endl;
      file << "sym\t" << sym << endl;
      file << "omega\t" << omega << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
        }
      }
      file << ubg[] << endl;
      file << umg[] << endl;
      file << umag[] << endl;
    }
    if (paraviewflag > 0){
      cout << "  Saving '" + hopffileout + "_hopf_[base,dirmode,adjmode].vtu' in '" + workdir + "'." << endl;
      if (paraviewflag > 1){
        meshN Thgs = trunc(Thg, 1, split = paraviewflag);
        fespace XMhs(Thgs, Pk);
        XMhs defu(ubs) = defu(ubg), defu(ubsi);
        XMhs<complex> defu(ums) = defu(umg);
        savevtk(workdir + hopffileout + "_hopf_base.vtu", Thgs, adaptu(ubs), dataname = ParaviewDataName, order = ParaviewOrder);
        ubs[] = ums[].re;
        ubsi[] = ums[].im;
        savevtk(workdir + hopffileout + "_hopf_dirmode.vtu", Thgs, adaptu(ubs), adaptu(ubsi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        defu(ums) = defu(umag);
        ubs[] = ums[].re;
        ubsi[] = ums[].im;
        savevtk(workdir + hopffileout + "_hopf_adjmode.vtu", Thgs, adaptu(ubs), adaptu(ubsi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
      }
      else {
        savevtk(workdir + hopffileout + "_hopf_base.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
        XMhg defu(ubgi);
        ubg[] = umg[].re;
        ubgi[] = umg[].im;
        savevtk(workdir + hopffileout + "_hopf_dirmode.vtu", Thg, adaptu(ubg), adaptu(ubgi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        ubg[] = umag[].re;
        ubgi[] = umag[].im;
        savevtk(workdir + hopffileout + "_hopf_adjmode.vtu", Thg, adaptu(ubg), adaptu(ubgi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
      }
    }
  }
}//EOM

macro savetdns(tdnsfileout, statsfile, meshfile, ICfile, time, saveflag, monitorflag){
  XMhg defu(tempu), defu(ubg);
  for[i, v : restu] tempu[][v] = ub[][i];
  mpiAllReduce(tempu[], ubg[], mpiCommWorld, mpiSUM);
  if (monitorflag) getmonitors(ubg);
  if (mpirank == 0 && statsfile != "") printstats(statsfile, tdnsfileout + ".tdns", meshfile, 0, 0, time);
  if (saveflag && mpirank == 0 && tdnsfileout != ""){
    cout << "  Saving '" + tdnsfileout + ".tdns' on '" + meshfile + "' in '" + workdir + "'." << endl;
    if (statsfile == "") {
      cout << "\ttime = " << time;
      if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
      if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
      cout << "." << endl;
    }
    {
      ofstream file(workdir + tdnsfileout + ".tdns", binary);
      file.precision(17);
      file << "mesh\t" << meshfile << endl;
      file << "init\t" << ICfile << endl;
      file << "time\t" << time << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file << monitornames[k] << "\t" << monitors[monitornames[k]] << endl;
        }
      }
      file << ubg[] << endl;
    }
    if (paraviewflag > 0){
      cout << "  Saving '" + tdnsfileout + "_tdns.vtu' in '" + workdir + "'." << endl;
      if (paraviewflag > 1){
        meshN Thgs = trunc(Thg, 1, split = paraviewflag);
        fespace XMhs(Thgs, Pk);
        XMhs defu(us) = defu(ubg);
        savevtk(workdir + tdnsfileout + "_tdns.vtu", Thgs, adaptu(us), dataname = ParaviewDataName, order = ParaviewOrder);
      }
      else {
        savevtk(workdir + tdnsfileout + "_tdns.vtu", Thg, adaptu(ubg), dataname = ParaviewDataName, order = ParaviewOrder);
      }
    }
  }
}//EOM

macro savewnl2(wnlfileout, hopffile, meshfile, q2param, sym, omega, alpha, beta, saveflag){
  if (saveflag){
    XMhg<complex> defu(tempu), defu(umg), defu(um2g), defu(um3g);
    XMhg<complex>[int] defu(umgparam)(paramnames.n);
    if(paramnames[0] != ""){
      for (int k = 0; k < paramnames.n; ++k){
        um[] = q2param[k][];
        for[i, v : restu] tempu[][v] = um[][i];
        mpiAllReduce(tempu[], umg[], mpiCommWorld, mpiSUM);
        umgparam[k][] = umg[];
      }
    }
    for[i, v : restu] tempu[][v] = um2[][i];
    mpiAllReduce(tempu[], um2g[], mpiCommWorld, mpiSUM);
    for[i, v : restu] tempu[][v] = um3[][i];
    mpiAllReduce(tempu[], um3g[], mpiCommWorld, mpiSUM);
    if (mpirank == 0 && wnlfileout != ""){
      cout << "  Saving '" + wnlfileout + ".wnl2' over '" + hopffile + "' on '" + meshfile + "' in '" + workdir + "'." << endl;
      cout << "\tsym = " + sym + ", omega = " + (omega);
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          cout << ", alpha[" + paramnames[k] + "] = " + alpha[paramnames[k]];
        }
      }
       cout << ", beta = " + (beta);
      if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
      cout << "." << endl;
      {
        ofstream file(workdir + wnlfileout + ".wnl2", binary);
        file.precision(17);
        file << "mesh\t" << meshfile << endl;
        file << "file\t" << hopffile << endl;
        file << "sym\t" << sym << endl;
        file << "omega\t" << omega << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << "alpha[" + paramnames[k] + "]" << alpha[paramnames[k]] << endl;
          }
        }
        file << "beta\t" << beta << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << paramnames[k] << "\t" << params[paramnames[k]] << endl;
          }
        }
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << umgparam[k][] << endl;
          }
        }
        file << um2g[] << endl;
        file << um3g[] << endl;
      }
      if (paraviewflag > 0){
        cout << "  Saving '" + wnlfileout + "_wnl2_[param[:],mean,harm].vtu' in '" + workdir + "'." << endl;
        if (paraviewflag > 1){
          meshN Thgs = trunc(Thg, 1, split = paraviewflag);
          fespace XMhs(Thgs, Pk);
          XMhs<complex> defu(ums);
          XMhs defu(usr), defu(usi);
          if(paramnames[0] != ""){
            for (int k = 0; k < paramnames.n; ++k){
              umg[] = umgparam[k][];
              defu(ums) = defu(umg);
              usr[] = ums[].re;
              usi[] = ums[].im;
              savevtk(workdir + wnlfileout + "_wnl2_param[" + k + "].vtu", Thg, adaptu(usr), adaptu(usi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
            }
          }
          defu(ums) = defu(um2g);
          usr[] = ums[].re;
          usi[] = ums[].im;
          savevtk(workdir + wnlfileout + "_wnl2_mean.vtu", Thgs, adaptu(usr), adaptu(usi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
          defu(ums) = defu(um3g);
          usr[] = ums[].re;
          usi[] = ums[].im;
          savevtk(workdir + wnlfileout + "_wnl2_harm.vtu", Thgs, adaptu(usr), adaptu(usi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        }
        else {
          XMhg defu(usr), defu(usi);
          if(paramnames[0] != ""){
            for (int k = 0; k < paramnames.n; ++k){
              umg[] = umgparam[k][];
              usr[] = umg[].re;
              usi[] = umg[].im;
              savevtk(workdir + wnlfileout + "_wnl2_param[" + k + "].vtu", Thg, adaptu(usr), adaptu(usi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
            }
          }
          usr[] = um2g[].re;
          usi[] = um2g[].im;
          savevtk(workdir + wnlfileout + "_wnl2_mean.vtu", Thg, adaptu(usr), adaptu(usi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
          usr[] = um3g[].re;
          usi[] = um3g[].im;
          savevtk(workdir + wnlfileout + "_wnl2_harm.vtu", Thg, adaptu(usr), adaptu(usi), dataname = ParaviewDataNamec, order = ParaviewOrderc);
        }
      }
    }
  }
}//EOM

func bool printstats(string outputfilename, string filename, string meshfilename, int sym, real omega, real time) {
      cout << "  Saving solution stats to '" + outputfilename + ".cont' in '" + workdir + "'." << endl;
      if(paramnames[0] != "" || monitornames[0] != "" || time != 0 || omega != 0.0 || sym != 0) cout << "\t";
      if (omega != 0.0 | sym != 0) cout << "sym = " + sym + ", omega = " + omega;
      if (time != 0.0) cout << "time = " + time;
      if((paramnames[0] != "" || monitornames[0] != "") && (time != 0 || omega != 0.0 || sym != 0)) cout << ", ";
      if(paramnames[0] != "") cout << listparams(paramnames, params);
      if(paramnames[0] != "" && monitornames[0] != "") cout << ", ";
      if(monitornames[0] != "") cout << listparams(monitornames, monitors);
      if(paramnames[0] != "" || monitornames[0] != "" || time != 0 || omega != 0.0 || sym != 0) cout << "." << endl;
      {
        ofstream file(workdir + outputfilename + ".cont", append);
        file.precision(17);
        file << filename << "\t" << meshfilename;
        if (omega != 0.0 | sym != 0) file << "\t" << sym << "\t" << omega;
        if (time != 0.0) file << "\t" << time;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << "\t" << params[paramnames[k]];
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << "\t" << monitors[monitornames[k]];
          }
        }
        file << endl;
      }
      return 0;
    }

func bool printgains(string outputfilename, string basefilename, string meshfilename, int sym, real omega, real[int] & gains) {
      cout << "  Saving " + gains.n + " optimal gain(s) to '" + outputfilename + ".gain' in '" + workdir + "'." << endl;
      cout << "\tsym = " + sym + ", omega = " + omega + ", gain(s) = [" + gains(0);
      for (int kk = 1; kk < gains.n; ++kk){
        cout << ", " + gains(kk);
      }
      cout << "]";
      if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
      if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
      cout << "." << endl;
      for (int kk = 0; kk < gains.n; ++kk){
        ofstream file(workdir + outputfilename + ".gain", append);
        file.precision(17);
        file << basefilename << "\t" << meshfilename << "\t" << sym << "\t" << omega << "\t" << gains(kk);
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file <<  "\t" << params[paramnames[k]];
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << "\t" << monitors[monitornames[k]];
          }
        }
        file << endl;
      }
      return 0;
    }

func bool printevals(string outputfilename, string basefilename, string meshfilename, int sym, complex[int] & eigenvalue) {
      cout << "  Saving " + eigenvalue.n + " eigenvalues to '" + outputfilename + ".eval' in '" + workdir + "'." << endl;
      cout << "\tsym = " + sym;
      if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
      if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
      cout << "." << endl;
      for (int kk = 0; kk < eigenvalue.n; ++kk){
        ofstream file(workdir + outputfilename + ".eval", append);
        file.precision(17);
        file << basefilename << "\t" << meshfilename << "\t" << sym << "\t" << eigenvalue(kk) << endl;
        if(paramnames[0] != ""){
          for (int k = 0; k < paramnames.n; ++k){
            file << "\t" << params[paramnames[k]];
          }
        }
        if(monitornames[0] != ""){
          for (int k = 0; k < monitornames.n; ++k){
            file << "\t" << monitors[monitornames[k]];
          }
        }
        file << endl;
      }
      return 0;
    }

func string readmeshname(string inputfilename) {
  string meshfilename;
  { ifstream file(inputfilename);
    file >> meshfilename >> meshfilename;
  }
  return meshfilename;
}

func string readbasename(string inputfilename) {
  string basefilename;
  { ifstream file(inputfilename);
    file >> basefilename >> basefilename >> basefilename >> basefilename;
  }
  return basefilename;
}
func complex readmodeeval(string inputfilename, int & sym) {
  complex eigenvalue;
  string dummy;
  { ifstream file(inputfilename);
    for (int k = 0; k < (paramnames.n+2); ++k){
      file >> dummy >> dummy;
    }
    file >> dummy >> sym;
    file >> dummy >> eigenvalue;
  }
  return eigenvalue;
}


func real[int] loadbase(string inputfilename, string meshfilename) {
      XMhg defu(ubg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".base' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string filemesh;
      ifstream file(workdir + inputfilename + ".base");
      file >> filemesh >> filemesh;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        if(paramnames[0] != "" || monitornames[0] != "") cout << "\t";
        if(paramnames[0] != "") cout << listparams(paramnames, params);
        if(paramnames[0] != "" && monitornames[0] != "") cout << ", ";
        if(monitornames[0] != "") cout << listparams(monitornames, monitors);
        if(paramnames[0] != "" || monitornames[0] != "") cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1);
        file >> ubg1[];
        defu(ubg) = defu(ubg1);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      return qlocal;
    }

func real[int] loadfold(string inputfilename, string meshfilename, real[int] & qmlocal, real[int] & qmalocal) {
      XMhg defu(ubg), defu(umg), defu(umag);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".fold' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string filemesh;
      ifstream file(workdir + inputfilename + ".fold");
      file >> filemesh >> filemesh;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        if(paramnames[0] != "" || monitornames[0] != "") cout << "\t";
        if(paramnames[0] != "") cout << listparams(paramnames, params);
        if(paramnames[0] != "" && monitornames[0] != "") cout << ", ";
        if(monitornames[0] != "") cout << listparams(monitornames, monitors);
        if(paramnames[0] != "" || monitornames[0] != "") cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        file >> umg[];
        file >> umag[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1), defu(umg1), defu(umag1);
        file >> ubg1[];
        file >> umg1[];
        file >> umag1[];
        defu(ubg) = defu(ubg1);
        defu(umg) = defu(umg1);
        defu(umag) = defu(umag1);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      qmlocal = umg[](restu);
      qmalocal = umag[](restu);
      return qlocal;
    }

func real[int] loadhopf(string inputfilename, string meshfilename, complex[int] & qmlocal, complex[int] & qmalocal, int & sym, real & omega) {
      XMhg defu(ubg);
      XMhg<complex> defu(umg), defu(umag);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".hopf' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string dummy, filemesh;
      ifstream file(workdir + inputfilename + ".hopf");
      file >> dummy >> filemesh >> dummy >> sym >> dummy >> omega;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\tsym = " + sym + ", omega = " + omega;
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
        file >> umg[];
        file >> umag[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1);
        XMhg1<complex> defu(umg1), defu(umag1);
        file >> ubg1[];
        file >> umg1[];
        file >> umag1[];
        defu(ubg) = defu(ubg1);
        defu(umg) = defu(umg1);
        defu(umag) = defu(umag1);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      qmlocal = umg[](restu);
      qmalocal = umag[](restu);
      return qlocal;
    }

func complex[int] loadmode(string inputfilename, string meshfilename, int & sym, complex & eigenvalue) {
      XMhg<complex> defu(umg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".mode' over '";
      string filemesh, basefilename, dummy;
      real[string] tempparams;
      ifstream file(workdir + inputfilename + ".mode");
      file >> filemesh >> filemesh >> basefilename >> basefilename >> dummy >> sym >> dummy >> eigenvalue;
      if (mpirank == 0) cout << basefilename + "' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> tempparams[paramnames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\tsym = " + sym + ", eval = " + eigenvalue;
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, tempparams);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> umg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1<complex> defu(umg1);
        file >> umg1[];
        defu(umg) = defu(umg1);
      }
      complex[int] qlocal = umg[](restu);
      return qlocal;
    }

func complex[int] loadresolvent(string inputfilename, string meshfilename, complex[int] & fmlocal, int & sym, real & omega, real & gain) {
      Xhg<complex> deff(fmg);
      XMhg<complex> defu(umg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".rslv' over '";
      string filemesh, basefilename, dummy;
      real[string] tempparams;
      ifstream file(workdir + inputfilename + ".rslv");
      file >> filemesh >> filemesh >> basefilename >> basefilename >> dummy >> sym >> dummy >> omega >> dummy >> gain;
      if (mpirank == 0) cout << basefilename + "' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> tempparams[paramnames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\tsym = " + sym + ", omega = " + omega + ", gain = " + gain;
        if(paramnames[0] != "") cout << ", " + listparams(paramnames,tempparams);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> fmg[] >> umg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace Xhg1(Thg1, Pkf);
        Xhg1<complex> deff(fmg1);
        fespace XMhg1(Thg1, Pk);
        XMhg1<complex> defu(umg1);
        file >> fmg1[] >> umg1[];
        deff(fmg) = deff(fmg1);
        defu(umg) = defu(umg1);
      }
      fmlocal = fmg[](restf);
      complex[int] qlocal = umg[](restu);
      return qlocal;
    }

func real[int] loadtdns(string inputfilename, string meshfilename, real& time) {
      XMhg defu(ubg);
      if (mpirank == 0) cout << "  Loading '" + inputfilename + ".tdns' on '" + meshfilename + "' from '" + workdir + "'." << endl;
      string filemesh, ICfile, dummy;
      ifstream file(workdir + inputfilename + ".tdns");
      file >> filemesh >> filemesh >> ICfile >> ICfile >> dummy >> time;
      if(paramnames[0] != ""){
        for (int k = 0; k < paramnames.n; ++k){
          file >> paramnames[k] >> params[paramnames[k]];
        }
      }
      if(monitornames[0] != ""){
        for (int k = 0; k < monitornames.n; ++k){
          file >> monitornames[k] >> monitors[monitornames[k]];
        }
      }
      if (mpirank == 0) {
        cout << "\ttime = " << time;
        if(paramnames[0] != "") cout << ", " + listparams(paramnames, params);
        if(monitornames[0] != "") cout << ", " + listparams(monitornames, monitors);
        cout << "." << endl;
      }
      if (filemesh == meshfilename){ // no interpolation needed
        file >> ubg[];
      }
      else { // must interpolate
        if (mpirank == 0) cout << "\tMesh mismatch. Interpolating from '" << filemesh << "'." << endl;
        meshN Thg1 = readmeshN(workdir + filemesh);
        fespace XMhg1(Thg1, Pk);
        XMhg1 defu(ubg1);
        file >> ubg1[];
        defu(ubg) = defu(ubg1);
      }
      setparams(paramnames, params);
      real[int] qlocal = ubg[](restu);
      return qlocal;
    }


// parameter functions
  func real getlambda(string& contparam){
    real lambda;
    for (int k = 0; k < paramnames.n; ++k){
    if (contparam == paramnames[k]) lambda = params[paramnames[k]];
      }
    return lambda;
  }

  func int updatelambda(string& contparam, real lambda){
    for (int k = 0; k < paramnames.n; ++k){
      if (contparam == paramnames[k]) params[paramnames[k]] = lambda;
    }
    return 0;
  }
