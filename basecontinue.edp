//
// basecontinue.edp
// Chris Douglas
// chris.douglas@ladhyx.polytechnique.fr
//
// EXAMPLE USAGE:
//  Continue input file along parameter without mesh adaptation:
// mpirun -n 4 FreeFem++-mpi -v 0 basecontinue.edp -fi <FILEIN> -param <PARAM>
//
//  Continue input file along parameter with mesh adaptation:
// mpirun -n 4 FreeFem++-mpi -v 0 basecontinue.edp -fi <FILEIN> -param <PARAM> -mo <MESHOUT>
//
// NOTE: This file should not be changed unless you know what you're doing.
//
load "iovtk"
load "PETSc"
include "settings.idp"
include "macros_bifbox.idp"
// arguments
string meshin = getARGV("-mi", ""); // input meshfile with extension
string meshout = getARGV("-mo", "");
string filein = getARGV("-fi", "");
string fileout = getARGV("-fo", filein);
int count = getARGV("-count", 0);
int savecount = getARGV("-scount", 1);
int maxcount = getARGV("-maxcount", 100);
real h0 = getARGV("-h0", 1.0);
string param = getARGV("-param", "");
string adaptto = getARGV("-adaptto", "b");
real fmax = getARGV("-fmax", 2.0);
real kappamax = getARGV("-kmax", 0.5);
real deltamax = getARGV("-dmax", 4.0);
real alphamax = getARGV("-amax", 30.)*pi/180.0;
int monotone = getARGV("-mono", 1);
real eps = getARGV("-eps", 1e-7);
string ksptype = getARGV("-ksp_type", "preonly");
string pctype = getARGV("-pc_type", "lu");
real snesrtol = getARGV("-snes_rtol", 0.0);
int snesmaxit = getARGV("-snes_max_it", 10);
string sneslinesearchtype = getARGV("-snes_linesearch_type", "basic"); // set -snes_linesearch_type
int refactor = getARGV("-refact", snesmaxit);

// Load mesh, make FE basis
string fileroot, meshroot;
string fileext = parsefilename(filein, fileroot); //extract file name and extension
parsefilename(fileout, fileout); // trim extension from output file, if given
if(fileext == "mode" || fileext == "rslv") {
  filein = readbasename(workdir + filein);
  fileext = parsefilename(filein, fileroot);
}
if(meshin == "") meshin = readmeshname(workdir + filein); // get mesh file
string meshext = parsefilename(meshin, meshroot);
parsefilename(meshout, meshroot); // trim extension from output mesh, if given
if(count > 0) {
  fileroot = fileroot(0:fileroot.rfind("_" + count)-1); // get file root
  meshroot = meshroot(0:meshroot.rfind("_" + count)-1); // get file root
}
bool adapt = false;
if(meshout == "") meshout = meshin; // if no adaptation
else adapt = true;  // if output meshfile is given, adapt mesh
Th = readmeshN(workdir + meshin);
Thg = Th;
buildDmesh(Th);
restu = restrict(XMh, XMhg, n2o);
XMh defu(ub), defu(um), defu(yb), defu(um2);
if(count == 0) {
  if(fileext == "base") {
    ub[] = loadbase(fileroot, meshin);
  }
  else if(fileext == "fold") {
    real[int] qm, qma;
    ub[] = loadfold(fileroot, meshin, qm, qma);
  }
  else if(fileext == "hopf") {
    int m;
    real omega;
    complex[int] qm, qma;
    ub[] = loadhopf(fileroot, meshin, qm, qma, m, omega);
  }
  if(mpirank == 0 && savecount > 0) printstats(fileout, filein, meshin, 0, 0, 0);
}
else {
  ub[] = loadbase(fileroot + "_" + count, meshin);
}
real lambda = getlambda(param);

Mat J, Ja;
createMatu(Th, J, Pk);
int m = 0;
real ik = 0.0, ik2 = 0.0, ik3 = 0.0, iomega = 0.0, iomega2 = 0.0;
include "eqns.idp"
// Build bordered block matrix from only Mat components
Mat JlPM(J.n, mpirank == 0 ? 1 : 0), yqPM(J.n, mpirank == 0 ? 1 : 0); // Initialize Mat objects for bordered matrix
Ja = [[J,JlPM],[yqPM',-1.0]]; // make dummy Jacobian

real[int] yqP(J.n), qap(J.n + (mpirank == 0 ? 1 : 0)), yqP0(J.n);
int it, internalit, adaptflag;
real f, kappa, alpha, res, resp, delta, deltap, maxdelta;
// FUNCTIONS
  func real[int] funcRa(real[int]& qa) {
      ChangeNumbering(J, ub[], qa(0:qa.n - (mpirank == 0 ? 2 : 1)), inverse = true, exchange = true); // PETSc to FreeFEM
      if(mpirank == 0) lambda = qa(qa.n-1); // Extract parameter value from state vector on proc 0
      broadcast(processor(0), lambda);
      updatelambda(param, lambda);
      real[int] Ra, R = vR(0, XMh, tgv = -1);
      ChangeNumbering(J, R, Ra); // FreeFEM to PETSc
      if(mpirank == 0) {
          Ra.resize(Ra.n+1); // Append 0 to residual vector on proc 0
          Ra(Ra.n-1) = 0.0;
      }
      res = sqrt(J(R, R));
      string text1;
      if (!adaptflag) text1 = count + "-" + it;
      else text1 = "A" + (count-1) + "-" + it;
      if(internalit > 0) text1 = text1 + ">" + internalit;
      if (it == 0){
        kappa = 0.0;
        maxdelta = 0.0;
        alpha = 0.0;
        delta = abs(h0);
        if(mpirank == 0) cout << "  " + text1 + ":\t||R|| = " << res << ",\th0 = " << h0 << ",\t" + param + " = " << lambda << "." << endl;
      }
      else {
        real dlambda;
        if(mpirank == 0) dlambda = lambda - qap(qap.n-1); // Extract parameter value from state vector on proc 0
        broadcast(processor(0), dlambda);
        real[int] qdiff  = qa(0:qa.n - (mpirank == 0 ? 2 : 1)) - qap(0:qap.n - (mpirank == 0 ? 2 : 1));
        ChangeNumbering(J, R, qdiff, inverse = true, exchange = false);
        delta = sqrt(J(R, R) + dlambda^2); // distance to curve
        ChangeNumbering(J, R, yqP0, inverse = true, exchange = false);
        ChangeNumbering(J, yb[], yqP, inverse = true, exchange = false);
        alpha = (J(R, yb[]) + 1.0)/sqrt((J(R, R) + 1.0)*(J(yb[], yb[]) + 1.0));
        kappa = max(delta/deltap, kappa);
        maxdelta = max(delta, maxdelta);
        if(mpirank == 0) cout << "  " + text1 + ":\t||R|| = " << res << ",\t||dx|| = " << delta << ",\tangle = " << (sign(alpha)*acos(abs(alpha))*180./pi) << ",\t" + param + " = " << lambda << "." << endl;
      }
      f = max(acos(abs(alpha))/alphamax*fmax, sqrt(maxdelta/deltamax)*fmax, sqrt(kappa/kappamax)*fmax, 1./fmax);
      if (it > 0 && !adaptflag && (f > fmax || it-1 >= snesmaxit || res*(monotone!=0) > resp)) Ra(0) = NaN();
      ++internalit;
      return Ra;
  }

  func int funcJa(real[int]& qa) {
      ++it;
      internalit = 0;
      qap = qa;
      resp = res;
      deltap = delta;
      ChangeNumbering(J, ub[], qa(0:qa.n - (mpirank == 0 ? 2 : 1)), inverse = true, exchange = true); // PETSc to FreeFEM
      if(mpirank == 0) lambda = qa(qa.n-1); // Extract parameter value from state vector on proc 0
      broadcast(processor(0), lambda);
      updatelambda(param, lambda + eps);
      real[int] Jl = vR(0, XMh, tgv = -1);
      updatelambda(param, lambda);
      real[int] Jltemp = vR(0, XMh, tgv = -1);
      Jl -= Jltemp;//vR(0, XMh, tgv = -1);
      Jl /= eps;
      if (it == 1 | refactor >= it) J = vJ(XMh, XMh, tgv = -1);
      ChangeNumbering(J, Jl, yqP); // FreeFEM to PETSc
      matrix tempPms = [[yqP]]; // dense array to sparse matrix
      ChangeOperator(JlPM, tempPms, parent = Ja); // send to Mat
      KSPSolve(J, yqP, yqP); // compute tangent vector in PETSc numbering
      tempPms = [[yqP]]; // dense array to sparse matrix
      ChangeOperator(yqPM, tempPms, parent = Ja); // send to Mat
      return 0;
  }

set(Ja, sparams = "-ksp_type preonly -pc_type fieldsplit -pc_fieldsplit_type schur -pc_fieldsplit_schur_precondition self ", setup = 1);
set(J, sparams = " -fieldsplit_0_ksp_type " + ksptype + " -fieldsplit_0_pc_type " + pctype + " " + KSPparams, prefix = "fieldsplit_0_", parent = Ja);

// PREDICTOR
real[int] qa;
ChangeNumbering(J, ub[], qa);
if(mpirank == 0) {
  qa.resize(qa.n+1);
  qa(qa.n-1) = lambda;
}
broadcast(processor(0), lambda);
{
  updatelambda(param, lambda + eps);
  real[int] Jl = vR(0, XMh, tgv = -1);
  updatelambda(param, lambda);
  real[int] Jltemp = vR(0, XMh, tgv = -1);
  Jl -= Jltemp;//vR(0, XMh, tgv = -1);
  Jl /= eps;
  J = vJ(XMh, XMh, tgv = -1);
  ChangeNumbering(J, Jl, yqP); // FreeFEM to PETSc
  KSPSolve(J, yqP, yqP);
  yqP0 = yqP;
}
while (count < maxcount){
  real[int] qa0 = qa;
  ChangeNumbering(J, yb[], yqP, inverse = true, exchange = false); // PETSc to FreeFEM
  real h = h0/sqrt(J(yb[] ,yb[]) + 1.0); // use FreeFEM numbering here
  qa(0:qa.n - (mpirank == 0 ? 2 : 1)) -= (h*yqP);
  if (mpirank == 0) {
    qa(qa.n-1) += h; // -= (-1.0*h)
    lambda = qa(qa.n-1);
  }
  broadcast(processor(0), lambda);
  updatelambda(param, lambda);
  // CORRECTOR LOOP
  int ret;
  it = 0;
  internalit = 0;
  adaptflag = 0;
  SNESSolve(Ja, funcJa, funcRa, qa, reason = ret,
            sparams = " -snes_rtol " + snesrtol
                    + " -snes_linesearch_type " + sneslinesearchtype
                    + " -snes_max_it " + snesmaxit
                    + " -snes_converged_reason "
                    + " "); // solve nonlinear problem with SNES
  if (ret > 0) {
    ++count;
    h0 /= f;
    if (alpha < 0) {
      h0 *= -1.0;
      ChangeNumbering(J, ub[], qa(0:qa.n - (mpirank == 0 ? 2 : 1)), inverse = true);
      if(mpirank == 0) lambda = qa(qa.n-1);
      broadcast(processor(0), lambda);
      updatelambda(param, lambda);
      if(mpirank == 0) cout << "\tFold detected. Orientation reversed." << endl;
      savebase(fileout + "_" + count + "foldguess", "", meshout, true, true);
    }
    if (adapt && (count % savecount == 0)){
      meshout = meshroot + "_" + count + "." + meshext;
      ChangeNumbering(J, ub[], qa(0:qa.n - (mpirank == 0 ? 2 : 1)), inverse = true, exchange = false);
      if(mpirank == 0) lambda = qa(qa.n-1);
      broadcast(processor(0), lambda);
      updatelambda(param, lambda);
      ChangeNumbering(J, yb[], yqP, inverse = true, exchange = false);
      XMhg defu(uG), defu(yG), defu(tempu);
      for[i, v : restu] tempu[][v] = ub[][i];
      mpiAllReduce(tempu[], uG[], mpiCommWorld, mpiSUM);
      for[i, v : restu] tempu[][v] = yb[][i];
      mpiAllReduce(tempu[], yG[], mpiCommWorld, mpiSUM);
      if(mpirank == 0) {
        if(adaptto == "b") Thg = adaptmesh(Thg, adaptu(uG), adaptmeshoptions);
        if(adaptto == "by") Thg = adaptmesh(Thg, adaptu(uG), adaptu(yG), adaptmeshoptions);
      }
      broadcast(processor(0), Thg);
      defu(uG) = defu(uG);
      defu(yG) = defu(yG);
      Th = Thg;
      Mat Adapt;
      createMatu(Th, Adapt, Pk);
      J = Adapt;
      defu(ub) = initu(0.0);
      defu(yb) = initu(0.0);
      restu.resize(ub[].n); // Change size of restriction operator
      restu = restrict(XMh, XMhg, n2o); // Compute new restriction from global mesh to local mesh
      ub[] = uG[](restu);
      yb[] = yG[](restu);
      Mat Adapt1(J.n, mpirank == 0 ? 1 : 0), Adapt2(J.n, mpirank == 0 ? 1 : 0); // Initialize Mat objects for bordered matrix
      JlPM = Adapt1;
      yqPM = Adapt2;
      Ja = [[J,JlPM],[yqPM',-1.0]]; // make dummy Jacobian
      set(Ja, sparams = "-ksp_type preonly -pc_type fieldsplit -pc_fieldsplit_type schur -pc_fieldsplit_schur_precondition self ", setup = 1);
      set(J, sparams = " -fieldsplit_0_ksp_type " + ksptype + " -fieldsplit_0_pc_type " + pctype + " " + KSPparams, prefix = "fieldsplit_0_", parent = Ja);
      qa.resize(J.n);
      ChangeNumbering(J, ub[], qa);
      if(mpirank == 0) {
        qa.resize(qa.n+1);
        qa(qa.n-1) = lambda;
      }
      yqP.resize(J.n);
      ChangeNumbering(J, yb[], yqP);
      yqP0.resize(J.n);
      yqP0 = yqP;
      qa0.resize(qa.n);
      qap.resize(qa.n);
      it = 0;
      internalit = 0;
      adaptflag = 1;
      SNESSolve(Ja, funcJa, funcRa, qa, reason = ret,
                sparams = " -snes_rtol " + snesrtol
                        + " -snes_linesearch_type " + sneslinesearchtype
                        + " -snes_converged_reason "
                        ); // solve nonlinear problem with SNES
      assert(ret > 0);
      if(mpirank==0) { // Save adapted mesh
        cout << "  Saving adapted mesh '" + meshout + "' in '" + workdir + "'." << endl;
        savemesh(Thg, workdir + meshout);
      }
    }
    ChangeNumbering(J, ub[], qa(0:qa.n - (mpirank == 0 ? 2 : 1)), inverse = true);
    if(mpirank == 0) lambda = qa(qa.n-1);
    broadcast(processor(0), lambda);
    updatelambda(param, lambda);
    savebase(fileout + "_" + count, (savecount > 0 ? fileout : ""), meshout, (count % savecount == 0), true);
    yqP0 = yqP;
  }
  else {
    if (mpirank == 0){
      if(res*(monotone!=0) >= resp) cout << "\tResidual norm failed to decrease. Reattempting with smaller step." << endl;
      if(kappa >= kappamax) cout << "\tContraction rate exceeds " << kappamax << ". Reattempting with smaller step." << endl;
      if(it >= snesmaxit) cout << "\tFailed to converge within limit of " + snesmaxit + " iterations. Reattempting with smaller step." << endl;
      if(maxdelta >= deltamax) cout << "\tStep size exceeds " << deltamax << "." << endl;
      if(acos(abs(alpha)) >= alphamax) cout << "\tAngle exceeds " << (alphamax*180./pi) << " degrees." << endl;
    }
    h0 /= fmax;
    qa = qa0;
  }
}
