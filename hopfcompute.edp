//
// hopfcompute.edp
// Chris Douglas
// chris.douglas@ladhyx.polytechnique.fr
//
// EXAMPLE USAGE:
//  Initialize with Hopf guess from base file, solve on same mesh
// mpirun -n 4 FreeFem++-mpi -v 0 hopfcompute.edp -param <PARAM> -fi <FILEIN> -bfi <BASEFILEIN> -fo <FILEOUT>
//
//  Initialize with Hopf from base and mode file, solve on same mesh
// mpirun -n 4 FreeFem++-mpi -v 0 hopfcompute.edp -param <PARAM> -fi <FILEIN> -fo <FILEOUT>
//
//  Initialize with Hopf guess from file on a mesh from file
// mpirun -n 4 FreeFem++-mpi -v 0 hopfcompute.edp -param <PARAM> -mi <MESHIN> -bfi <BASEFILEIN> -fi <FILEIN> -fo <FILEOUT>
//
//  Initialize with Hopf from file, adapt mesh/solution
// mpirun -n 4 FreeFem++-mpi -v 0 hopfcompute.edp -param <PARAM> -fi <FILEIN> -fo <FILEOUT> -mo <MESHOUT>
//
// NOTE: This file should not be changed unless you know what you're doing.
//
/*
RESIDUAL EVALUATION IN MINIMALLY AUGMENTED FORMULATION
 We can directly compute the residual using the varf vR().
 To build Ra, we must additionally compute the Hopf residual augmentation:
     g = v'*(1i*omega*M + J)*w = v'*L*w
 where g is the Hopf residual and v & w are the adjoint & direct eigenvectors.
 g, v, and w, can be found using minimially augmented systems:
 (For more details, see Govaerts, (2000), Ch. 4, particularly page 87.)
       ┌                 ┐┌   ┐   ┌   ┐
       | -L         M*p0 || w |   | 0 |
  (1)  |                 ||   | = |   |
       | (M*q0)'    0    || g |   | 1 |
       └                 ┘└   ┘   └   ┘
 where q0, p0 are initial approximations of the direct & adjoint eigenvectors.
 This implies:
     L*w = M*p0*g  and  (M*q0)'*w = 1
 so
     w = L^-1*M*p0*g  and  g = 1.0/((M*q0)'*L^-1*M*p0)

 At g = 0, we have L*w = 0 and (M*q0)'*w = 1.

 Similarly, we can find the adjoint eigenmode using the related system:
                        ┌                  ┐
       ┌               ┐| -L          M*p0 |   ┌        ┐
  (2)  |  v'   conj(h) ||                  | = | 0    1 |
       └               ┘| (M*q0)'     0    |   └        ┘
                        └                  ┘
 This implies:
      v'*L = conj(h)*(M*q0)'  and  v'*M*p0 = 1
   or, taking the complex conjugate transpose:
        ┌                 ┐┌   ┐   ┌   ┐
        | -L'        M*q0 || v |   | 0 |
  (2')  |                 ||   | = |   |
        | (M*p0)'    0    || h |   | 1 |
        └                 ┘└   ┘   └   ┘
 giving, equivalently,
     L'*v = M*q0*h  and  (M*p0)'*v = 1
 so
     v = L'^-1*M*q0*h  and  h = 1.0/((M*p0)'*L'^-1*M*q0)

 At h = 0, we have L'*v = 0 and (M*p0)'*v = 1, so v'*L = 0 and v'*M*p0 = 1.

 It can be confirmed that g = conj(h) and that g = v'*L*w, h = w'*L'*v.

JACOBIAN CONSTRUCTION IN MINIMALLY AUGMENTED FORMULATION
 Having computed the RHS of the augmented system in funcRa, we now have
 to build the complex augmented Jacobian matrix for the Newton scheme:
       ┌                                  ┐┌         ┐   ┌   ┐
       | J        dJ/dlambda    0         || dq      |   | R |
  (3)  |                                  || dlambda | = |   |
       | dg/dq'   dg/dlambda    dg/domega || domega  |   | g |
       └                                  ┘└         ┘   └   ┘
 where g = v'*L*w
 which gives, in real arithmetic:
    J*dq           + dJ/dlambda*dlambda                                = R
    real(dg/dq)*dq + real(dg/dlambda)*dlambda + real(dg/domega)*domega = real(g)
   -imag(dg/dq)*dq + imag(dg/dlambda)*dlambda + imag(dg/domega)*domega = imag(g)

 To determine the matrix entries, we differentiate Eq. (1) along each
 z in q, lambda, omega to find:
       ┌                 ┐┌       ┐   ┌         ┐
       | -L         M*p0 || dw/dz |   | dL/dz*w |
  (4)  |                 ||       | = |         |
       | (M*q0)'    0    || dg/dz |   | 0       |
       └                 ┘└       ┘   └         ┘
 We now left-multiply Eq. (4) by [ v'   conj(h) ], finding due to Eq. (2) that:

  (5)  dg/dz = v'*dL/dz*w

 So we can write (3) explicitly as
       ┌                                                          ┐┌         ┐   ┌         ┐
       |  dR/dq              dJ/dlambda              0            || dq      |   | R       |
  (3)  |  real(v'*dL/dq*w)   real(v'*dL/dlambda*w)  -imag(v'*M*w) || dlambda | = | real(g) |
       | -imag(v'*dL/dq*w)   imag(v'*dL/dlambda*w)   real(v'*M*w) || domega  |   | imag(g) |
       └                                                          ┘└         ┘   └         ┘
*/

load "iovtk"
load "PETSc-complex"
include "settings.idp"
include "macros_bifbox.idp"
// arguments
string meshin = getARGV("-mi", "");
string meshout = getARGV("-mo", "");
string filein = getARGV("-fi", "");
string basefilein = getARGV("-bfi", "");
string fileout = getARGV("-fo", "");
bool normalform = getARGV("-nf", 1);
bool zerofreq = getARGV("-zero", 0);
string param = getARGV("-param", "");
string adaptto = getARGV("-adaptto", "b");
real eps = getARGV("-eps", 1e-7);
string ksptype = getARGV("-ksp_type", "preonly");
string pctype = getARGV("-pc_type", "lu");
string sneslinesearchtype = getARGV("-snes_linesearch_type", "basic"); // set -snes_linesearch_type
int sym;
real omega;
complex[string] alpha;
complex beta;

string fileroot, meshroot, basefileroot;
string fileext = parsefilename(filein, fileroot); //extract file name and extension
parsefilename(fileout, fileout); // trim extension from output file, if given
if((fileext == "mode" || fileext == "rslv") && basefilein == "") basefilein = readbasename(workdir + filein);
string basefileext = parsefilename(basefilein, basefileroot);
if(meshin == "") meshin = readmeshname(workdir + filein); // get mesh file
string meshext = parsefilename(meshin, meshroot);
parsefilename(meshout, meshout); // trim extension from output mesh, if given
// Load mesh, make FE basis
Th = readmeshN(workdir + meshin);
Thg = Th;
buildDmesh(Th);
restu = restrict(XMh, XMhg, n2o);
XMh<complex> defu(ub), defu(um), defu(uma), defu(um2), defu(um3);
if (fileext == "hopf") {
  ub[].re = loadhopf(fileroot, meshin, um[], uma[], sym, omega, alpha, beta);
}
else if (fileext == "mode") {
  complex eigenvalue;
  um[] = loadmode(fileroot, meshin, sym, eigenvalue);
  omega = imag(eigenvalue);
}
else if (fileext == "rslv") {
  real gain;
  complex[int] fm;
  um[] = loadresolvent(fileroot, meshin, fm, sym, omega, gain);
}
else assert(false); // invalid input filetype
if (basefileext == "base") {
  ub[].re = loadbase(basefileroot, meshin);
}
else if(basefileext == "fold") {
  real[string] alpha;
  real beta;
  real[int] qm, qma;
  ub[].re = loadfold(basefileroot, meshin, qm, qma, alpha, beta);
}
else if(basefileext == "hopf") {
  int sym;
  real omega;
  complex[string] alpha;
  complex beta;
  complex[int] qm, qma;
  ub[].re = loadhopf(basefileroot, meshin, qm, qma, sym, omega, alpha, beta);
}
else if(basefileext == "tdns") {
  real time;
  ub[].re = loadtdns(basefileroot, meshin, time);
}
real lambda = getlambda(param);
// Create distributed Mat
Mat<complex> J;
createMatu(Th, J, Pk);
complex ik, ik2 = 0.0, ik3 = 0.0, iomega, iomega2 = 0.0, iomega3 = 0.0;
include "eqns.idp"
// MESH ADAPTATION
bool adapt = false;
if(meshout == "") meshout = meshin; // if no adaptation
else { // if output meshfile is given, adapt mesh
  adapt = true;
  meshout = meshout + "." + meshext;
  complex[int] q;
  ChangeNumbering(J, ub[], q);
  ChangeNumbering(J, ub[], q, inverse = true);
  ChangeNumbering(J, um[], q);
  ChangeNumbering(J, um[], q, inverse = true);
  ChangeNumbering(J, uma[], q);
  ChangeNumbering(J, uma[], q, inverse = true);
  XMhg defu(uG), defu(umrG), defu(umiG), defu(umarG), defu(umaiG), defu(tempu);
  for[i, v : restu] tempu[][v] = real(ub[][i]);
  mpiAllReduce(tempu[], uG[], mpiCommWorld, mpiSUM);
  for[i, v : restu] tempu[][v] = real(um[][i]);
  mpiAllReduce(tempu[], umrG[], mpiCommWorld, mpiSUM);
  for[i, v : restu] tempu[][v] = imag(um[][i]);
  mpiAllReduce(tempu[], umiG[], mpiCommWorld, mpiSUM);
  for[i, v : restu] tempu[][v] = real(uma[][i]);
  mpiAllReduce(tempu[], umarG[], mpiCommWorld, mpiSUM);
  for[i, v : restu] tempu[][v] = imag(uma[][i]);
  mpiAllReduce(tempu[], umaiG[], mpiCommWorld, mpiSUM);
  if(mpirank == 0) {  // Perform mesh adaptation (serially) on processor 0
    if(adaptto == "b") Thg = adaptmesh(Thg, adaptu(uG), adaptmeshoptions);
    else if(adaptto == "bd") Thg = adaptmesh(Thg, adaptu(uG), adaptu(umrG), adaptu(umiG), adaptmeshoptions);
    else if(adaptto == "ba") Thg = adaptmesh(Thg, adaptu(uG), adaptu(umarG), adaptu(umaiG), adaptmeshoptions);
    else if(adaptto == "bda") Thg = adaptmesh(Thg, adaptu(uG), adaptu(umrG), adaptu(umiG), adaptu(umarG), adaptu(umaiG), adaptmeshoptions);
  } // TODO: add adaptation to endogeneity and structural sensitivity
  broadcast(processor(0), Thg);
  defu(uG) = defu(uG);
  defu(umrG) = defu(umrG);
  defu(umiG) = defu(umiG);
  defu(umarG) = defu(umarG);
  defu(umaiG) = defu(umaiG);
  Th = Thg;
  Mat<complex> Adapt;
  createMatu(Th, Adapt, Pk);
  J = Adapt;
  defu(ub) = initu(0.0);
  defu(um) = initu(0.0);
  defu(uma) = initu(0.0);
  restu.resize(ub[].n); // Change size of restriction operator
  restu = restrict(XMh, XMhg, n2o); // Compute new restriction from global mesh to local mesh
  ub[].re = uG[](restu);
  um[].re = umrG[](restu);
  um[].im = umiG[](restu);
  uma[].re = umarG[](restu);
  uma[].im = umaiG[](restu);
}
// Build bordered block matrix from only Mat components
Mat<complex> JlPM(J.n, mpirank == 0 ? 2 : 0), gqPM(J.n, mpirank == 0 ? 2 : 0), glPM(mpirank == 0 ? 2 : 0, mpirank == 0 ? 2 : 0); // Initialize Mat objects for bordered matrix
Mat<complex> H(J), Ja = [[J, JlPM], [gqPM', glPM]]; // make dummy Jacobian
complex[int] qm(J.n), qma(J.n), pP(J.n), qP(J.n);
// FUNCTIONS
  func complex[int] funcRa(complex[int]& qa) {
      ChangeNumbering(J, ub[], qa(0:qa.n - (mpirank == 0 ? 3 : 1)), inverse = true, exchange = true); // PETSc to FreeFEM
      if(mpirank == 0) {
        lambda = real(qa(qa.n-2)); // Extract parameter value from state vector on proc 0
        omega = zerofreq ? 0.0 : real(qa(qa.n-1)); // Extract frequency value from state vector on proc 0
      }
      broadcast(processor(0), lambda);
      broadcast(processor(0), omega);
      updatelambda(param, lambda);
      complex[int] Ra, R = vR(0, XMh, tgv = -1);
      ChangeNumbering(J, R, Ra); // FreeFEM to PETSc
      iomega = 1i*omega;
      ik = 1i*real(sym);
      J = vJ(XMh, XMh, tgv = -1);
      KSPSolve(J, pP, qm);
      KSPSolveHermitianTranspose(J, qP, qma);
      ChangeNumbering(J, R, qP, inverse = true);
      ChangeNumbering(J, um[], qm, inverse = true);
      complex g = 1.0/J(R, um[]);
      qm *= g; // rescale direct mode
      qma *= conj(g); // rescale adjoint mode
      if(mpirank == 0) {
        Ra.resize(Ra.n+2); // Append 0 to residual vector on proc 0
        Ra(Ra.n-2) = real(g);
        Ra(Ra.n-1) = zerofreq ? 0.0 : imag(g);
      }
      return Ra;
  }

  func int funcJa(complex[int]& qa) {
      ChangeNumbering(J, ub[], qa(0:qa.n - (mpirank == 0 ? 3 : 1)), inverse = true, exchange = true); // PETSc to FreeFEM
      if(mpirank == 0) {
        lambda = real(qa(qa.n-2)); // Extract parameter value from state vector on proc 0
        omega = zerofreq ? 0.0 : real(qa(qa.n-1)); // Extract frequency value from state vector on proc 0
      }
      broadcast(processor(0), lambda);
      broadcast(processor(0), omega);
      ChangeNumbering(J, um[], qm, inverse = true, exchange = true);
      ChangeNumbering(J, uma[], qma, inverse = true);
      int mm = sym;
      ik = 1i*real(sym);
      iomega = 1i*omega;
      updatelambda(param, lambda + eps);
      complex[int] Jl = vR(0, XMh, tgv = -1);
      complex[int] Hl = vJ(0, XMh, tgv = -10);
      updatelambda(param, lambda);
      complex[int] temp1, temp2(qm.n), bm = vR(0, XMh, tgv = -1);
      Jl -= bm;
      Jl /= eps;
      bm = vJ(0, XMh, tgv = -10);
      Hl -= bm;
      Hl /= eps;
      ChangeNumbering(J, Jl, temp1);
      temp1.im = 0.0;
      matrix<complex> tempPms = [[temp1, 0]]; // dense array to sparse matrix
      ChangeOperator(JlPM, tempPms, parent = Ja); // send to Mat
      sym = 0;
      H = vH(XMh, XMh, tgv = -10); // form the matrix (dL/dq*w)
      sym = mm;
      MatMultHermitianTranspose(H, qma, temp1); // compute (dL/dq*w)'*v
      if(!zerofreq) temp2.re = -temp1.im;
      temp1.im = 0.0;
      tempPms = [[temp1, temp2]]; // dense array to sparse matrix
      ChangeOperator(gqPM, tempPms, parent = Ja); // send to Mat
      complex gl = J(uma[], Hl);
      if(zerofreq)
        tempPms = [[real(gl), 0], [0, 1.0]];
      else {
        bm = vM(0, XMh, tgv = -10);
        complex gw = J(uma[], bm);
        tempPms = [[real(gl), -imag(gw)], [imag(gl), real(gw)]];
      }
      ChangeOperator(glPM, tempPms, parent = Ja); // send to Mat
      ik = 0.0;
      iomega = 0.0;
      sym = 0;
      J = vJ(XMh, XMh, tgv = -1);
      sym = mm;
      return 0;
  }

set(Ja, sparams = "-ksp_type preonly -pc_type fieldsplit -pc_fieldsplit_type schur -pc_fieldsplit_schur_precondition self ", setup = 1);
set(J, sparams = " -fieldsplit_0_ksp_type " + ksptype + " -fieldsplit_0_pc_type " + pctype + " " + KSPparams, prefix = "fieldsplit_0_", parent = Ja);

// Initialize
complex[int] qa;
ChangeNumbering(J, ub[], qa);
if(mpirank == 0) {
  qa.resize(qa.n+2);
  qa(qa.n-2) = lambda;
  qa(qa.n-1) = omega;
}
{
  complex[int] Mq = vM(0, XMh, tgv = -10);
  ChangeNumbering(J, Mq, qP);
  if (fileext == "hopf") {
    um[] = uma[];
    Mq = vM(0, XMh, tgv = -10);
    ChangeNumbering(J, Mq, pP);
  }
  else {
    J = vJ(XMh, XMh, tgv = -1);
    ChangeNumbering(J, um[], qm);
    KSPSolveHermitianTranspose(J, qm, pP);
    ChangeNumbering(J, um[], pP, inverse = true, exchange = true);
    Mq = vM(0, XMh, tgv = -10);
    ChangeNumbering(J, Mq, pP);
  }
}
// solve nonlinear problem with SNES
int ret;
SNESSolve(Ja, funcJa, funcRa, qa, reason = ret, sparams = " -snes_linesearch_type " + sneslinesearchtype
                                                        + " -snes_monitor -snes_converged_reason "
                                                        );
if (ret > 0) { // Save solution if solver converged and output file is given
  ChangeNumbering(J, ub[], qa(0:qa.n - (mpirank == 0 ? 3 : 1)), inverse = true, exchange = true);
  if(mpirank == 0) {
    lambda = real(qa(qa.n-2));
    omega = zerofreq ? 0.0 : real(qa(qa.n-1)); // Extract frequency value from state vector on proc 0
  }
  broadcast(processor(0), lambda);
  broadcast(processor(0), omega);
  updatelambda(param, lambda);
  ChangeNumbering(J, um[], qm, inverse = true, exchange = true);
  complex[int] Mq = vM(0, XMh, tgv = -10);
  complex Mnorm = sqrt(J(um[], Mq));
  um[] /= Mnorm; // so that <um[],M*um[]> = 1
  uma[] *= conj(Mnorm/J(uma[], Mq)); // so that <uma[],M*um[]> = 1
  ChangeNumbering(J, um[], qm);
  ChangeNumbering(J, uma[], qma);
  if (normalform){
    complex[int] qAAs(J.n), qAA(J.n), tempP(J.n), temp(um[].n), temp1(um[].n);
    complex[int,int] qDa(paramnames.n, J.n);
    int mm = sym;
    // 2nd-order
    //  A: base modification due to parameter changes
    ik = 0.0;
    ik2 = 0.0;
    iomega = 0.0;
    iomega2 = 0.0;
    sym = 0;
    J = vJ(XMh, XMh, tgv = -1);
    if(paramnames[0] != ""){
      for (int k = 0; k < paramnames.n; ++k){
        lambda = getlambda(paramnames[k]);
        updatelambda(paramnames[k], lambda + eps);
        temp = vR(0, XMh, tgv = -1);
        updatelambda(paramnames[k], lambda);
        temp1 = vR(0, XMh, tgv = -1);
        temp -= temp1;
        temp /= -eps;
        ChangeNumbering(J, temp, tempP); // FreeFEM to PETSc
        KSPSolve(J, tempP, qAAs);
        qDa(k, :) = qAAs;
      }
    }
    //  B: base modification due to quadratic nonlinear interaction
    ik = 1i*real(mm);
    ik2 = -ik;
    iomega = 1i*omega;
    iomega2 = -iomega;
    um2[] = conj(um[]);
    temp = vH(0, XMh, tgv = -10);
    temp.re *= -1.0; // -2.0/2.0
    temp.im = 0.0;
    ChangeNumbering(J, temp, tempP); // FreeFEM to PETSc
    KSPSolve(J, tempP, qAAs);
    //  C: harmonic generation due to quadratic nonlinear interaction
    ik = 1i*real(mm); ik2 = ik;
    iomega = 1i*omega; iomega2 = iomega;
    um2[] = um[];
    sym = 2*mm;
    temp = vH(0, XMh, tgv = -10);
    temp *= -0.5; // -1.0/2.0
    ChangeNumbering(J, temp, tempP); // FreeFEM to PETSc
    ik = 2i*real(mm);
    iomega = 2i*omega;
    J = vJ(XMh, XMh, tgv = -1);
    KSPSolve(J, tempP, qAA);
    // 3rd-order
    //  A: fundamental modification due to parameter change and quadratic interaction of fundamental with 2nd order modification A.
    sym = mm;
    ik = 1i*real(sym);
    ik2 = 0.0;
    iomega = 1i*omega;
    iomega2 = 0.0;
    if(paramnames[0] != ""){
      for (int k = 0; k < paramnames.n; ++k){
        lambda = getlambda(paramnames[k]);
        updatelambda(paramnames[k], lambda + eps);
        temp = vJ(0, XMh, tgv = -10);
        updatelambda(paramnames[k], lambda);
        temp1 = vJ(0, XMh, tgv = -10);
        temp -= temp1;
        temp /= eps;
        ChangeNumbering(J, um2[], qDa(k, :), inverse = true, exchange = true); // FreeFEM to PETSc
        temp += vH(0, XMh, tgv = -10); // 2.0/2.0
        alpha[paramnames[k]] = -J(uma[], temp);
      }
    }
    //  B: fundamental modification due to cubic self-interaction of fundamental
    ik = 1i*real(sym);
    ik2 = 1i*real(sym);
    ik3 = -1i*real(sym);
    iomega = 1i*omega;
    iomega2 = 1i*omega;
    iomega3 = -1i*omega;
    um2[] = um[];
    um3[] = conj(um[]);
    temp = vT(0, XMh, tgv = -10);
    temp *= 0.5; //3.0/6.0
    //  C: fundamental modification due to quadratic interaction of fundamental with 2nd order modification B
    ik = 1i*real(sym);
    ik2 = 0.0;
    iomega = 1i*omega;
    iomega2 = 0.0;
    ChangeNumbering(J, um2[], qAAs, inverse = true, exchange = true); // FreeFEM to PETSc
    temp += vH(0, XMh, tgv = -10);
    //  D: fundamental modification due to quadratic interaction of fundamental with 2nd order modification C
    ik = -1i*real(sym);
    ik2 = 2i*real(sym);
    iomega = -1i*omega;
    iomega2 = 2i*omega;
    um[] = conj(um[]);
    ChangeNumbering(J, um2[], qAA, inverse = true, exchange = true); // FreeFEM to PETSc
    temp += vH(0, XMh, tgv = -10);
    beta = -J(uma[], temp);
    um[] = conj(um[]);
  } else {
    for (int k = 0; k < paramnames.n; ++k){
      alpha[paramnames[k]] = 0.0;
    }
    beta = 0.0;
  }
  if(mpirank==0 && adapt) { // Save adapted mesh
    cout << "  Saving adapted mesh '" + meshout + "' in '" + workdir + "'." << endl;
    savemesh(Thg, workdir + meshout);
  }
  ChangeNumbering(J, ub[], qa(0:qa.n - (mpirank == 0 ? 3 : 1)), inverse = true);
  ChangeNumbering(J, um[], qm, inverse = true);
  ChangeNumbering(J, uma[], qma, inverse = true);
  savehopf(fileout, "", meshout, sym, omega, alpha, beta, true, true);
}
