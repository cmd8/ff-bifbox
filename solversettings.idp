//
// settings.idp
// Chris Douglas
// chris.douglas@ladhyx.polytechnique.fr
//
// NOTE: When starting a project this is one of the main files that should be edited
//
// Set dimension macro for 'macro_ddm.idp' (2)
macro dimension()2//EOM NOTE: only 2 for now
// Set coordinate system (cartesian or cylindrical)
macro coordinates()cylindrical//EOM
// Set number of vector components (2 or 3)
macro component()3//EOM
// Set equations (incomp, lowmach, comp, lowmachreact, compreact, or custom)
macro formulation()lowmachreact//EOM
include "macro_ddm.idp"
verbosity = getARGV("-v",0);
// Define parameter and monitor names
IFMACRO(formulation,incomp)
  string[int] paramnames = ["Re"]; // set parameter names
  string[int] monitornames = [""]; // set monitor names
  macro pressure()1//EOM
ENDIFMACRO
IFMACRO(formulation,lowmach)
  string[int] paramnames = ["Re","Pe","a"]; // set parameter names
  string[int] monitornames = [""]; // set monitor names
  macro temperature()1//EOM
  macro pressure()1//EOM
ENDIFMACRO
IFMACRO(formulation,comp)
  string[int] paramnames = ["Re","Pe","Ma","ga","a"]; // set parameter names
  string[int] monitornames = [""]; // set monitor names
  macro temperature()1//EOM
  macro density()1//EOM
  macro compressible()1//EOM
ENDIFMACRO
IFMACRO(formulation,lowmachreact)
  string[int] paramnames = ["Re","Pe","Le","dT","Ze","Da","a"]; // set parameter names
  string[int] monitornames = ["xqmax"]; // set monitor names
  macro species()1//EOM
  macro temperature()1//EOM
  macro pressure()1//EOM
ENDIFMACRO
IFMACRO(formulation,compreact)
  string[int] paramnames = ["Re","Pe","Le","dT","Ze","Da","Ma","ga","a"]; // set parameter names
  string[int] monitornames = ["xqmax"]; // set monitor names
  macro species()1//EOM
  macro temperature()1//EOM
  macro density()1//EOM
  macro compressible()1//EOM
ENDIFMACRO
IFMACRO(formulation,custom)
// NOTE: Edit this one
  string[int] paramnames = ["Re","S","v0","d0","cb1","sig","cb2","kap","cw2","cw3","cv1","ct3","ct4","cw1"]; // set parameter names
  string[int] monitornames = ["Sn","minuCL","maxnu"]; // set monitor names
  macro custom()1//EOM
  macro defu(u)[u,u#y, IFMACRO(component,3) u#z, ENDIFMACRO u#v, u#p, u#pc]//EOM
  macro initu(i)[i, i, IFMACRO(component,3) i, ENDIFMACRO i, i, i]//EOM
  macro InitialConditions() [0,0, IFMACRO(component,3) 0, ENDIFMACRO 0, 0, 0]//EOM
  func Pk = [P2,P2, IFMACRO(component,3) P2, ENDIFMACRO P2, P1, P1];
  macro deff(f)[f,f#y IFMACRO(component,3) ,f#z ENDIFMACRO]//EOM
  macro initf(i)[i, i IFMACRO(component,3) ,i ENDIFMACRO]//EOM
  func Pkf = [P2,P2 IFMACRO(component,3) ,P2 ENDIFMACRO];
  macro u2u(u)[u,u#y, IFMACRO(component,3) 0, ENDIFMACRO u#v, u#p, 0]//EOM
  macro f2u(f)[f,f#y, IFMACRO(component,3) f#z,ENDIFMACRO 0, 0, 0]//EOM
  macro adaptu(u)[u, u#y IFMACRO(component,3) ,u#z ENDIFMACRO] , u#v, u#p //EOM
  macro adaptf(f)[f, f#y IFMACRO(component,3) ,f#z ENDIFMACRO] //EOM
  int[int] ParaviewOrder = [1, 1, 1];
  string ParaviewDataName = "velocity viscosity pressure";
ENDIFMACRO
IFMACRO(!custom)
  macro defu(u)[u,u#y    IFMACRO(component,3) ,u#z ENDIFMACRO  IFMACRO(species) ,u#Y ENDIFMACRO IFMACRO(temperature) ,u#T ENDIFMACRO IFMACRO(density) ,u#R ENDIFMACRO IFMACRO(pressure) ,u#p ENDIFMACRO]//EOM
  macro initu(i)[i, i    IFMACRO(component,3) ,i   ENDIFMACRO  IFMACRO(species) ,i   ENDIFMACRO IFMACRO(temperature) ,i   ENDIFMACRO ,i]//EOM
  func Pk = [P2,P2       IFMACRO(component,3) ,P2  ENDIFMACRO  IFMACRO(species) ,P2  ENDIFMACRO IFMACRO(temperature) ,P2  ENDIFMACRO ,P1];
  macro deff(f)[f,f#y    IFMACRO(component,3) ,f#z ENDIFMACRO]//EOM
  macro initf(i)[i, i    IFMACRO(component,3) ,i   ENDIFMACRO]//EOM
  func Pkf = [P2,P2      IFMACRO(component,3) ,P2  ENDIFMACRO];
  macro u2u(u)[u,u#y     IFMACRO(component,3) ,0   ENDIFMACRO  IFMACRO(species) ,u#Y ENDIFMACRO IFMACRO(temperature) ,u#T ENDIFMACRO IFMACRO(density) ,u#R ENDIFMACRO IFMACRO(pressure) ,u#p ENDIFMACRO]//EOM
  macro f2u(f)[f,f#y     IFMACRO(component,3) ,f#z ENDIFMACRO  IFMACRO(species) ,0   ENDIFMACRO IFMACRO(temperature) ,0   ENDIFMACRO ,0]//EOM
  macro adaptu(u)[u, u#y IFMACRO(component,3) ,u#z ENDIFMACRO] IFMACRO(species) ,u#Y ENDIFMACRO IFMACRO(temperature) ,u#T ENDIFMACRO IFMACRO(density) ,u#R ENDIFMACRO IFMACRO(pressure) ,u#p ENDIFMACRO//EOM
  macro adaptf(f)[f, f#y IFMACRO(component,3) ,f#z ENDIFMACRO] //EOM
  int[int] ParaviewOrder = [1                                  IFMACRO(species) ,1 ENDIFMACRO IFMACRO(temperature) ,1 ENDIFMACRO ,1];
  string ParaviewDataName = "velocity"  IFMACRO(species) + " species" ENDIFMACRO IFMACRO(temperature) + " temperature" ENDIFMACRO IFMACRO(density) + " density" ENDIFMACRO IFMACRO(pressure) + " pressure" ENDIFMACRO;
ENDIFMACRO
IFMACRO(!InitialConditions)
  macro InitialConditions()initu(1)//EOM
ENDIFMACRO
// Boundary labels and boundary conditions
IFMACRO(!custom)
/*
int BCnull = 0;
int BCaxis = 1;
int BCopen = 2;
int BCinflow = 3;
int BCwall = 4;
int BCslip = 5;
macro BoundaryConditions(m, u, U)
  on(BCwall, u = U, u#y = U#y IFMACRO(component,3) ,u#z = U#z ENDIFMACRO IFMACRO(temperature) ,u#T = U#T - 1.0 ENDIFMACRO )
+ on(BCslip, u#y = U#y IFMACRO(component,3) ,u#z = U#z ENDIFMACRO )
+ on(BCinflow, u = U - 1., u#y = U#y IFMACRO(component,3) ,u#z = U#z ENDIFMACRO IFMACRO(species) ,u#Y = U#Y - 1.0 ENDIFMACRO IFMACRO(temperature) ,u#T = U#T - 1.0 ENDIFMACRO )
// EOM
macro HomBoundaryConditions(m, u)
  on(BCwall, u = 0, u#y = 0 IFMACRO(component,3) ,u#z = 0 ENDIFMACRO IFMACRO(temperature) ,u#T = 0 ENDIFMACRO )
+ on(BCslip, u#y = 0 IFMACRO(component,3) ,u#z = 0 ENDIFMACRO )
+ on(BCinflow, u = 0., u#y = 0 IFMACRO(component,3) ,u#z = 0 ENDIFMACRO IFMACRO(species) ,u#Y = 0.0 ENDIFMACRO IFMACRO(temperature) ,u#T = 0.0 ENDIFMACRO )
// EOM
*/
int BCinternal = 0;
int BCaxis = 1;
int BCopen = 2;
int BCwall = 3;
int BCinflow = 4;
int BCpipe = 5;
int BCslip = 6;
macro BoundaryConditions(m, u, U)
  on(BCinflow, u = U - 2.0*(1.0 - (2.0*y)^2), u#y = U#y IFMACRO(component,3) ,u#z = U#z ENDIFMACRO IFMACRO(species) ,u#Y = U#Y - 1.0 ENDIFMACRO IFMACRO(temperature) ,u#T = U#T - 1.0 ENDIFMACRO )
+ on(BCwall, BCpipe, u = U, u#y = U#y IFMACRO(component,3) ,u#z = U#z ENDIFMACRO IFMACRO(temperature) ,u#T = U#T - 1.0 ENDIFMACRO )
+ on((abs(int(m)) != 1)*BCaxis, u#y = U#y IFMACRO(component,3) ,u#z = U#z ENDIFMACRO )
+ on((abs(int(m))  > 0)*BCaxis, u = U IFMACRO(species) ,u#Y = U#Y ENDIFMACRO IFMACRO(temperature) ,u#T = U#T ENDIFMACRO )
// EOM
macro HomBoundaryConditions(m, u)
  on(BCinflow, u = 0., u#y = 0 IFMACRO(component,3) ,u#z = 0 ENDIFMACRO IFMACRO(species) ,u#Y = 0.0 ENDIFMACRO IFMACRO(temperature) ,u#T = 0.0 ENDIFMACRO )
+ on(BCwall, BCpipe, u = 0, u#y = 0 IFMACRO(component,3) ,u#z = 0 ENDIFMACRO IFMACRO(temperature) ,u#T = 0 ENDIFMACRO )
+ on((abs(int(m)) != 1)*BCaxis, u#y = 0 IFMACRO(component,3) ,u#z = 0 ENDIFMACRO )
+ on((abs(int(m))  > 0)*BCaxis, u = 0 IFMACRO(species) ,u#Y = 0 ENDIFMACRO IFMACRO(temperature) ,u#T = 0 ENDIFMACRO )
// EOM
ENDIFMACRO
IFMACRO(custom)
int BCnull = 0;
int BCaxis = 1;
int BCopen = 2;
int BCin2  = 3;
int BCwall = 4;
int BCin1  = 5;
macro BoundaryConditions(m, u, U)
  on(BCin2,BCwall, u = U, u#y = U#y IFMACRO(component,3) ,u#z = U#z ENDIFMACRO, u#v = U#v, u#pc = U#pc )
+ on(BCin1, u = U - tanh(params["d0"]*(1.0 - y^2.0)), u#y = U#y IFMACRO(component,3) ,u#z = U#z - params["S"]*y*tanh(params["d0"]*(1.0 - y^2.0)) ENDIFMACRO , u#v = U#v - params["v0"], u#pc = U#pc )
+ on((abs(int(m)) != 1)*BCaxis, u#y = U#y IFMACRO(component,3) ,u#z = U#z ENDIFMACRO )
+ on((abs(int(m))  > 0)*BCaxis, u = U, u#v = U#v )
// EOM
ENDIFMACRO

// Define solution monitors to extract
macro getmonitors(u)
  IFMACRO(custom){
  fespace Xh1(Thg, P2);
  Xh1 UX = u, UZ = u#z, UV = (1.0 + u#v*fv1(u));
  varf Onaxis(UX, VX) = on(BCaxis, UX = 1);
  real[int] onaxis = Onaxis(0, Xh1, tgv = 1);
  int[int] indices(onaxis.sum);
  for(int i=0, j=0; i<Xh1.ndof; ++i) if(onaxis[i]) {indices[j] = i; ++j;}
  real[int] uonaxis(indices.n);
  for(int i=0; i<indices.n; ++i) uonaxis[i] = UX[][indices[i]];
  monitors["maxnu"] = UV[].max;
  monitors["minuCL"] = uonaxis.min;
  monitors["Sn"] = int1d(Thg, levelset=x)(UX*UZ*y^2)/(1e-12+int1d(Thg, levelset=x)(y*UX*UX));
  }  ENDIFMACRO
  IFMACRO(species) IFMACRO(temperature){
  fespace Xh1(Thg, P2);
  IFMACRO(formulation,compreact)
  Xh1 RR = u#R*u#Y*exp(-params["Ze"]/params["dT"]*(1.0 + params["dT"])*(1.0 + params["dT"] - u#T)/(u#T + 1e-12)), Xpoints = x;
  ENDIFMACRO
  IFMACRO(formulation,lowmachreact)
  Xh1 RR = u#Y/(u#T + 1e-12)*exp(-params["Ze"]/params["dT"]*(1.0 + params["dT"])*(1.0 + params["dT"] - u#T)/(u#T + 1e-12)), Xpoints = x;
  ENDIFMACRO
  varf Onaxis(RR, VX) = int2d(Th)(0*RR*VX) + on(BCaxis, RR = 1);
  real[int] onaxis = Onaxis(0, Xh1, tgv = 1);
  int[int] indices(onaxis.sum);
  for(int i=0, j=0; i<Xh1.ndof; ++i) if(onaxis[i]) {indices[j] = i; ++j;}
  real[int] RRonaxis(indices.n);
  for(int i=0; i<indices.n; ++i) RRonaxis[i] = RR[][indices[i]];
  real xqmax = RRonaxis.max;
  for(int i=0; i<indices.n; ++i) if(abs(RRonaxis[i] - xqmax) < 1e-12) {xqmax = Xpoints[][indices[i]]; break;}
  monitors["xqmax"] = xqmax;
} ENDIFMACRO ENDIFMACRO
  // EOM

// term macros ------------------------------------------------------
macro r1() (1.0 /(y + 1.0e-12*(y==0))) // EOM

macro ndotu(u) (N.x*u + N.y*u#y) //EOM

IFMACRO(coordinates,cartesian)
macro ndotgrads(s) ( N.x*dx(s) + N.y*dy(s)) // EOM

macro tdotgrads(s) (-N.y*dx(s) + N.x*dy(s)) //EOM NOTE: grid scaling factors cancel

macro gdotf(g,f) ( g*f )//EOM

macro vdotu(v, u) ( v*u + v#y*u#y IFMACRO(component,3)+ v#z*u#z ENDIFMACRO) //EOM

macro divu(ik, u) ( dx(u) + dy(u#y) IFMACRO(component,3) + (ik)*u#z ENDIFMACRO ) // velocity divergence

macro ndotvisc(v, ik, u) (N.x*(v*(dx(u  ) - 2./3.*divu(ik, u)) + v#y*dy(u  )                       IFMACRO(component,3) + v#z*(ik)*u   ENDIFMACRO )
                        + N.y*(v*dx(u#y)                       + v#y*(dy(u#y) - 2./3.*divu(ik, u)) IFMACRO(component,3) + v#z*(ik)*u#y ENDIFMACRO )) //EOM

macro ugradu(v, U, ik, u) (  v  *(U*dx(u  ) + U#y*dy(u  ) IFMACRO(component,3) + (ik)*U#z*u ENDIFMACRO )
                           + v#y*(U*dx(u#y) + U#y*dy(u#y) IFMACRO(component,3) + (ik)*U#z*u#y ENDIFMACRO )
      IFMACRO(component,3) + v#z*(U*dx(u#z) + U#y*dy(u#z)                      + (ik)*U#z*u#z) ENDIFMACRO ) // scaled convection term

macro visc(ij, v, ik, u)   ( dx(v  )*(2.*dx(u  ) - 2./3.*divu(ik, u))  + dy(v  )*(dx(u#y) + dy(u  ))              IFMACRO(component,3) + (ij)*v  *(dx(u#z) + (ik)*u   ) ENDIFMACRO
                           + dx(v#y)*(dx(u#y) + dy(u  ))               + dy(v#y)*(2.*dy(u#y) - 2./3.*divu(ik, u)) IFMACRO(component,3) + (ij)*v#y*((ik)*u#y + dy(u#z) ) ENDIFMACRO
      IFMACRO(component,3) + dx(v#z)*((ik)*u + dx(u#z))                + dy(v#z)*((ik)*u#y + dy(u#z))                                  + (ij)*v#z*(2.*(ik)*u#z - 2./3.*divu(ik, u)) ENDIFMACRO ) // EOM

macro diff(ij, g, ik, f) ( dx(g)*dx(f) + dy(g)*dy(f) IFMACRO(component,3)+ (ij)*(ik)*g*f ENDIFMACRO ) // EOM

macro ugradf(U, ik, f)   ( U*dx(f) + U#y*dy(f) IFMACRO(component,3) + (ik)*U#z*f ENDIFMACRO ) // EOM

macro Daexp(u) ( params["Da"]*exp(-params["Ze"]/params["dT"]*(1.0 + params["dT"])*(1.0 + params["dT"] - u#T)/u#T) ) // EOM
ENDIFMACRO
IFMACRO(coordinates,cylindrical)

macro ndotgrads(s) ( y*N.x*dx(s) + y*N.y*dy(s)) // EOM

macro tdotgrads(s) (-y*N.y*dx(s) + y*N.x*dy(s)) //EOM NOTE: grid scaling factors cancel

macro gdotf(f,g) ( y*g*f )//EOM

macro vdotu(v,u) ( y*v*u + y*v#y*u#y IFMACRO(component,3) + y*v#z*u#z ENDIFMACRO) //EOM

macro divu(ik, u) ( y*dx(u) + y*dy(u#y) + u#y IFMACRO(component,3) + (ik)*u#z ENDIFMACRO ) // velocity divergence

macro ndotvisc(v, ik, u) (N.x*(v*(y*dx(u  ) IFMACRO(compressible,1) - 2./3.*divu(ik, u) ENDIFMACRO) + y*v#y*dy(u  )                       IFMACRO(component,3) + v#z*(ik)*u ENDIFMACRO )
                        + N.y*(v* y*dx(u#y)                      + v#y*(y*dy(u#y) IFMACRO(compressible,1) - 2./3.*divu(ik, u) ENDIFMACRO) IFMACRO(component,3) + v#z*((ik)*u#y - u#z) ENDIFMACRO )) //EOM

macro ugradu(v, U, ik, u) (  v  *(y*U*dx(u  ) + y*U#y*dy(u  ) IFMACRO(component,3) + (ik)*U#z*u ENDIFMACRO )
                           + v#y*(y*U*dx(u#y) + y*U#y*dy(u#y) IFMACRO(component,3) + (ik)*U#z*u#y - U#z*u#z ENDIFMACRO )
      IFMACRO(component,3) + v#z*(y*U*dx(u#z) + y*U#y*dy(u#z)                      + (ik)*U#z*u#z + U#z*u#y) ENDIFMACRO ) // scaled convection term

macro visc(ij, v, ik, u) (   dx(v  )*(2.*y*dx(u  ) IFMACRO(compressible,1) - 2./3.*divu(ik, u) ENDIFMACRO) + y*dy(v  )*(dx(u#y) + dy(u  ))                     + r1*(ij)*v   *( IFMACRO(component,3) y*dx(u#z) + ENDIFMACRO (ik)*u)
                         + y*dx(v#y)*(dx(u#y) + dy(u  ))                +   dy(v#y)*(2.*y*dy(u#y) IFMACRO(compressible,1) - 2./3.*divu(ik, u) ENDIFMACRO)      + r1*((ij)*v#y IFMACRO(component,3) - v#z ENDIFMACRO )*((ik)*u#y IFMACRO(component,3) - u#z + y*dy(u#z) ENDIFMACRO )
      IFMACRO(component,3) + dx(v#z)*((ik)*u + y*dx(u#z))               +   dy(v#z)*((ik)*u#y - u#z + y*dy(u#z)) ENDIFMACRO + r1*( IFMACRO(component,3) (ij)*v#z + ENDIFMACRO v#y)*( 2.*( IFMACRO(component,3) (ik)*u#z + ENDIFMACRO u#y) IFMACRO(compressible,1) - 2./3.*divu(ik, u) ENDIFMACRO) ) // EOM

macro diff(ij, g, ik, f) ( y*dx(g)*dx(f) + y*dy(g)*dy(f) IFMACRO(component,3) + (ij)*(ik)*r1*g*f ENDIFMACRO ) // EOM

macro ugradf(U, ik, f) ( y*U*dx(f) + y*U#y*dy(f) IFMACRO(component,3) + (ik)*U#z*f ENDIFMACRO ) // EOM

macro Daexp(u) ( y*params["Da"]*exp(-params["Ze"]/params["dT"]*(1.0 + params["dT"])*(1.0 + params["dT"] - u#T)/u#T) ) // EOM

IFMACRO(custom)
// S-A macros from NASA: https://turbmodels.larc.nasa.gov/spalart.html#sa
macro fv1(u) ( u#v^3.0/(u#v^3.0 + params["cv1"]^3.0)) // EOM
macro fv1p(u,du) ( 3.0*params["cv1"]^3*u#v^2.0*du#v/(u#v^3.0 + params["cv1"]^3.0)^2.0) // EOM

macro dist() (  (y > 1.00001 && y >  x + 2.00001)*(x + 1.00001)
              + (y > 1.00001 && y <= x + 2.00001)*(  (x >  0)*sqrt(x^2 + (y - 1.00001)^2)
                                                   + (x <= 0)*(y - 1.00001) )
              + (y > 1.0 && y <= 1.00001)*(x)
              + (y <= 1.0)*(  (x >  0)*sqrt(x^2 + (1.0 - y)^2)
                            + (x <= 0)*(1.0 - y) ) ) // EOM

macro S(u) ( Ome(u) + y*u#v*fv2(u)/(params["Re"]*params["kap"]^2.0*dist^2.0) ) // EOM
macro SSp(u,ik,du) ( Omep(u,ik,du) + y*(du#v*fv2(u) + u#v*fv2p(u,du))/(params["Re"]*params["kap"]^2.0*dist^2.0) ) // EOM

macro fv2(u) (1.0 - u#v/(1.0 + u#v*fv1(u))) // EOM
macro fv2p(u,du) ( (u#v^2.0*fv1p(u,du) - du#v)/(1.0 + u#v*fv1(u))^2.0 ) // EOM

macro fw(u) (g(u)*((1.0 + params["cw3"]^6.0)/(g(u)^6.0 + params["cw3"]^6))^(1.0/6.0)) // EOM
macro fwp(u,ik,du) (params["cw3"]^6.0*gp(u,ik,du)/(1.0 + params["cw3"]^6.0)*((1.0 + params["cw3"]^6.0)/(g(u)^6.0 + params["cw3"]^6.0))^(7.0/6.0) ) // EOM

macro g(u) (r(u) + params["cw2"]*(r(u)^6.0 - r(u))) // EOM
macro gp(u,ik,du) ((1.0 + params["cw2"]*(6.0*r(u)^5.0 - 1.0))*rp(u,ik,du)) // EOM

macro r(u) (min(y*u#v/(params["Re"]*S(u)*params["kap"]^2.0*dist^2.0),10.0)) // EOM
macro rp(u,ik,du) ( ((y*u#v/(params["Re"]*S(u)*params["kap"]^2.0*dist^2.0))<10.0)*y*(du#v/(params["Re"]*S(u)*params["kap"]^2.0*dist^2.0) - u#v*SSp(u,m,du)/(params["Re"]*S(u)^2.0*params["kap"]^2.0*dist^2.0)) ) // EOM

macro ft2(u) (params["ct3"]*exp(-params["ct4"]*u#v^2.0)) // EOM
macro ft2p(u,du) (-2.0*params["ct4"]*params["ct3"]*u#v*du#v*exp(-params["ct4"]*u#v^2.0)) // EOM

macro Ome(u) ( max(sqrt((y*dy(u#z) + u#z)*(y*dy(u#z) + u#z) + (-y*dx(u#z))*(-y*dx(u#z)) + (y*(dx(u#y) - dy(u)))*(y*(dx(u#y) - dy(u)))),1e-10) ) // EOM
macro Omep(u,ik,du) ( ((y*dy(u#z) + u#z)*(y*dy(du#z) + du#z - (ik)*du#y) + (-y*dx(u#z))*(-y*dx(du#z) + (ik)*du) + (y*(dx(u#y) - dy(u)))*(y*(dx(du#y) - dy(du))))/Ome(u) ) // EOM
ENDIFMACRO
ENDIFMACRO
